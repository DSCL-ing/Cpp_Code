[toc]

## 字符串原始字面值

语法:
R"16字符以内相同注释(保持原始输出的值)16字符以内相同注释"

```
int main() {

    std::cout<<R"必须相同的注释(
    <html>
    <head>
    <title>
    主题
    </title>
    </head>
    </html> 
    )必须相同的注释"<<"\n";
    return 0;
}
```

![image-20240619114733255](C++11常用特性.assets/image-20240619114733255.png)





## 超长整型long long

- long long也是C语言关键字,但long long是在C++11标准中正式加入

- C++11要求long long至少占8字节,不同平台标准不一样,可能8字节,也可能16,32字节.

- 表示形式

  ```
  long int n1 = 100L;
  long long n2 = 100LL;
  unsigned long long n3 = 100ULL;
  ```

- 等价类型

  ```
  int main() {
      long long n1;
      long long int n2;
      signed long long n3;
      signed long long int n4;
      std::cout<<typeid(n1).name()<<"\n";
      std::cout<<typeid(n2).name()<<"\n";
      std::cout<<typeid(n3).name()<<"\n";
      std::cout<<typeid(n4).name()<<"\n";
      return 0;
  }
  ```

  ![image-20240619135404157](C++11常用特性.assets/image-20240619135404157.png)

- 取值范围

  C++11提供了三个宏

  LLONG_MAX:signed long long int 的最大值

  LLONG_MIN:signed long long int 的最小值

  ULONG_MAX:unsiged long long int 的最大值(也等于2*LLONG_MAX)

  (无符号的最小值为0)

  计算方式:无符号,`2^比特位数==2^(字节数*8);`,8字节为`2^(8*8)== 2^64`;有符号,`2^(64-1)`;

- C++11定义的5种标准有符号整型

  - signed char, 1字节
  - short int, 2字节
  - int, 4字节
  - long int, 32位下4字节,64位下8字节
  - long long int, 最小占8字节.

  无符号5种在前面加上unsigned.



## static_assert

C语言中<cassert>是运行时断言,C++中static_assert是编译时断言.

语法:static_assert(常量表达式,"自定义代码提示");

static_assert的常量表达式必须要在编译期间能计算出来



## noexcept

### C++98异常抛出方法:

`void func() throw(int ,double){}` 表示只能抛出int,double类型的异常

`void func() throw(){}` 表示不抛出任何异常

`void func(){}`表示抛出异常没有类型限制

### C++11中如果不需要抛出异常:

`void func() noexcept{}` 表示不抛出任何异常,就算内部抛出,noexcept也会自动终止异常抛出,或者报错

### noexcept还可以带参数

`void func() noexcept(常量表达式,返回值为bool类型) {}`

如果表达式为true,和noexcept一样,不抛异常.

如果表达式为false,则会抛异常

一般在模板里使用.



## to_string

C++11提供了数值类型与字符串转换函数重载函数,头文件 `<string>`

[to_string - C++ Reference (cplusplus.com)](https://legacy.cplusplus.com/reference/string/to_string/)

数值转字符串

```
string to_string (int val);
string to_string (long val);
string to_string (long long val);
string to_string (unsigned val);
string to_string (unsigned long val);
string to_string (unsigned long long val);
string to_string (float val);
string to_string (double val);
string to_string (long double val);
```

字符串转数值

[标准库标头  - cppreference.com](https://zh.cppreference.com/w/cpp/header/string)

```
int       stoi ( const std::string& str, std::size_t* pos = nullptr, int base = 10 );
long      stol ( const std::string& str, std::size_t* pos = nullptr, int base = 10 );
long long stoll( const std::string& str, std::size_t* pos = nullptr, int base = 10 );

unsigned long      stoul ( const std::string& str, std::size_t* pos = nullptr, int base = 10 );
unsigned long long stoull( const std::string& str, std::size_t* pos = nullptr, int base = 10 );

float       stof ( const std::string& str, std::size_t* pos = nullptr );
double      stod ( const std::string& str, std::size_t* pos = nullptr );
long double stold( const std::string& str, std::size_t* pos = nullptr );
```

参数:

str是需要转成数值的字符串

pos:如果 pos 不是空指针,那么指针 ptr 会接收 str.c_str() 中首个未转换字符的地址,将计算该字符的下标它存储到 `*pos`;缺省是nullptr

base:进制数,base的值就代表所转换的进制数;缺省是10;如果 `base` 是 0,那么自动检测数值进制;如果前缀是 `0,`那么底是八进制,如果前缀是 `0x` 或 `0X`,那么底是十六进制,否则底是十进制.

演示

```
#include<string>

int main() {
    std::string str = "123a123a";
    size_t n= 0;
    int a = std::stoi(str,&n, 10);
    std::cout<<a<<", char:"<<n << "\n";

    return 0;
}
```

![image-20240619181753584](C++11常用特性.assets/image-20240619181753584.png)





## decltype 

decltype == declare type

### 语法: 

- decltype(表达式) 变量名;

- decltype((表达式)) 引用;

```
struct A {
    int _a;
};

int main() {
    A a;
    decltype(a._a) t = 1;
    decltype((a._a)) tref= t;
    return 0;
}
```

![image-20240624202324684](C++11常用特性.assets/image-20240624202324684.png)

### 功能:

- 简化类模板编写

  举例: const对象与非const对象的类模板处理

  ```
  template<typename T>
  struct Container {
      void Traversal(T& t) {
          for (_it = t.begin(); _it != t.end(); _it++) {
              std::cout<< *_it << " ";
          }
      }
      //typename T::iterator _it;
      decltype(T().begin()) _it;  //也可以这样
  };
  
  int main() {
      std::list<int> lt{ 1,2,3,4,5,6 };
      Container<std::list<int>> con;
      //Container<const std::list<int>> con;
      con.Traversal(lt);
      return 0;
  }
  ```

  当传入非const对象时, 遍历list使用两种方式定义成员变量类型都满足需求

  `typename T::iterator _it;`

  ![image-20240624205830864](C++11常用特性.assets/image-20240624205830864.png)

  `decltype(T().begin()) _it;`

  ![image-20240624210012737](C++11常用特性.assets/image-20240624210012737.png)

  但如果传入的是const对象.此时`typename T::iterator _it;`这样的定义方式就无法满足,

  ![image-20240624210318622](C++11常用特性.assets/image-20240624210318622.png)

  而`decltype(T().begin()) _it;`都能满足两种方式:

  ![image-20240624210413603](C++11常用特性.assets/image-20240624210413603.png)

  因为类型是推导出来的,由编译器在编译期间自动识别,更加灵活.

  因此,decltype在模板编程中,能起到很好地简化实现的作用.



## 强类型枚举 enum class/struct

先看C++11之前,C++98的枚举(C风格)

```
#include<iostream>

enum { yellow, orange };
enum color { red,yellow, blue };

int main() {
    std::cout<<color::yellow<<"\n";
    return 0;
}
```

运行结果:

![image-20240624173300963](C++11常用特性.assets/image-20240624173300963.png)

C风格枚举是全局可见.显然不符合面向对象封装特性.(此处全局指域内可见,如果在全局域,则全局可见;在类域则仅类域可见,在函数体内,则函数体内可见)

多个枚举有相同的属性时,会发生重定义行为,有着明先缺陷.

之后,在C++11中引入了enum class

### 举例

```
#include<iostream>

enum struct color { red,yellow, blue };

int main() {
    printf("%d",color::yellow);
    return 0;
}
```



### 特点

- 强作用域

  使用时必须指明作用域,`color::yellow;`

- 转换限制

  Description:强类型枚举成员的值不可以与整型发生隐式类型转化

  Example1:不能隐式类型转换

  ![image-20240624211051939](C++11常用特性.assets/image-20240624211051939.png)

  Example2:可以显式相近类型转换

  ![image-20240624212105917](C++11常用特性.assets/image-20240624212105917.png)

- 可以指定底层类型

  语法:

  enum class/struct 类型名 : 底层类型 { 成员 };

  `enum struct Color : char { blue, red, yellow };`

  //不能指定wchar_t,宽字节类型

  //C++11后普通枚举也支持指定底层类型



## 匿名联合体作为类成员

木叶村要进行第99次人口普查，人员的登记方式如下：
    - 学生只需要登记所在学校的编号
        - 本村学生以外的人员需要登记其身份证号码
        - 本村外来人员需要登记户口所在地+联系方式

```
// 外来人口信息
struct Foreigner
{
    Foreigner(string s, string ph) : addr(s), phone(ph) {}
    string addr;
    string phone;
};

// 登记人口信息
class Person
{
public:
    enum class Category : char {Student, Local, Foreign};
    Person(int num) : number(num), type(Category::Student) {}
    Person(string id) : idNum(id), type(Category::Local) {}
    Person(string addr, string phone) : foreign(addr, phone), type(Category::Foreign) {}
    ~Person() {}

    void print()
    {
        cout << "Person category: " << (int)type << endl;
        switch (type)
        {
        case Category::Student:
            cout << "Student school number: " << number << endl;
            break;
        case Category::Local:
            cout << "Local people ID number: " << idNum << endl;
            break;
        case Category::Foreign:
            cout << "Foreigner address: " << foreign.addr
                << ", phone: " << foreign.phone << endl;
            break;
        default:
            break;
        }
    }

private:
    Category type;
    union
    {
        int number;
        string idNum;
        Foreigner foreign;
    };
};

int main()
{
    Person p1(9527);
    Person p2("1101122022X");
    Person p3("砂隐村村北", "1301810001");
    p1.print();
    p2.print();
    p3.print();
    return 0;
}
```

输出结果:

```
Person category: 0
Student school number: 9527
Person category: 1
Local people ID number: 1101122022X
Person category: 2
Foreigner address: 砂隐村村北, phone: 1301810001
```

根据需求我们将木叶村的人口分为了三类并通过枚举记录了下来，在Person类中添加了一个匿名的非受限联合体用来存储人口信息，仔细分析之后就会发现这种处理方式的优势非常明显：尽可能地节省了内存空间。

1. Person类可以直接访问匿名非受限联合体内部的数据成员。
2. 不使用匿名非受限联合体申请的内存空间等于 number、 idNum 、 foreign 三者内存之和。
3. 使用匿名非受限联合体之后number、 idNum 、 foreign 三者共用同一块内存。



## chrono库

C++11中提供了日期和时间相关的库chrono，通过chrono库可以很方便地处理日期和时间，为程序的开发提供了便利。chrono库主要包含三种类型的类：`时间间隔duration`、`时钟clocks`、`时间点time point`。 

### 时间间隔duration

1. 常用类成员

`duration表示一段时间间隔`，用来记录时间长度，可以表示几秒、几分钟、几个小时的时间间隔。duration的原型如下：

```
// 定义于头文件 <chrono>
template< 
	class Rep, 
	class Period = std::ratio<1> 
> class duration;
```

模板参数:

- `Rep`：Representation(表示),这是一个数值类型，用于**表示**时钟数（周期）的类型（默认为整形）。若 `Rep` 是浮点数，则 `duration` 能使用小数描述时钟周期的数目。

- `Period`：表示时钟的周期，它的原型如下：

  ```
  // 定义于头文件 <ratio>
  template<
      std::intmax_t Num,
      std::intmax_t Denom = 1
  > class ratio;
  ```

  `ratio`(比率;比例)类表示`每个时钟周期的单位`,如秒、毫秒、微秒，其中第一个模板参数`Num(Numerator)代表分子`，`Denom(denominator)代表分母`，该分母值默认为1，因此，`ratio代表的是一个分子除以分母的数值`，比如：ratio<2>代表一个时钟周期是2秒，ratio<60>代表一分钟，ratio<60\*60>代表一个小时，ratio<60\*60\*24>代表一天。而ratio<1,1000>代表的是1/1000秒，也就是1毫秒，ratio<1,1000000>代表一微秒，ratio<1,1000000000>代表一纳秒。

  >为了方便使用，在标准库中定义了一些常用的时间间隔，比如：时、分、秒、毫秒、微秒、纳秒，它们都位于chrono命名空间下，定义如下：
  >
  >| 类型                                | 定义                                             |
  >| ----------------------------------- | ------------------------------------------------ |
  >| 纳秒：**std::chrono::nanoseconds**  | using nanoseconds  = duration<long long, nano>;  |
  >| 微秒：**std::chrono::microseconds** | using microseconds = duration<long long, micro>; |
  >| 毫秒：**std::chrono::milliseconds** | using milliseconds = duration<long long, milli>; |
  >| 秒  ：**std::chrono::seconds**      | using seconds      = duration<long long>;        |
  >| 分钟：**std::chrono::minutes**      | using minutes      = duration<int, ratio<60>>;   |
  >| 小时：**std::chrono::hours**        | using hours        = duration<int, ratio<3600>>; |

  ![image-20240625144845831](C++11常用特性.assets/image-20240625144845831.png)

2. duration类的构造函数原型如下：

```
// 1. 拷贝构造函数
duration( const duration& ) = default;  //浅拷贝
// 2. 通过指定时钟周期的类型来构造对象
template< class Rep2 >
constexpr explicit duration( const Rep2& r ); //改变类型
// 3. 通过指定时钟周期类型，和时钟周期长度来构造对象
template< class Rep2, class Period2 >
constexpr duration( const duration<Rep2,Period2>& d );
```

3. 为了更加方便的进行duration对象之间的操作，类内部进行了操作符重载：

```
duration& operator= (const duration& rhs) = default;
constexpr duration operator+() const;
constexpr duration operator-() const;
duration& operator++();
duration  operator++(int);
duration& operator--();
duration  operator--(int);
duration& operator+= (const duration& rhs);
duration& operator-= (const duration& rhs);
duration& operator*= (const rep& r);
duration& operator/= (const rep& r);
duration& operator%= (const rep& r);
duration& operator%= (const duration& rhs);
```

![image-20240625145741710](C++11常用特性.assets/image-20240625145741710.png)

> 注意事项：duration的加减运算有一定的规则，当两个duration时钟周期不相同的时候，会先统一成一种时钟，然后再进行算术运算，统一的规则如下：假设有ratio<x1,y1> 和 ratio<x2,y2>两个时钟周期，首先需要求出x1，x2的最大公约数X，然后求出y1，y2的最小公倍数Y，统一之后的时钟周期ratio为ratio<X,Y>。

exam:

```
    std::chrono::duration<double, std::ratio<9, 7>> d1(3); //单位为9/7秒
    std::chrono::duration<double, std::ratio<6, 5>> d2(1); //单位为6/5秒
    /*
    9和6的最大公约数是3;
    7和5的最小公倍数是35;
    */
    // d1 和 d2 统一之后的时钟周期
    std::chrono::duration<double, std::ratio<3, 35>> d4 = d1 - d2; 
    auto d3 = d1 - d2;
    std::cout<<d3.count()<<"\n";
```

![image-20240625150330546](C++11常用特性.assets/image-20240625150330546.png)

4. duration类还提供了获取时间间隔的**时钟周期数**的方法count()，函数原型如下：

```
constexpr rep count() const; //计算有多少个单位
```

![image-20240625143251339](C++11常用特性.assets/image-20240625143251339.png)

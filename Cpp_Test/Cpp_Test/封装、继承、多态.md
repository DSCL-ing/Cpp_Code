# 封装、继承、多态



## 继承和组合

 组合即为在类成员是其他自定义类型:如适配器中栈,队列,反向迭代器.

 继承的耦合度高 , 组合的耦合度低

 耦合度:联系强度,软件工程领域:高内聚,低耦合; 类与类之间高耦合->解耦 ; 继承解耦->组合

 继承被称为白盒复用(white_box reuse)
 组合被称为黑箱复用(black_box reuse)

 继承是is-a关系:我就是你
 组合是has-a关系:我里面有一个你

 一般来说组合更好
 不过继承也有用武之地:面向对象三大特性,继承,封装,多态. 有继承才有多态



## 抽象类

 1.纯虚函数:在虚函数后面写上=0,则这个函数为纯虚函数  例:virtual void fun() = 0;
   纯虚函数只需要声明,不能写函数体.
   纯虚函数被继承后的派生类如果不重写,则还是抽象类 -- 直到重写为止

 2.抽象类的定义:包含纯虚函数的类叫做抽象类,也叫接口类.
 $ 抽象类不能实例化出对象.派生类继承后也不能直接实例化出对象,必须重写纯虚函数后才能实例化对象.
 $ 纯虚函数规范了派生类必须重写(强制必须重写),  典型接口继承!!!


  功能:纯虚函数是用来规范接口的



## 动态绑定和静态绑定

 1.静态绑定又称为前期绑定(早绑定),在程序编译期间就确定了程序的行为,也称为静态多态. 如:函数重载(cout<<类型自动识别等等)\code

 2.动态绑定也称为后期绑定(晚绑定),是在程序运行期间(运行时),根据具体拿到的类型确定程序的具体行为(调用具体的函数),也称为动态多态.

 

场景
 一般库里带base的,可能就是继承关系



## 继承

- 继承受权限影响
   有public protected private 三种继承

- 基本语法:   
  class 子类 : 权限 父类
   `class student : public Person`

- 使用父类成员的方法
    使用域作用限定符显式指出,语法:
     基类::基类成员
     `Person::Print();`

- 继承方式也可以不写 -- 默认是public,建议显式写出继承方式
    a.对于class,默认继承方式是私有
    b.对于struct默认继承方式是公有

- 继承可以认为是将父类当作子类的一个看不见成员  
  证明:  
  ![image-20240527141623626](封装、继承、多态.assets/image-20240527141623626.png)

- 友元关系不能被继承  
  父类的友元不是子类的友元.友元只对所在的类域有效



### 继承的访问权限

继承的访问权限的作用是将继承下来的父类成员的原有的权限进行缩小.

> 类权限  
> - public: 外部,子类都可见
> - protected: 外部不可见,子类可见
> - private: 外部,子类都不可见
> 

- 继承的访问权限表
|类成员\继承方式     |public继承            |protected继承          |private继承		  |  
|:-------------------|:---------------------|:----------------------|:--------------------|  
|基类的public成员    |派生类的public成员    |派生类的protected成员  |派生类的private成员  |  
|基类的protected成员 |派生类的protected成员 |派生类的protected成员  |派生类的private成员  |  
|基类的private成员   |在派生类中不可见      |在派生类中不可见       |在派生类中不可见	  |  

> 基类的private成员最特殊,继承后子类不可见. 其他权限成员无论被什么方式继承至少子类自己内部可见

- 继承的权限可以被缩小，但是不能放大，和const一样

- 私有继承私有成员也是继承下来了,只是对子类和外界都不可见(直接不可见). 虽然子类不可见,但是可以通过父类的方法间接去调用(间接可见)



### 子类赋值给父类
#### 赋值兼容规则
在公有继承中,子类可以赋值给父类 并且是天然支持(编译器直接行为),没有临时变量,(不是隐式类型转换,不存在类型转换发生)

1. 派生类的对象可以赋值给基类对象。
2. 派生类的对象可以初始化基类的引用。
3. 派生类对象的地址可以赋给指向基类的指针。

#### “天然”的行为

“赋值”过程是通过切片方式,通过调用父类拷贝构造/赋值运算符重载完成赋值,将从父类继承下的部分依次赋值给父类,

引用和指针也是类似，通过切片方式，直接引用/指向子类中父类的一部分,也是"天然"的,不存在类型转换的发生

> 切片不是丢弃,是划分

#### 验证:

##### 1. 其他权限继承能否支持赋值兼容规则

```
class Person{
public:
    Person(std::string name, int age) :_name(name), _age(age)
    {};
    void Print(){
        std::cout << "name:" << _name << " ";
        std::cout << "age:" << _age << " ";
        std::cout << std::endl;
    }
private:
    std::string _name;
    int _age;
};

class Student : private Person
{
public:
    Student() :Person("stu", 18) {};
    void Print1(){
        Print();
    }
private:
    int _stuid;
};

class Teacher : public Person
{
public:
    Teacher() :Person("tea", 28) {};
private:
    int _teaid;
};

class A :protected Person
{
public:
    A():Person("A",65){};
};

int main(){
    Student stu;
    stu.Print1();
    Teacher tea;
    tea.Print();

    Person per("per", 99);
    per = stu;
    per = tea;

    A a;
    per = a;

    return 0;
}
```

![image-20240526221117655](封装、继承、多态.assets/image-20240526221117655.png)

结论:只有公有继承才支持赋值兼容规则



##### 2.是否"天然",有没有产生临时变量

产生临时变量就说明是赋值行为,没有则是"天然"

```
student s;
person& rp = s;//可以不加const -- 说明不是右值,没有隐式类型转换
```

- 父类不能赋值给子类





### 继承中的作用域
在继承体系中,基类和派生类都有独立的作用域.

> 不同作用域可以定义同一个名字的变量
> 不同作用域的同名函数不能构成重载,同一个作用域内同名函数才有可能构成重载

- 隐藏/重定义:不同作用域的同名成员(非虚函数)构成重定义
 子类和父类有同名成员时,子类成员将屏蔽父类对同名成员的直接访问,这种情况叫做隐藏或重定义,继承关系才有隐藏
  说明: 触发隐藏后,默认调用的是子类作用域内的成员,如果需要调用父类的,只需要显式指出父类作用域  
  语法:   "基类::基类成员"  
  `Base::_member;`

- 函数构成隐藏的条件,只需要函数名相同就构成隐藏,不考虑返回值和参数列表(一不一样都不影响)  

- 隐藏会影响可读性,最好还是少用,可能会给自己埋坑.


### 继承的构造函数

继承中规定:父类的成员必须通过调用父类的构造函数完成初始化.因此,继承中子类需要帮助父类初始化.
子类自动生成的构造函数也会自动调用父类构造函数进行初始化

- 如果子类中没写父类构造函数,则父类会自动调用无参的构造函数,但是父类写了其他构造函数,但没写无参则报错,除非全缺省
- 父类构造都是通过子类初始化列表完成初始化,无论显式还是隐式
- 需要显式指定参数完成父类初始化时,可以在初始化列表中显式写出父类构造函数`Derive:Base(参数列表){}`  
- 继承下来的父类算是一个子类成员,和其他子类成员一样,需要初始化,只是看不见

### 继承的拷贝构造
切片
```<Cpp>
Derive(const Derive& d):Base(d){};
```
### 继承的operator=
```<Cpp>
Derive& operator(const Derive& d)
{
    if(this!=d)
    {
        Base::operator=(d);
        _member = d._member;
    }
    return *this;
}

```


### 继承的析构函数


#### 析构顺序
> 正常来说,父类是子类的"成员",先调子类析构,析构到自定义类型时,就调用自定义类型的析构函数.等析构到父类时,就调用父类的析构函数,这样符合逻辑.   
> 
> 因此,继承中析构像进栈的顺序那样,后进去的先析构,先析构子类,再析构父类



- 不需要显式调用父类析构  
  > 为了要保证析构顺序,父类的析构是自动调用的 -- 如果是用户自己写,不能保证析构顺序,容易出问题
  
  如果显式调用了,则会析构两次.

##### 析构的特殊处理
析构在继承及以后的多态中会被处理成Destructor,
坑引入:析构的特殊处理引入
	&如果是父类指针接收子类类型,则析构函数调用父类的,没调子类,
	$析构特殊处理后,构成隐藏的析构函数,类型是谁就调用谁的析构,目前不能解决
	$多态,虚函数,父类指针或引用调用虚函数,->彻底解决继承的析构问题

 父类析构会在子类析构结束后自动调用





### 继承中的static成员
基类定义了static静态成员,则整个继承体系里面只有一个这样的成员,都共享这个成员.无论派生出多少个子类,都只有一个static成员实例 

### 设计一个不能被继承的类 
- 方法1:私有构造函数或私有析构函数(继承需要帮助父类初始化和析构,ban就完事了)
- 方法2:C++11关键字 final修饰类

```<language>
public :
	static A CreateObj(){ return A()}; //允许从类域内访问
private:
	A(){};
main(){A::CreateObj()};
```

  

### 多继承

多继承是指被多个子孙继承

多继承的语法:继承方式 类 ,继承方式 类,...
  以逗号分隔开



#### 菱形继承

##### 定义

多个子类继承同一个父类而又有子类同时继承这几个子类或其子孙类

##### 标准的菱形继承图:

![image-20240528191422575](封装、继承、多态.assets/image-20240528191422575.png)

```
class Person
{
public:
    std::string _name; // 姓名
};

class Student : public Person {
protected:
    int _num; //学号
};

class Teacher : public Person{
protected:
    int _id; // 职工编号
};
class Assistant : public Student, public Teacher{
protected:
    std::string _majorCourse; // 主修课程
};

int main(){
    Assistant a;
    return 0;
}
```

![image-20240528192434539](封装、继承、多态.assets/image-20240528192434539.png)





其他的菱形继承

![image-20240528192920115](封装、继承、多态.assets/image-20240528192920115.png)

```
class Person{
public:
    std::string _name; // 姓名
};

class Children:public Person{
protected:
    int _num; //学号
};

class Student : public Children {
protected:
    int _num; //学号
};

class Teacher : public Person{
protected:
    int _id; // 职工编号
};

class Assistant : public Student, public Teacher{
protected:
    std::string _majorCourse; // 主修课程
};

int main(){
    Assistant a;
    return 0;
}

```

![image-20240528192142151](封装、继承、多态.assets/image-20240528192142151.png)


#### 菱形继承的二义性和数据冗余

菱形继承意味着两个父类都继承了爷爷类,所以两个父类都有相同的爷爷成员,导致孙子会有两个相同的成员

- 二义性是指继承了多个有相同爷爷类的父类,也就继承了多份相同的爷爷类成员,直接指定这些爷爷类成员时会发生冲突,不能唯一确认.

- 数据冗余:两份相同继承

- 菱形继承不仅是菱形,包括成环都是菱形继承

##### 代码举例:

```
class Person
{
public:
    std::string _name; // 姓名
};
class Student : public Person
{
protected:
    int _num; //学号
};
class Teacher : public Person
{
protected:
    int _id; // 职工编号
};
class Assistant : public Student, public Teacher
{
protected:
    std::string _majorCourse; // 主修课程
};
int main()
{
    // 这样会有二义性无法明确知道访问的是哪一个 
    Assistant a;
    a._name = "peter";

    return 0;
}

```

问题举例:

![image-20240527213317120](封装、继承、多态.assets/image-20240527213317120.png)

显式指定父类成员可以解决二义性问题:

![image-20240527213913792](封装、继承、多态.assets/image-20240527213913792.png)



##### 菱形继承的现实问题:

菱形继承在现实情况下不存在,爷爷类的属性在子孙类中都应该是唯一属性,才能符合继承的意义.

> 比方说我们都是人,我们都继承了人的属性,我们都有一套相同的人的属性,不可能有多套.爷爷类就相当于人的属性,大家都只有一份才合理.

#### 菱形继承的内存布局

```
class A{
public:
    int _a = 1;
};

class B : public A{
public:
    int _b = 2;
};

class C : public A{
    public:
    int _c = 3;
};

class D :public B, public C {
    public:
    int _d = 4;
};

int main(){
    D d;
    return 0;
}
```



![image-20240528205738681](封装、继承、多态.assets/image-20240528205738681.png)

#### 解决数据冗余 -- 虚继承

##### 定义:

虚拟继承,也叫**虚继承** 是面向对象编程中的一种技术，是指一个指定的基类，在继承体系结构中，将其成员数据实例共享给也从这个基类型直接或间接派生的其它类。

##### 示例代码:

```
class A{
public:
    int _a = 1;
};

class B :virtual public A{
public:
    int _b = 2;
};

class C :virtual public A{
    public:
    int _c = 3;
};

class D :public B, public C {
    public:
    int _d = 4;
};

int main(){
    D d;
    return 0;
}
```

##### VS监视窗口现象

![image-20240528202820145](封装、继承、多态.assets/image-20240528202820145.png)

  目前我们认为虚继承解决是解决了数据冗余问题,但监视窗口中依旧显示出菱形继承中数据冗余的样子.可能会引起误解.

这其实也是合理的,因为虚拟继承是让直接或间接派生的类共享基类,每个派生类都共同享有这个基类,因此每个派生类都有一份也是能够理解的.只要注意在使用时提醒自己这是个共享类.

  监视窗口终究还是抽象的产物,看内存得到的信息则一定是准确的.可以发现图片右边的内存窗口中数值为1的只有一个字节,这就能够说明,基类只有1个,就是是数据冗余问题被解决.

  另外,还可以发现对象d的内存中还有除了缺省值1,2,3,4以外的其他值,这是虚继承做的特殊处理,见下文

##### 虚继承的原理

为什么不是地址,而是偏移量

 演示
 非虚继承的菱形继承
  [ A成员  ] B -|
  [ B成员  ]	|
  [ A成员  ] C -|-D
  [ C成员  ]	|
  [ D成员  ]   -|

 虚继承的菱形继承
  [ A的偏移地址  ] B -|
  [ B成员        ]    |
  [ A的偏移地址  ] C -|-D
  [ C成员        ]    |
  [ D成员        ]    |
  [ A成员        ] A -|

  $ 偏移量的作用:目的是让子类对象切片后的父类对象指针能找到A

 

  8.3虚继承/虚拟继承  
  语法:>在继承方式前加上virtual
  表现:>a对象为所有子孙共享,子孙指针域内原非虚继承的位置变成 存放a的偏移量的指针,A的成员则在D的最下方,D的成员后面(比D还后)
  注意:虚拟继承不能在其他地方使用

  8.4 虚继承的调试
  虚继承调试需要观察内存;监视窗口中虚继承和多继承基本一样,观察不出来

  9.继承的this
  $a.继承不会改变函数的类型
  $b. 由a ==> 继承下来的函数中,this参数的类型还是父类指针(重要) ************ ,



 补充
 虚继承和虚函数没有直接关系,容易混淆

 菱形继承没有虚基表,菱形虚拟继承才有虚基表
 虚基表存的是偏移量,两个值都是偏移量

 菱形继承+虚继承+虚函数->需要子类完成最终重写

  继承是在使用层面做了限制,仅仅在用户使用层面私有不可见
	但在内存中父类所有代码都是可见的,完整继承了父类的所有代码.




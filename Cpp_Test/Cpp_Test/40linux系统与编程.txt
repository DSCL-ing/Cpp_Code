#pragma once


linux版本号

主版本号.次版本号.修正次数 2.6.30    -- 次版本号为偶数:稳定版   奇数:测试版


$ 操作系统是一款进行软硬件管理的软件

$ 操作系统存在的意义:操作系统对软硬件进行合理管理(手段/方法),以达到为上层用户提供良好的,稳定的,安全的运行环境的目的

$ 开机就是加载操作系统,俗称开机

# mkdir 目录名  //创建目录(linux)/文件夹(win)

# pwd  //显式当前目录的绝对路径

# touch	文件名.后缀          //创建普通文件

//#命令 -[命令选项]  --后序学习"命令行参数和环境变量"
//command 
//command not found :找不到命令

#echo "字符串" > 文件 //清空文件再写入,'w'


$ 文件 = 内容+属性
文件操作分为1.内容操作 2.属性操作

# ls -l(l:list) //以list的形式显式更多的属性

$ 以.开头的文件/目录是隐藏文件/目录

# ls -ul  //以uid形式显式属性

# .  //当前路径
# .. //上级路径

# C:\Users\26390\Desktop //  windows下的路径,  (反斜杠) \ : 路径分割符
# /root/test             //  linux下的路径,      (斜杠) / : 路径分隔符

# ls -ld /   //只显示路径,不显示内容
$ / 为linux下的根,linux下为目录为蓝色
$ windows下文件夹内可以有新的文件夹,linux下目录内可以有新的目录 -- 所以linux的根 / 和路径分隔符 / 不冲突
$ linux整体是一个多叉树的样子/结构

$ windows通过路径来定位文件/文件夹,linux也是如此.  
为什么呢? > 任何一个目录都可以有多个子目录,但一个子目录只有一个父目录 -->因此一条路径能唯一标识一目录/文件 
$ 路径分为1.绝对路径 2.相对路径(相对是相对于当前路径,如果当前路径改变了,则相对路径也会发生改变 ->失效)

$ 绝对路径使用场景:准确但麻烦,一般是在某些配置环境中,进行对某种文件进行配置时采用!
$ 相对路径使用场景:用起来简单,是后序指令操作时,常用的路径定位方案!

# cd ~  //进入/home目录
$ 超级用户/管理员root的~独立位于/root
$ 普通用户的~都位于/home底下 -- ~称为普通用户的家目录
$ window也有家目录,位于C:\Users ,

# cd -   //回到上一次访问的目录

热键:高频被使用的按键
# 快速双击tab键  -->命令的自动补齐:1.显式出匹配的所有命名 2.显示出匹配目录下的所有文件
# 不想进入目录又想查看其他目录有哪些文件 --> 无脑 tab../../../../

# tree [空] / [.] / [..] / [其他目录]   //以树的形式把指定目录打印出来,不加命令选项默认是当前目录
$ -bash: tree: command not found 解决方法:root下# yum install -y tree  //如果是Ubuntu,则是# apt-get install -y tree

$ 按键:ctrl+C  //停止当前活动/打印/刷屏 /终止程序的运行/刷屏

# touch 文件 或 ../文件 //在当前目录创建一个普通文本文件 或在指定目录创建一个普通文本文件

# nano 文件  //使用nano编辑器u是什么意思打开文件

$ nano :nano是Unix/Linux下的一个文本编辑器
nano编辑器的快捷键使用
Ctrl+G 帮助
Ctrl+X 退出
Ctrl+O 保存
Ctrl+R 复制指定文件内容
Ctrl+W 查找
Ctrl+\ 替换
Ctrl+K 剪切
Ctrl+U 粘贴
Ctrl+J 调整段落
Ctrl+T 检查拼写
Ctrl+C 光标位置信息
Ctrl+Shift+_ 跳转到指定行
Alt+U 撤销
Alt+E 反撤销
Alt+A 从光标位置开始标记/选择
Alt+6 复制
Ctrl+3 & Shift+3 显示行号
//nano不能用数字小键盘,只能用数字横键盘

//cancel :取消

# cat 文件  // 打印/显式文件内容

# gcc .c文件 //编译.c文件,得到a.out可执行文件 //可执行文件是绿色
# ./a.out    //执行可执行文件,执行a.out文件  -- 可执行文件在linux下必须带./  ,后面学

$ 云服务器可以重启,但不要轻易关机

# stat 文件  //获取文件的所有属性
$ 任何文件都有三种时间:A.C.M.时间:1.Access(访问) 2.Modify(内容) 3.Change(属性)
$ ll显式的时间是M时间

# mkdir -p d1/d2/d3/...   //创建一串路径/目录; 递归创建多个目录

# rmdir 目录     //删除目录,只能删除非空目录 -- 也没有支持递归删除的命令选项,所以目前没什么用
//rmdir:failed to remove :删除失败

# rm  指定目录/指定文件   //删除文件或目录  -- 什么都能删,只要权限够
# rm -r 指定目录          //递归删除目录内的所有文件/目录
# rm -rf 指定目录         //强制递归删除目录内的所有文件/目录 -- 不提示/不通知/不需要确认 直接删完

$ 普通用户只能在 /home/自己/... 内创建文件 ,root在哪里都可以创建

//3

//判断绝对路径 1.绝对路径是以/开始的 2.绝对路径放在任何目录下都与其他路径无关


$ 输入框为空时按一下table可以显式当前linux系统有多少条指令 -- 阿里云轻量应用级有1265条左右

//删除
# rm -r 目录  //通过rm删除目录,递归删除目录  -- 因为目录本身就是递归定义的

# sudo touch 文件 // 以root身份创建文件

# rm  文件  //只能删除普通文件 -- 默认只能删除普通文件

# yum install -y man-pages //安装man手册
# man [号] xx  //搜索[几号]man手册并进入,没有号码则默认搜索全部
# man man //打开man手册首页

# sudo 命令  //命令提权

//拷贝
# cp 普通文件 目录 // 拷贝普通文件到目录中
# cp -r 目录  目录 // 拷贝目录到目录中,必须带-r,递归拷贝 

$ 命令选项可以放中间也可以放在最后 // 最好保持放中间,有些系统不支持,如mac

//剪切
# mv 目录/文件 目录  //移动目录/文件,不需要带递归-r命令选项   ,后面一项一定是目录
# mv 目录/文件 ..    //移动文件/目录到上级目录
# mv 目录/文件 .    //移动文件/目录到当前目录

//文件重命名
# mv 旧文件名  新文件名  //重命名 --                        后面一项一定时文件名

//文件剪切+重命名
# mv 旧文件名  路径/new_filename(带目录的新文件名)    //如果第二项是是目录且带着一个没有重复的文件名,则是移动+重命名

//目录重命名
# mv 目录   新目录名(不能和所在路径有重复)  //当前目录下重命名

//目录剪切+重命名
# mv 目录  带路径的新目录名(不能和所在路径有重复)   //


//linux下一起皆文件,键盘,显示器...可以读,可以写都是文件


# cat 文件      //打印文件内容到控制台

# echo    文本内容       // 输出到控制台  - 文本内容目前最好带上"" 

# echo    文本内容  >  文件   // 输出 文本内容 重定向 到文件 , '>'为输出重定向符号 -- 如果文件不存在,输出重定向>会创建一个新文件并写入
$ '>'输出重定向是一种覆盖式写入 ,清空文件再写入
$ '>>' 追加重定向:追加重定向是追加式写入,在原文件内容的末尾追加写入,给原文件新增内容


# wc 文件 //wc命令的功能为统计指定文件中的字节数、单词数、行数, 并将统计结果显示输出
-c, --bytes打印字节数
-m, --chars  打印字符数 
-l, --lines  打印行数                                   //学
-L, --max-line-length  打印最长行的长度
-w, --words 打印单词数

$ '<' 输入重定向

$ cat默认是重键盘读取数据 -- 只输入cat就会进入键盘读取状态,打一个回显一个,直到ctrl+C
# cat < 文件  //读入重定向到文件,默认是键盘 -- 和# 【cat 文件】  不一样 , 【cat 文件】是命令获取文件

//cat用法：cat [选项] [文件]...
将[文件]或标准输入组合输出到标准输出。
  -A, --show-all           等价于 -vET
  -b, --number-nonblank    对非空输出行编号
  -e                       等价于 -vE
  -E, --show-ends          在每行结束处显示 $
  -n, --number             对输出的所有行编号                //学
  -s, --squeeze-blank      不输出多行空行                    //把连续的空行合并成一行
  -t                       与 -vT 等价
  -T, --show-tabs          将跳格字符显示为 ^I
  -u                       (被忽略)
  -v, --show-nonprinting   使用 ^ 和 M- 引用，除了 LFD 和 TAB 之外
      --help     显示此帮助信息并退出
      --version  输出版本信息并退出
如果[文件]缺省，或者[文件]为 - ，则读取标准输入。

# more 文件 //按屏幕大小显式文件内容 -- 按回车翻页,并且只能向下翻页,按q推出


{
# less 文件 //按屏幕大小显式文件内容 -- 按上下键翻页,可以自由翻页,按q推出
//搜索 输入/搜索内容+回车 , 转到下一个搜索结果按n(next)
less 与more命令类似，但可以通过翻页键查看上下页的内容
-b<缓冲区大小> 设置缓冲区的大小
-e 当文件显示结束后，自动离开
-f 强迫打开特殊文件，例如外围设备代号、目录和二进制文件
-g 只标志最后搜索的关键词
-i 忽略搜索时的大小写
-m 显示类似more命令的百分比
-N 显示每行的行号
-o<文件名> 将less 输出的内容在指定文件中保存起来
-Q 不使用警告音
-s 显示连续空行为一行
-S 行过长时间将超出部分舍弃
-x<数字> 将“tab”键显示为规定的数字空格

命令内部操作按键功能如下：
b 向前翻一页
d 向后翻半页
h 显示帮助界面
Q 退出less 命令
u 向前滚动半页
y 向前滚动一行
空格键 滚动一页
回车键 滚动一行 

1) 向前搜索
    / ： 使用一个模式进行搜索，并定位到下一个匹配的文本
    n ： 向前查找下一个匹配的文本
    N ： 向后查找前一个匹配的文本

2) 向后搜索
    ? ： 使用模式进行搜索，并定位到前一个匹配的文本
    n ： 向后查找下一个匹配的文本
    N ： 向前查找前一个匹配的文本

2 全屏导航
    ctrl + F ：向前移动一屏
    ctrl + B ：向后移动一屏
    ctrl + D ：向前移动半屏
    ctrl + U ：向后移动半屏

3 单行导航
    j ： 向前移动一行
    k ： 向后移动一行

4 其它导航
    G ： 移动到最后一行
    g ： 移动到第一行
    q / ZZ ： 退出 less 命令

5 编辑文件
    v ： 进入编辑模式，使用配置的编辑器编辑当前文件

6 标记导航
    当使用 less 查看大文件时，可以在任何一个位置作标记，可以通过命令导航到标有特定标记的文本位置。
    ma ： 使用 a 标记文本的当前位置
    'a ： 导航到标记 a 处

7 浏览多个文件
    方式一，传递多个参数给 less，就能浏览多个文件。
    less file1 file2

    方式二，正在浏览一个文件时，使用 :e 打开另一个文件。
    less file1
    :e file2

    当打开多个文件时，使用如下命令在多个文件之间切换
    :n - 浏览下一个文件
    :p - 浏览前一个文件

}


# head 文件 //默认会把文件的前10行打印出来,不够10行有多少打多少
# head -n5 文件 //设置成只打印前5行
# head -5 文件 //一样,省略,设置成只打印前5行

# tail 文件 //
# tail -3 文件
# tail -n3 文件

# wc -l 文件 //统计文件有多少行


# cat 文件 | wc -l  //cat的数据流入管道,wc统计管道数据的行数

$ '|' //管道 ,管道最核心的意义在于:可以级联多条命令,让命令和命令组合,来完成批量化文本处理任务,做数据的不断加工
//从左到右一次执行,结果由最后一条命令输出




//时间

# date //linux时间
# date +%Y-%m-%d_%H:%M:%S //格式化输出时间
# date +%s //输出时间戳  -- 格林尼治时间  --因时区问题,显式为8:00
# date +%Y-%m-%d_%H:%M:%S -d @时间戳  //将时间戳转为格式化输出

# cal //显式当前月份日历
# cal 2023(年份) //显式该年的所有月份
# cal -3  // 显式本月和前后月  //*只有命令选项只有-3


# sort 文件  //按行的ascii比较,默认是升序 -- 排序后打印
# sort -r 文件 //降序 r为reverse
# sort 文件 | uniq //排序后去重 -- 单纯去重没有用
//sort - uniq都不会修改源文件



//搜索三件套
# find 路径 -name 文件  //在路径底下搜索文件 -- 第一次搜索很慢,第二次会快,因为linux会把常用搜索缓存起来  

# which 指令  //搜索指令所在目录 

# whereis 文档/程序/压缩包...  //搜索各种

$ linux基本所有指令都在 /usr/bin下
$ linux指令是可执行程序(绿色),就是平时写的C语言代码编译好的可执行程序 --指令,程序,工具没本质区别

# alias 别名='命令+命令选项组合'  //给命令+选项起别名
$ 为什么我们ls时有些文件会带颜色: 因为ls是'ls --color=auto的'别名

//文本 行过滤工具 
# grep '关键字' 文件 //过滤出文件中具有关键字的行 -- grep为文本行过滤工具
# grep -n '关键字' 文件  //带上行号

# >文件  //清空文件内容 --输出重定向,覆盖式,覆盖空进去,所以清空

# grep -v '关键字' 文件  //过滤掉文件中具有关键字的行 -- 不显示有关键字的行
# grep -i '关键字' 文件  //忽略大小写过滤
// grep -ivn '关键字' 文件     //组合命令
//cat 文件|grep  '关键字' 文件 //管道级联组合
注意:grep尽量带''或"",特别是有空格或其他符号

# top //任务管理器linux   


//zip打包 并压缩
# zip 打包的包名.zip  要打包的文件/目录     // 把文件打包 -- 只打包当前(1个/最外层)目录或文件
# zip -r 打包的包名.zip  要打包的文件/目录  // 递归打包文件/目录
ll
//zip解包
# unzip 要解包的文件(xxx.zip)


//4

# ls [命令选项] 目录/路径 //以列表形式显式该目录

# rm * -rf       //把当前目录的所有文件删掉 -- 不带路径默认为当前目录 --  '*' ,linux通配符,代表所有文件
# rm *.后缀 -rf  //把带有相同后缀的文件全部删除
$ 通配符:可以匹配上任意个数的任意字符

# unzip 压缩文件 -d 路径/目录  //解压缩到指定目录 d:dir

# zip 文件.rar 文件 // 没问题 后缀名可以为7z,rar,zip,解压也可以,用unzip --- 猜测是压缩算法是zip,后缀格式兼容或无所谓

# yum install -y unzip zip //安装 zip和unzip,可以把zip和unzip分开写 -- 安装多个包时用空格分开

# tar -czf  档名(名.tgz) 文件 //c为create:创建一个新的归档文件,即打包; z为使用gzip压缩,即压缩; f:使用档名,即紧接档名(新名),不能再接命令选项 //一般建议把f放最后,档名一般为tgz后缀
# tar -xzf  压缩文件  //x:解压指令(只需把czf的c换成x),准备解包; z:曾经压缩过,现在需要解压;f:文件名
$ tgz:  t:tar  gz:gzip//压缩:gzip压缩算法

# tar -ztvf 压缩文件  //查看压缩包内但不解压 //z为解压(解压一些头部信息) , t为查看指令  v为显式更详细  f为文件名

//有的平台上命令选项可以不带'-'

# tar -xzf 压缩文件 -C 目录/路径  //解压到指令路径/目录  //-C和zip的-d含义一样 -- 默认都是解压到当前路径

$ linux支持多行输入 ,只要在结尾输入反斜杠\回车即到下一行 -- 不需要空格等,空格也算命令中

//热键:ctrl+C :终止在影响命令行输入的程序,回到命令行输出

# bc //linux中的计算器
# echo "1+2*3/2" | bc //管道组合运算 -- 结果为4

# uname  -a //查看所有信息 // Linux iZ7xv3f3wlfxwevnefn5drZ 3.10.0-957.21.3.el7.x86_64 #1 SMP Tue Jun 18 16:35:19 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux
//linux版本 3.10.0;  发行版:el:centos 7;  架构:x64;  

# uname -r //查看软硬件体系结构  //软件体系结构3.10.0-957.21.3.        硬件体系结构:  el7.x86_64

# cat /etc/redhat-release  //查看linux的商业化发行版 -- centos是redhat公司的一款免费系统

# exit //退出linux

$ ctrl+d //退出//通常代表着：『键盘输入结束(End Of File, EOF 或 End OfInput)』的意思；另外，他也可以用来取代exit

$ 在输入框按上或按下可以翻动历史命令

$ ctrl+r  //搜索历史命令

# history //显式最近1000条命令
# history > 文件 //把命令保存到文件中

# reboot //重启linux 
# shutdown [命令选项] //关机  -- 云服务器不关机,关机要去后台重启

// 命令输入的地方叫做:  命令行 /    CLI/命令行界面

$ Shell的最简单定义：命令行解释器（command Interpreter）主要包含： -- shell的感性理解
   .将使用者的命令翻译给核心（kernel）处理。同时，将核心的处理结果翻译给使用者
   .保护操作系统 -- 防止用户执行非法指令
   .执行命令会创建子进程进行执行
//我们平常的命令主要是通过shell来和linux内核交互,shell帮我们解释命令给kernel -- shell命令
//shell是一个程序/命令 :/usr/bin/bash ,即bash.  我们链接上服务器时会自动关联上shell程序
//shell是linux的外壳程序,是软件层,命令行



//权限
$ 权限的概念:权限

$ 权限是约束普通用户的,超级用户几乎没有约束

$ linux的文件属性
 - --- --- ---  
 - rwx rwx rwx


$ linux下文件类型不用后缀区分文件类型,而是用文件属性中的第一列的一个字符区分文件类型
// 文件类型:   
// '-'是普通文件 ,包括文本文件,可执行文件,归档文件(压缩包)等   
// 'd'是目录
  ---------------------
// 'b':块设备,block,如磁盘
// 'c':字符设备,如键盘,显示器
// 'p':管道文件,
// 's':网络socket文件
// 'l':链接文件,link


$ linux虽然不以后缀区分文件类型,但是可以给人看,
// a.我们可以使用后缀名
// b.我们把后缀当作文件名的一部分
$ linux不以后缀区分文件类型是linux操作系统的事,我们的程序可以使用后缀来识别文件
$ linux程序与后缀无关,改成什么名都能执行.但是linux程序不一定能识别后缀不符合的文件,因为linux程序也是人写的
//即:操作系统以文件类型区分,用户程序可以以后缀区分文件.互不影响



//超级用户
# su 任何用户 //切换到任何用户,无需密码

//普通用户
# su  // 切换到超级管理员.需要输入密码 //在同一个bash下进行身份切换
# su - //以root身份重新登录,
# su 同级用户 //切换到同级用户,需要输入密码

$ ctrl+d可以理解为退出shell,shell也会套娃

# sudo 命令 // 普通用户单条指令提权
//会有错误aaaa is not in the sudoers file.  This incident will be reported.//以后解决



//角色划分

1.文件拥有者

2.文件所属组

3.文件的other(其他人) :如果不是拥有者或所属组,自动识别成other -- root也会被识别成other,但是不能影响root的霸权

文件信息示例:
:    -          rw-         rw-         r--         1        chj           chj           0       Sep 6 20:47     test.txt
:文件类型   拥有者权限  所属组权限    other权限          文件拥有者     文件所属组    文件大小      日期          文件名

文件自身具有权限属性分为
r -- 可读
w -- 可写
x -- 可执行
- -- 该位置没有权限

$ 文件权限如果存在则显式对应位置的相应字符(rwx),没有则为'-'











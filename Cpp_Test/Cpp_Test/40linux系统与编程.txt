#pragma once

xshell快捷键:
$ shift+Page Down/Up  //[终端]向上或向下翻页
xshell配色:obsidian(黑曜石)  /Xterm
xshell字体:consolas(控制台)-normal
$ ctrl+u // 快速向前清空命令 --- 实用 

linux版本号

主版本号.次版本号.修正次数 2.6.30    -- 次版本号为偶数:稳定版   奇数:测试版


$ 操作系统是一款进行软硬件管理的软件

$ 操作系统存在的意义:操作系统对软硬件进行合理管理(手段/方法),以达到为上层用户提供良好的,稳定的,安全的运行环境的目的

$ 开机就是加载操作系统,俗称开机

$$$$ 命令选项查看方式
1.内建命令(help)
格式： help + 内建命令
#### help 命令 // 命令使用说明

2.外部命令(–help)
一般是 Linux 命令自带的帮助信息，并不是所有命令都自带这个选项。
如我们想查看命令 ls 的用法：ls --help

内建命令要比系统论命令有比较高的执行效率。外部命令执行时往往需要fork出（产生出）一个子进程，而内建命令一般不用。外部命令是在bash之外额外安装的，通常放在/bin，/usr/bin，/sbin，/usr/sbin…等等。可通过“echo $PATH”命令查看外部命令的存储路径，比如：ls、vi等。
————————————————
版权声明：本文为CSDN博主「打酱油的；」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_46098612/article/details/123187157

这是为什么echo应该内置shell 的真正原因：
假设您在中有密码$PASSWORD。您如何将其写入文件./password？自然，大多数程序员都会写：
echo "$PASSWORD" >./password
但是，如果echo不是内置的Shell，则密码将通过ps信息泄露给所有用户。
当然，如果您想对此有所了解，可以找到一种无需使用即可存储密码的方法echo，也许可以利用其他一些Shell功能：
cat >./password <<EOF
${PASSWORD}
EOF
但是，具有echo内置功能是一个重要的安全带，因为将密码保存到文件的最明显的方法也应该起作用。
https://qastack.cn/unix/1355/why-is-echo-a-shell-built-in-command





# mkdir 目录名  //创建目录(linux)/文件夹(win)
# mkdir -p d1/d2/d3/...   //创建一串路径/目录; 递归创建多个目录

# pwd  //显式当前目录的绝对路径

# touch	文件名.后缀          //创建普通文件

//#命令 -[命令选项]  --后序学习"命令行参数和环境变量"
//command 
//command not found :找不到命令

#echo "字符串" > 文件 //清空文件再写入,'w'


$ 文件 = 内容+属性
文件操作分为1.内容操作 2.属性操作

# ls -l(l:list) //以list的形式显式更多的属性

# ls -t  //按时间先后排序
# ls -rt //按时间先后逆序排序

$ 以.开头的文件/目录是隐藏文件/目录

# ls -ul  //以uid形式显式属性

# .  //当前路径
# .. //上级路径

# C:\Users\26390\Desktop //  windows下的路径,  (反斜杠) \ : 路径分割符
# /root/test             //  linux下的路径,      (斜杠) / : 路径分隔符

# ls -ld /   //只显示路径,不显示内容
$ / 为linux下的根,linux下为目录为蓝色
$ windows下文件夹内可以有新的文件夹,linux下目录内可以有新的目录 -- 所以linux的根 / 和路径分隔符 / 不冲突
$ linux整体是一个多叉树的样子/结构

# ll -h  // h:  human_readable//人类可读的

$ windows通过路径来定位文件/文件夹,linux也是如此.  
为什么呢? > 任何一个目录都可以有多个子目录,但一个子目录只有一个父目录 -->因此一条路径能唯一标识一目录/文件 
$ 路径分为1.绝对路径 2.相对路径(相对是相对于当前路径,如果当前路径改变了,则相对路径也会发生改变 ->失效)

$ 绝对路径使用场景:准确但麻烦,一般是在某些配置环境中,进行对某种文件进行配置时采用!
$ 相对路径使用场景:用起来简单,是后序指令操作时,常用的路径定位方案!

# cd ~  //进入/home目录
$ 超级用户/管理员root的~独立位于/root
$ 普通用户的~都位于/home底下 -- ~称为普通用户的家目录
$ window也有家目录,位于C:\Users ,

# cd -   //回到上一次访问的目录

热键:高频被使用的按键
# 快速双击tab键  -->命令的自动补齐:1.显式出匹配的所有命名 2.显示出匹配目录下的所有文件
# 不想进入目录又想查看其他目录有哪些文件 --> 无脑 tab../../../../

# tree [空] / [.] / [..] / [其他目录]   //以树的形式把指定目录打印出来,不加命令选项默认是当前目录
$ -bash: tree: command not found 解决方法:root下# yum install -y tree  //如果是Ubuntu,则是# apt-get install -y tree

$ 按键:ctrl+C  //停止当前活动/打印/刷屏 /终止程序的运行/刷屏

# touch 文件 或 ../文件 //在当前目录创建一个普通文本文件 或在指定目录创建一个普通文本文件

# nano 文件  //使用nano编辑器u是什么意思打开文件

$ nano :nano是Unix/Linux下的一个文本编辑器
nano编辑器的快捷键使用
Ctrl+G 帮助
Ctrl+X 退出
Ctrl+O 保存
Ctrl+R 复制指定文件内容
Ctrl+W 查找
Ctrl+\ 替换
Ctrl+K 剪切
Ctrl+U 粘贴
Ctrl+J 调整段落
Ctrl+T 检查拼写
Ctrl+C 光标位置信息
Ctrl+Shift+_ 跳转到指定行
Alt+U 撤销
Alt+E 反撤销
Alt+A 从光标位置开始标记/选择
Alt+6 复制
Ctrl+3 & Shift+3 显示行号
//nano不能用数字小键盘,只能用数字横键盘

//cancel :取消

# cat 文件  // 打印/显式文件内容 
$ 将[文件]或标准输入组合输出到标准输出。

# echo xx   //显示一行文本,允许在标准输出上显示string , 将字符串打印到显示器

# gcc .c文件 //编译.c文件,得到a.out可执行文件 //可执行文件是绿色
# ./a.out    //执行可执行文件,执行a.out文件  -- 可执行文件在linux下必须带./  ,后面学

$ 云服务器可以重启,但不要轻易关机

# stat 文件  //获取文件的所有属性
$ 任何文件都有三种时间:A.C.M.时间:1.Access(访问) 2.Modify(内容) 3.Change(属性)
$ ll显式的时间是M时间


# rmdir 目录     //删除目录,只能删除非空目录 -- 也没有支持递归删除的命令选项,所以目前没什么用
//rmdir:failed to remove :删除失败
$ 为什么要有 -- 如果有一个文件和目录同名,想删目录可以用rmdir 或 rm -r 目录, 想删文件用rm(默认删的就是文件) --这样就区分开来

# rm  指定目录/指定文件   //删除文件或目录  -- 什么都能删,只要权限够
# rm -r 指定目录          //递归删除目录内的所有文件/目录
# rm -rf 指定目录         //强制递归删除目录内的所有文件/目录 -- 不提示/不通知/不需要确认 直接删完

$ 普通用户只能在 /home/自己/... 内创建文件 ,root在哪里都可以创建

//3

//判断绝对路径 1.绝对路径是以/开始的 2.绝对路径放在任何目录下都与其他路径无关


$ 输入框为空时按一下table可以显式当前linux系统有多少条指令 -- 阿里云轻量应用级有1265条左右

//删除
# rm -r 目录  //通过rm删除目录,递归删除目录  -- 因为目录本身就是递归定义的

# sudo touch 文件 // 以root身份创建文件

# rm  文件  //只能删除普通文件 -- 默认只能删除普通文件

# yum install -y man-pages //安装man手册
# man [号] xx  //搜索[几号]man手册并进入,没有号码则默认搜索全部
# man man //打开man手册首页

如果man2,3查不到,安装 yum install -y man-pages.noarch //先安装再更新 -- 原来是安装错了

//man 2 一般是系统调用
//man 3 一般是C库

$$ man命令选项
{
# -k 或 --apropos：用于搜索手册页面的简要描述。例如，man -k keyword会搜索包含关键字的手册页面的简要描述。
    //可以搜索包含关键字的句子 所在的手册页
# -f 或 --whatis：用于查找手册页面的简要描述，类似于-k选项。
    //只搜索目录,和直接man搜索一样,显示所在的手册页
# -p 或 --pager：指定用于查看手册页面的分页器（pager），默认情况下使用less。
    //man -p less ls
    //就是选择什么文档查看器来看文档
# -S 或 --sections：指定要查看的手册部分。默认情况下，man会搜索所有部分，但你可以使用此选项来指定特定部分。
    //就是man 3 printf 的简写


}

# sudo 命令  //命令提权

//拷贝
# cp 普通文件 目录 // 拷贝普通文件到目录中
# cp -r 目录  目录 // 拷贝目录到目录中,必须带-r,递归拷贝 

$ 命令选项可以放中间也可以放在最后 // 最好保持放中间,有些系统不支持,如mac

//剪切
# mv 目录/文件 目录  //移动目录/文件,不需要带递归-r命令选项   ,后面一项一定是目录
# mv 目录/文件 ..    //移动文件/目录到上级目录
# mv 目录/文件 .    //移动文件/目录到当前目录

//文件重命名
# mv 旧文件名  新文件名  //重命名 --                        后面一项一定时文件名

//文件剪切+重命名
# mv 旧文件名  路径/new_filename(带目录的新文件名)    //如果第二项是是目录且带着一个没有重复的文件名,则是移动+重命名

//目录重命名
# mv 目录   新目录名(不能和所在路径有重复)  //当前目录下重命名

//目录剪切+重命名
# mv 目录  带路径的新目录名(不能和所在路径有重复)   //


//linux下一起皆文件,键盘,显示器...可以读,可以写都是文件


# cat 文件      //打印文件内容到显示器

# echo    文本内容       // 输出到控制台  - 文本内容目前最好带上"" 


# echo    文本内容  >  文件   // 输出 文本内容 重定向 到文件 , '>'为输出重定向符号 -- 如果文件不存在,输出重定向>会创建一个新文件并写入
$ '>'输出重定向是一种覆盖式写入 ,清空文件再写入
$ '>>' 追加重定向:追加重定向是追加式写入,在原文件内容的末尾追加写入,给原文件新增内容
// 重定向 redirect

# wc 文件 //wc命令的功能为统计指定文件中的字节数、单词数、行数, 并将统计结果显示输出
-c, --bytes打印字节数
-m, --chars  打印字符数 
-l, --lines  打印行数                                   //学
-L, --max-line-length  打印最长行的长度
-w, --words 打印单词数

//示例
# who | wc -l //按行统计

$ '<' 输入重定向

$ cat默认是重键盘读取数据 -- 只输入cat就会进入键盘读取状态,打一个回显一个,直到ctrl+C
# cat < 文件  //读入重定向到文件,默认是键盘 -- 和# 【cat 文件】  不一样 , 【cat 文件】是命令获取文件

//cat用法：cat [选项] [文件]...
将[文件]或标准输入组合输出到标准输出。
  -A, --show-all           等价于 -vET
  -b, --number-nonblank    对非空输出行编号
  -e                       等价于 -vE
  -E, --show-ends          在每行结束处显示 $
  -n, --number             对输出的所有行编号                //学
  -s, --squeeze-blank      不输出多行空行                    //把连续的空行合并成一行
  -t                       与 -vT 等价
  -T, --show-tabs          将跳格字符显示为 ^I
  -u                       (被忽略)
  -v, --show-nonprinting   使用 ^ 和 M- 引用，除了 LFD 和 TAB 之外
      --help     显示此帮助信息并退出
      --version  输出版本信息并退出
如果[文件]缺省，或者[文件]为 - ，则读取标准输入。

# more 文件 //按屏幕大小显式文件内容 -- 按回车翻页,并且只能向下翻页,按q推出


{
# less 文件 //按屏幕大小显式文件内容 -- 按上下键翻页,可以自由翻页,按q推出
//搜索 输入/搜索内容+回车 , 转到下一个搜索结果按n(next)
less 与more命令类似，但可以通过翻页键查看上下页的内容
-b<缓冲区大小> 设置缓冲区的大小
-e 当文件显示结束后，自动离开
-f 强迫打开特殊文件，例如外围设备代号、目录和二进制文件
-g 只标志最后搜索的关键词
-i 忽略搜索时的大小写
-m 显示类似more命令的百分比
-N 显示每行的行号
-o<文件名> 将less 输出的内容在指定文件中保存起来
-Q 不使用警告音
-s 显示连续空行为一行
-S 行过长时间将超出部分舍弃
-x<数字> 将“tab”键显示为规定的数字空格

命令内部操作按键功能如下：
b 向前翻一页
d 向后翻半页
h 显示帮助界面
Q 退出less 命令
u 向前滚动半页
y 向前滚动一行
空格键 滚动一页
回车键 滚动一行 

1) 向前搜索
    / ： 使用一个模式进行搜索，并定位到下一个匹配的文本
    n ： 向前查找下一个匹配的文本
    N ： 向后查找前一个匹配的文本

2) 向后搜索
    ? ： 使用模式进行搜索，并定位到前一个匹配的文本
    n ： 向后查找下一个匹配的文本
    N ： 向前查找前一个匹配的文本

2 全屏导航
    ctrl + F ：向前移动一屏
    ctrl + B ：向后移动一屏
    ctrl + D ：向前移动半屏
    ctrl + U ：向后移动半屏

3 单行导航
    j ： 向前移动一行
    k ： 向后移动一行

4 其它导航
    G ： 移动到最后一行
    g ： 移动到第一行
    q / ZZ ： 退出 less 命令

5 编辑文件
    v ： 进入编辑模式，使用配置的编辑器编辑当前文件

6 标记导航
    当使用 less 查看大文件时，可以在任何一个位置作标记，可以通过命令导航到标有特定标记的文本位置。
    ma ： 使用 a 标记文本的当前位置
    'a ： 导航到标记 a 处

7 浏览多个文件
    方式一，传递多个参数给 less，就能浏览多个文件。
    less file1 file2

    方式二，正在浏览一个文件时，使用 :e 打开另一个文件。
    less file1
    :e file2

    当打开多个文件时，使用如下命令在多个文件之间切换
    :n - 浏览下一个文件
    :p - 浏览前一个文件

}


# head 文件 //默认会把文件的前10行打印出来,不够10行有多少打多少
# head -n5 文件 //设置成只打印前5行
# head -5 文件 //一样,省略,设置成只打印前5行

# tail 文件 //
# tail -3 文件
# tail -n3 文件

# wc -l 文件 //统计文件有多少行


# cat 文件 | wc -l  //cat的数据流入管道,wc统计管道数据的行数

$ '|' //管道 ,管道最核心的意义在于:可以级联多条命令,让命令和命令组合,来完成批量化文本处理任务,做数据的不断加工
//从左到右一次执行,结果由最后一条命令输出




//时间

# date //linux时间
# date +%Y-%m-%d_%H:%M:%S //格式化输出时间
# date +%s //输出时间戳  -- 格林尼治时间  --因时区问题,显式为8:00
# date +%Y-%m-%d_%H:%M:%S -d @时间戳  //将时间戳转为格式化输出

//
日历  calendar  [ˈkælɪndər]
# cal //显式当前月份日历
# cal 2023(年份) //显式该年的所有月份
# cal -3  // 显式本月和前后月  //*只有命令选项只有-3


# sort 文件  //按行的ascii比较,默认是升序 -- 排序后打印
# sort -r 文件 //降序 r为reverse
# sort 文件 | uniq //排序后去重 -- 单纯去重没有用
//sort - uniq都不会修改源文件



//搜索三件套
# find 路径 -name 文件  //在路径底下搜索文件 -- 第一次搜索很慢,第二次会快,因为linux会把常用搜索缓存起来  
要获取特定文件的路径
find ~ -name example.txt //范围尽可能小,使用~比较好


# which 指令  //搜索指令所在目录 //搜索可执行程序

# whereis 文档/程序/压缩包...  //搜索各种

$ linux基本所有指令都在 /usr/bin下
$ linux指令是可执行程序(绿色),就是平时写的C语言代码编译好的可执行程序 --指令,程序,工具没本质区别

# alias 别名='命令+命令选项组合'  //给命令+选项起别名
$ 为什么我们ls时有些文件会带颜色: 因为ls是'ls --color=auto的'别名

//文本 行过滤工具 
# grep '关键字' 文件 //过滤出文件中具有关键字的行 -- grep为文本行过滤工具
# grep -n '关键字' 文件  //带上行号

# >文件  //清空文件内容 --输出重定向,覆盖式,覆盖空进去,所以清空

# grep -v '关键字' 文件  //过滤掉文件中具有关键字的行 -- 不显示有关键字的行
# grep -i '关键字' 文件  //忽略大小写过滤
// grep -ivn '关键字' 文件     //组合命令
//cat 文件|grep  '关键字' 文件 //管道级联组合
注意:grep尽量带''或"",特别是有空格或其他符号

# top //任务管理器linux   


//zip打包 并压缩
# zip 打包的包名.zip  要打包的文件/目录     // 把文件打包 -- 只打包当前(1个/最外层)目录或文件
# zip -r 打包的包名.zip  要打包的文件/目录  // 递归打包文件/目录

//zip解包
# unzip 要解包的文件(xxx.zip)

# unzip 压缩文件 -d 路径/目录  //解压缩到指定目录 d:dir

# zip 文件.rar 文件 // 没问题 后缀名可以为7z,rar,zip,解压也可以,用unzip --- 猜测是压缩算法是zip,后缀格式兼容或无所谓

//zip安装
# yum install -y unzip zip //安装 zip和unzip,可以把zip和unzip分开写 -- 安装多个包时用空格分开

//4

# ls [命令选项] 目录/路径 //以列表形式显式该目录

# rm * -rf       //把当前目录的所有文件删掉 -- 不带路径默认为当前目录 --  '*' ,linux通配符,代表所有文件
# rm *.后缀 -rf  //把带有相同后缀的文件全部删除
$ 通配符:可以匹配上任意个数的任意字符



# tar -czf  档名(名.tgz) 文件 //c为create:创建一个新的归档文件,即打包; z为使用gzip压缩,即压缩; f:使用档名,即紧接档名(新名),不能再接命令选项 //一般建议把f放最后,档名一般为tgz后缀
# tar -xzf  压缩文件  //x(extract提取):解压指令(只需把czf的c换成x),准备解包; z:曾经压缩过,现在需要解压;f:文件名
$ tgz:  t:tar  gz:gzip//压缩:gzip压缩算法 //.tar.gz 的缩写 .tgz

# tar -ztvf 压缩文件  //查看压缩包内但不解压 //z为解压(解压一些头部信息)或者检查是否gzip , t--list为查看指令  v--verbose为列出更详细信息  f为归档文件名
# tar tvf 压缩文件 //目前和ztvf一样

//有的平台上命令选项可以不带'-'

# tar -xzf 压缩文件 -C 目录/路径  //解压到指令路径/目录  //-C和zip的-d含义一样 -- 默认都是解压到当前路径

$ linux支持多行输入 ,只要在结尾输入反斜杠\回车即到下一行 -- 不需要空格等,空格也算命令中

//热键:ctrl+C :终止在影响命令行输入的程序,回到命令行输出

# bc //linux中的计算器
# echo "1+2*3/2" | bc //管道组合运算 -- 结果为4

# uname  -a //查看所有信息 // Linux iZ7xv3f3wlfxwevnefn5drZ 3.10.0-957.21.3.el7.x86_64 #1 SMP Tue Jun 18 16:35:19 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux
//linux版本 3.10.0;  发行版:el:centos 7;  架构:x64;  

# uname -r //查看软硬件体系结构  //软件体系结构3.10.0-957.21.3.        硬件体系结构:  el7.x86_64

# cat /etc/redhat-release  //查看linux的商业化发行版 -- centos是redhat公司的一款免费系统

# exit //退出linux

$ ctrl+d //退出//通常代表着：『键盘输入结束(End Of File, EOF 或 End OfInput)』的意思；另外，他也可以用来取代exit

$ 在输入框按上或按下可以翻动历史命令

$ ctrl+r  //搜索历史命令

# history //显式最近1000条命令
# history > 文件 //把命令保存到文件中
//配合!使用
# !history编号 //执行该编号的命令
# !!           //执行上一次的命令

# reboot //重启linux 
# shutdown [命令选项] //关机  -- 云服务器不关机,关机要去后台重启

// 命令输入的地方叫做:  命令行 /    CLI/命令行界面

$ Shell的最简单定义：命令行解释器（command Interpreter）主要包含： -- shell的感性理解
   .将使用者的命令翻译给核心（kernel）处理。同时，将核心的处理结果翻译给使用者
   .保护操作系统 -- 防止用户执行非法指令
   .执行命令会创建子进程进行执行
//我们平常的命令主要是通过shell来和linux内核交互,shell帮我们解释命令给kernel -- shell命令
//shell是一个程序/命令 :/usr/bin/bash ,即bash.  我们链接上服务器时会自动关联上shell程序 -- bash也是一个可执行程序,C语言写的
//shell是linux的外壳程序,是软件层,命令行

// shell是适配程序,将内核适配后提供给用户合适的接口 -- 
$ shell是所有外壳程序的统称,linux的内核程序是bash ,统称shell


//权限
$ 权限的概念:权限 = 人 + 属性
# 

$ 权限是约束普通用户的,超级用户不受约束 ,想看就看,想改就改

$ linux的文件属性
 - --- --- ---  
 - rwx rwx rwx


$ linux下文件类型不用后缀区分文件类型,而是用文件属性中的第一列的一个字符区分文件类型
// 文件类型:   
// '-'是普通文件 ,包括文本文件,可执行文件,归档文件(压缩包)等   
// 'd'是目录
  ---------------------
// 'b':块设备,block,如磁盘
// 'c':字符设备,如键盘,显示器
// 'p':管道文件,
// 's':网络socket文件
// 'l':链接文件,link


$ linux虽然不以后缀区分文件类型,但是可以给人看,
// a.我们可以使用后缀名
// b.我们把后缀当作文件名的一部分
$ linux不以后缀区分文件类型是linux操作系统的事,我们的程序可以使用后缀来识别文件
$ linux程序与后缀无关,改成什么名都能执行.但是linux程序不一定能识别后缀不符合的文件,因为linux程序也是人写的
//即:操作系统以文件类型区分,用户程序可以以后缀区分文件.互不影响


# whoami  //查看我是谁
# who  //查看在线用户
# w    //详细信息
[chj@expiration1102 ~ 18:40:04]$ w
 18:40:12 up 19 days, 19:45,  1 user,  load average: 0.01, 0.04, 0.05
USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
chj      pts/0    14.150.227.120   18:40    4.00s  0.00s  0.00s w

//超级用户
# su 任何用户 //切换到任何用户,无需密码

//普通用户 
# su  // 切换到超级管理员.需要输入密码 //在同一个bash下进行身份切换
# su - //以root身份重新登录,
# su 同级用户 //切换到同级用户,需要输入密码
//su:switch user

$ ctrl+d是登出用户,用户可以su其他用户,套娃. 登出时按登入顺序依次退出 -- 栈结构

# sudo 命令 // 普通用户单条指令提权
//会有错误aaaa is not in the sudoers file.  This incident will be reported.//以后解决



//角色划分

1.文件拥有者

2.文件所属组

3.文件的other(其他人) :如果不是拥有者或所属组,自动识别成other -- root也会被识别成other,但是不能影响root的霸权

文件信息示例:
:    -          rw-         rw-         r--         1        chj           chj           0       Sep 6 20:47     test.txt
:文件类型   拥有者权限  所属组权限    other权限          文件拥有者     文件所属组    文件大小      日期          文件名

文件权限:   -- 文件自身具有权限属性
r -- 可读 -- 补充：可查看目录内文件
w -- 可写 -- 补充：目录内可新增、删除文件
x -- 可执行
- -- 该位置没有权限

$ 文件权限如果存在则显式对应位置的相应字符(rwx),没有则为'-'

$ 由于权限 = 人+属性,,要修改文件的权限,要么更改人,要么更改属性 -- 默认是文件的拥有者和root可以更改


//更改权限

//增加
# chmod u+r 文件 //Change Mode ,ch:change mod:mode //u代表拥有者user,+代表添加权限,r代表读权限;即给拥有者添加读权限
# chmod g+w 文件 //Change Mode ,ch:change mod:mode //g代表所属组group,+代表添加权限,w代表写权限;即给所属组添加写权限
# chmod o+x 文件 //Change Mode ,ch:change mod:mode //o代表其他人other,+代表添加权限,x代表写权限;即给其他人添加可执行权限

//移除
# chmod u+wx 文件 //u代表拥有者user,+代表添加权限,wx代表写和可执行权限;即给拥有者添加写和可执行权限
# chmod g+rx 文件 //g代表所属组group,+代表添加权限,rx代表读和可执行权限;即给所属组添加读和可执行权限
# chmod o+rw 文件 //o代表其他人other,+代表添加权限,rw代表读和写权限;即给其他人添加读和写权限

//权限顺序不影响,如 wrx,xrw,rxw...

//组合
# chmod o-rwx 文件 // 去掉o的rwx权限 '-'代表移除权限
# chmod u+x,g-w,o+w,u-x 文件 //组合增删权限,以逗号分隔

//所有+组合
# chmod a+x,a-w 文件  //给所有用户增加/删除权限 //a(all)代表所有用户

//默认,所有
# chmod +r 文件 //给所有用户ugo加上读权限 //



//二进制/八进制表示
$ 权限的每一个选项位,如果有对应权限则为1,如果没有则为0. 由此如果一文件拥有者权限为rw-,则二进制表示为110
$ 有三个用户组,每个用户组对应3个二进制位,这3个二进制位可以合并成一个八进制,即每3个二进制位为1个八进制,总共有9个二进制,则共有3个八进制位.
//设某文件权限为 110 110 100,则八进制为 664

$ 注意: 0开头代表是8进制数字

//八进制更改权限
# chmod 000 文件 //移除所有权限
# chmod 664 文件 //等价与110 110 100.//等价于chmod u+rw,g+rw,o+r 文件
# chmod 777 文件 //添加所有权限


$ sudo 命令 //命令提权,是以root身份执行,并不单纯是用户具有root权限 -- 需要在linux中把该用户添加到信任列表才能sudo



//更改所有者“chown是change owner的缩写//所有者
//更改所有组  chgrp是change group的缩写

$ 只有高级用户能强制给给低级用户文件,即root和能sudo用户

$ sudo输入密码后,短时间内再次使用sudo不需要密码 -- 方便人操作 --一般是15分钟以内

# sudo chown 别的用户 文件         //把文件所有者改为别的用户
# sudo chgrp 别的组  文件          //把文件的所有组改为别的组
# sudo chown 别的用户:别的组 文件  //同时修改用户和组




//file:查看是什么类型文件
# file txt文件 //test.txt: ASCII text
# file 目录//test.txt: ASCII text
# file C可执行文件//a.out: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.32, BuildID[sha1]=8261fb1b71b64a95f1a5f4be1559f4da3b0e339e, not stripped
# file .c文件//test.c: C source, ASCII text
# file tgz归档文件 //test.tgz: gzip compressed data, from Unix, last modified: Thu Sep  7 09:52:44 2023
$ 命令选项
-c 详细显示指令执行过程，便于排错或分析程序执行的情形。
-z 尝试去解读压缩文件的内容。



//目录权限
//r:查看,
//w:创建,移动...更改文件
//x:进入目录
//没有权限:permission denied


//centos默认权限
$ 文本文件的默认权限是664 rw-rw-r-- //可查看,可修改,可执行
$ 目录文件的默认权限是775 rwxrwxr-x //可查看,可增/删文件,可进入目录

$ 不同操作系统默认权限可能不一样

$ linux 权限分为
1.起始权限  -- 系统设定的,文本文件起始权限是666(没有可执行x),目录是777(都有) 
2.最终权限(系统角度)/默认权限(用户角度)

$ 权限掩码/umask:在起始权限中,去掉umask中出现的权限,不能影响其他权限的码 -- 用于系统更好的控制文件权限
// 掩码就是一串二进制数字,可以将源码与掩码经过按位运算或逻辑运算得出新的操作数

$ linux掩码有4位(八进制),最左边一位目前用不到,现在只使用后三位 -- 默认为0002   //最高位一般给系统标记位使用,1777,2664 3xxx ...
# umask 0002 // 修改掩码为0002 -- 掩码可以修改

最终权限 = 起始权限 & (~umask)


$ 异或 和 取反与 不等价 -- 容易出现相等的巧合
比如 3 ^ 4 = 7
二进制是 00000011 ^ 00000100 = 00000111
3 &~ 4 = 3
二进制是00000011 &(~ 00000100 )=00000011 &11111011=00000011=3


//粘滞位
//背景:linux中有共享目录,被所有普通用户共享,用来保存普通用户产生的临时数据
//linux下家目录只对自己开放，其他人无法访问（rwx --- ---/700） -- 由于不同用户之间需要交换数据,因此有了共享目录
$ 共享目录通常由root提供,任何人访问的身份都是other

$ 粘滞位的功能，限制目录内的文件只有文件拥有者和root可以删除 -- w目录有增/删文件功能,t是限制一部分

//一般情况,别人进不去我的家目录,别人删不掉,所以我的文件很安全.但是在共享目录下,如何防止被别人删除文件就很必要了

//粘滞位 -- 为了让大家共享文件,且不让其他人随便删除别人的文件 -- 提出了粘滞位

$ 粘滞位只能给目录添加 -- 一般对共享目录添加.  
$ 且只加到other的x位上 -- 可执行权限x对目录来说没用
# sudo chmod +t 目录 // 给目录添加粘滞位,a+t,+t都一样

$ 增加粘滞位的目录内的文件只有文件拥有者和root可以删除/目录的所有者也可以删除

$ 目录的w权限还有删除文件的功能

$ 粘滞位一般都在rwx的基础上添加


ls/cd/pwd/whoami/touch/mkdir/rm/rmdir/bc/cat/less/more/nano/date/wc/grep/head/tail/zip/unzip/tar/clear/cal/man/echo/tree/find/which/whereis/file/
cp/mv/chmod/chown/chgrp/sort/uniq/gcc/su/sudo/top/stat/uname/alias/umask/adduser/passwd/userdel/history

"重定向>,>> " ,  "管道|" ,    "  ~ , - " ,    "家目录"  , "文件类型" , "目录权限" ,"umask" ,"粘滞位" ,"权限" 

//



//yum -- 应用商店  -- 仓库

软件包名称: 主版本号.次版本号.源程序发行号-软件包的发行号.主机平台.cpu架构. 
"x86_64" 后缀表示64位系统的安装包, "i686" 后缀表示32位系统安装包. 选择包时要和系统匹配.
"el7" 表示操作系统发行版的版本. "el7" 表示的是 centos7/redhat7. "el6" 表示 centos6/redhat6.
最后一列, base 表示的是 "软件源" 的名称, 类似于 "小米应用商店", "华为应用商店" 这样的概念.

# yum list //列出yum所有程序 -- 软件名-版本号-@提供者

# yum search 关键字 //匹配有关键字的程序  -- 不好用

# yum list | grep 关键字 //好用

$ 版本中带el就是centos ,el7就代表centos7
//x86:架构 x86_64:x86架构64位系统

$ ctrl+Z :终止程序 -- 有些程序ctrl+C终止不了

//安装 
# yum install 程序名(严格匹配) //安装程序 ,需要确认安装
# yum install -y 程序  //直接安装到位,不需要确认

yum -y install gcc+ gcc-c++ //g++安装

//卸载
# yum remove 程序名 //卸载程序,需要确认卸载
# yum remove -y 程序名 //直接卸载

$ 程序sl:一个火车动画

# 软件仓库内内置了各个软件的下载地址/配置文件 
//yum的配置文件 -- yum源

$ yum源位置  /etc/yum.repos.d/下

$ centos的基础yum源: CentOS-Base.repo
$ 还有 epel.repo

$ //前面带"$"符号的单词表示这个单词是宏,会被替换掉

//更新yum源
1.备份原来的yum源 CentOS-Base.repo
2.wget 新的yum源 
3.mv 重命名成为 CentOS-Base.repo
4.yum clean all //清空缓存 
5.yum makecache //生成新的缓存

//可能在扩展yum源中的软件安装
1.# sudo yum install -y epel-release //根据base_yum源去找到匹配的yum源
2.# sudo yum install -y  

//复习->


//软件包和软件包管理器 -- 类似于App与应用商店
//软件包是已经由源代码编译好的可执行程序,包管理器能方便得获取到软件包







//5

//vim是vi的升级版本,vi有的vim都有,现在都使用vim

//集成开发环境/IDE :VS2019  //特点是功能齐全,把所有功能都集中在一起,一个软件能所有工作

//vim就是一个单纯的编辑器
//vim

$ vim是一款多模式的编辑器 -- 有各种模式 -- 常用就3-5种
1.命令模式(vim默认打开就是)
2.插入模式
3.低行模式
4.替换模式
5.视图模式
...

//vim命令
{

$ 任何模式按esc都能回到命令模式,命令模式能进入任何模式


$ 命令模式下按shift+:进入低行模式
// 低行模式中,w为write写入/保存,q为退出,组合命令wq为保存并推出 --- 如果文件被修改,则必须要w命令
// 低行模式,1.set nu为显示行号,nu为number  2.set nonu 为关闭行号
// 低行模式中 /关键字 为搜索 ,搜索模式中n向下匹配,shift向上匹配
// 低行模式中,!为强制,w!为强制保存 wq!为强制保存并退出
:x	保存并退出，同 :wq
:x!	强制保存并退出，同 :wq!
:
// 低行模式中,!空格+linux命令 为执行linux命令


// 低行模式中,vs什么都不加会打开多一份相同的文件,内容同步 -- 光标在哪里,则操作的就是谁
// 低行模式中,vs+文件名会打开多个文件多屏操作,如果文件不存在也能打开,不修改退出则不会生成新的文件,保存则会生成新的文件
//:vs为并列方式打开多个文件
//:sp为上下行方式分开多个文件
//ctrl+w+q  或:close  为关闭当前窗口.. 

ctrl+w+w循环切换
ctrl+w+方向,一次切换,不能循环


Linux vim 文本替换 %s/原文/替换文本/g
{
语法:%s///g
ESC:%s/origanl/new/g  --grammar:语法?

%s 表示替换文本。
origan 表示原文
new 表示新的内容
/g 表示全文替换，如果仅替换第一个则不需要/g

需要注意如果要替换的内容中包含特殊含义的自负，需要使用转义符转义

————————————————
版权声明：本文为CSDN博主「Drifting Kern」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_43740223/article/details/119925821
}

$ 命令模式下按i进入插入模式:光标不动,往光标前面插入
$ I	从目前光标所在行的第一个非空白字符处开始插入
$ 命令模式下按a进入插入模式:光标往后退一格,往光标前面插入
$ A	从目前光标所在行的最后一个字符处开始插入。
$ 命令模式下按o进入插入模式:往下插入一行并光标进入行首
$ 命令模式下按shift+o进入插入模式:往上插入一行并光标进入行首
$ 命令模式下按s进入插入模式:删出当前光标所在字符后光标不动,进入插入模式,往光标前面插入
$ 命令模式下shift+r 进入替换模式 ,输入会替换掉原有字符
$ 命令模式下按shift+s / cc清空当前行进入插入模式
$ 命令模式下按ZZ/shift+zz快速保存并退出
$ 命令模式下按Ctrl+Z 生成swap临时文件并退出
$ 命令模式下按.可重复上一次操作
$ 命令模式下按shift+q可以进入低行模式(更近的键盘操作,Qq退出)

【Ctrl + O】向后回退你的光标移动

【Ctrl + I 】向前追赶你的光标移动

fa → 到下一个为a的字符处，你也可以fs到下一个为s的字符。
ta → 到a前的第一个字符。a可以变成其它字符。
还有一个很有用的命令是 dt" → 删除所有的内容，直到遇到双引号—— "。 //或df
g_ → 到本行最后一个不是blank字符的位置。

$ 操作复制器:
qa            #打开操作记录器，将后续动作放在记录器a中;（左下角会显示一个【记录中@a】提示符号）
q             #关闭记录器;           --->备注：此时仍处于normal模式
执行操作
n@a // 执行n次操作,不带则为1次

Vim生成递增递减的数字
ctrl+a        #数字自加一次;         --->备注：如果想生成间隔n个数跳跃递增，则先按数字，再按下ctrl+a;
ctrl+x    递减

$ 命令模式指令:
// yy 复制 , nyy复制光标以下n行 
//yw	复制光标所在字符右边的单词
// p 粘贴 ,np粘贴n行,粘贴到下一行,粘贴当前光标所在的下一行,并且光标移动到一行     \ // 100p 粘贴100行 -- 
// P 往上/左粘贴
// u 撤销undo 
// ctrl+r 对撤销进行撤销/撤销命令u所作的操作,反撤销,重做 -- redo
// dd行剪切,ndd往下剪切n行  // 如果只dd不粘贴,则是删除
// x 删除光标当前所在位置 ,nx 删除光标连续的n个单词
// shift+nx 往前删除

//dG 删除当前及以下所有行
//d$/D	删除从光标所在字符到行尾的数据
//d0	删除从光标所在字符到行首的数据

// 光标移动
h: 左, h在最左侧
ctrl+h:可以退行的左
j: 下, jump
k: 上, king
l: 右, l在最右侧


vim 可视化选择
v	字符选择，会将光标经过的地方反白选择 -- 再按一次取消
V	行选择，会将光标经过的行反白选择
ctrl+ v 块选择 -- 绿色也会删掉
d	将反白的地方删除掉。(d)elete
D	将反白的地方经过的行都删除掉。(D)elete
y	将反白的地方复制。(y)ank
p	将刚刚复制的区块，在光标所在处贴上。(p)ut
u	将选中部分的字符全部改为小写
U	将选中部分的字符全部改为大写
>	将选中部分右移（缩进）一个 tab 键规定的长度（CentOS 6.x 中，一个tab键默认相当于 8 个空白字符的长度）
<	将选中部分左移一个 tab 键规定的长度（CentOS 6.x 中，一个tab键默认相当于 8 个空白字符的长度）

//linux批量化处理命令 -- 块模式
# ctrl+v+选择行+I,输入符号,esc // 批量化添加,即块添加,一般用于注释
# ctrl+v+选择块+d  //块删除



// n+移动 :移动n行或n位




//vim在退出前,可以撤销和undo.保存也可以
//vim在退出后,之前的修改不能再撤销

f<char> //f+字符==移动到该字符,shift是往前移动 -- 仅当前行

//shift+g移动到文本尾行
//gg 移动到文本首行
//n+shift+g 移动到第n行
//shift+$ 定位到行尾
//shift+^ / 0  定位到行首

//w以单词/字符为单位向右移动
//nw 移动n个单位
//b以单词/字符为单位向左移动(back)
//nb 移动n个单位
//e 移动到单词尾,空格前
//E 移动到单词尾的符号处,空格前

%	光标移动到匹配的字符(括号什么的一对符号)处。(),[],{},<>。%: goto match

+	光标移动到下一列的非空白字符  -- 慢慢移动
-	光标移动到上一列的非空白字符
[[ / ]] / (( /)) // 快快移动

//shift+~ 大小写切换
//r 替换光标所在字符, nr 连续换n个 // 按r后输入需要替换的字符
//shift+r 进入替换模式 ,输入会替换掉原有字符

1、翻整页命令
Ctrl + f 键 （f 的英文全拼为：forward）
Ctrl + b 键 （b 的英文全拼为：backward)

2、翻半页命令
Ctrl + d 键 （d 的英文全拼为：down）
Ctrl + u 键 （u 的英文全拼为：up）


//卡死可能的解决方案--ctrl+q
}

vim插入模式
{

$ #为注释

}

vim buffer
{{{
在不同文件buffer间切换
用 vim file1.txt file2.txt ... 命令同时打开多个文件，或者在 vim 里面用 :edit 命令再打开其他文件时，会有多个文件buffer，可以不用退出 vim 就同时编辑多个文件。

可以用下面命令在不同文件buffer间切换：

:bn
切换到下一个文件
:bp
切换到上一个文件
:ls
打印文件buffer的列表，带编号
:b [N]
切换到第N个文件，例如 :b 3 命令切换到第3个文件。文件编号可以用 ls 命令查看
:b {bufname}
通过文件名切换到 bufname 对应的文件，输入文件名时，可以用Tab键补全。
使用Tab键补全时，每按一次Tab键，就会补全一项。如果不小心跳过了想要打开的文件名，可以用 CTRL-P 键返回到前面的项。
:bnext
:bprevious
:blast //bl
:bfirst  //bf

:badd test5     //ba 
:bdelete test4  //bd

}}}

# yum install -y vim //安装vim

//vim打开文件
# vim 文件 //用vim打开文件

# vim // 直接打开vim -- 测试是否安装vim -- 目前基本上所有云服务器默认都装了vim

$ vim的配置文件每个用户有一个, linux配置文件所有用户共享

$ vim的配置文件名字为.vimrc
// vim配置文件用双引号的其中一个"来注释
// vim的配置一行命令就是一个配置

$ vim的插件目录名字为.vim

70 """"""""""""""""""""""" 按键映射和快捷键提示
271 " 跳转到定义
272 nnoremap <c-k> :YcmCompleter GoToDefinitionElseDeclaration<CR>
273 " 返回到跳转前的位置
274 nnoremap <c-l> <c-o>


$ 自动化配置命令
curl -sLf https://gitee.com/HGtz2222/VimForCpp/raw/master/install.sh -o ./install.sh && bash ./install.sh


$ 不使用table制表,使用空格最好,不同平台table占位不一样 -- 或者把\t制表符改成空格占用











//7

//linux编译器
GCC编译C语言
G++编译C++

gcc命令选项
-E 只激活预处理,这个不生成文件,你需要把它重定向到一个输出文件里面
-S  编译到汇编语言不进行汇编和链接
-c  编译到目标代码
-o 文件输出到 文件
-static 此选项对生成的文件采用静态链接
-g 生成调试信息。GNU 调试器可利用该信息。
-shared 此选项将尽量使用动态库，所以生成文件比较小，但是需要系统由动态库.
-O0
-O1
-O2
-O3 编译器的优化选项的4个级别，-O0表示没有优化,-O1为缺省值，-O3优化级别最高
-w  不生成任何警告信息。
-Wall 生成所有警告信息。


C语言/GCC

$ gcc默认是C89
# gcc ... -std=c99  //修改GCC执行C99标准
//gcc/g++默认生成的可执行程序是release版本
# gcc ... -g        //修改为debug版本

G++安装
yum -y install gcc+ gcc-c++ //必须这样才可以


// gcc g++都不需要写上头文件 -- 头文件在预处理阶段会自动在当前目录或库中寻找.c文件中所include的文件,并拷贝到c文件中,所以不用带.h文件

$$ 程序的翻译
1.预处理(头文件展开(合并到成我们的代码),条件编译,宏替换,去注释)
//预处理后还是C语言
$ -E 执行到预处理结束就停下 
组合 # gcc -E 源文件 -o 文件.i  //将预处理后的文件重命名到新文件,一般为.i文件

2.编译 -- 将C语言编译成汇编语言
# gcc -S .c文件 //从头开始,知到编译结束后停下  -- 默认自动生成.s文件 
# gcc -S .i文件 //从预处理后的文件开始         -- 默认自动生成.s文件 
# gcc -S .i/.c文件 -o 新文件  //自定义.s文件
$ .s文件是汇编文件

3.汇编 -- 将汇编语言翻译成 可重定位目标二进制 文件 -- 该二进制文件不可被执行bin/obj..
// 只翻译我们实现的代码 -- 即我们调用的代码不做处理
# gcc -c .c/.i/.s文件     //生成.o文件 -- 二进制文件  -- 对等windows的.obj文件
# gcc -c 文件 -o 重命名  // 自定义.o文件
$ 一般情况,有几个源文件,就有几个.obj文件

4.链接 -- 将程序和对应的库链接起来
//将我们自己形成的.obj文件和对应的库文件某种合并,形成可执行程序
# gcc .o/.c/... 文件 //链接
# gcc .o文件  //链接 -- gcc会自动识别 ,不需要命令选项了

$ 记忆: 命令选项为ESc键 ,生成的文件为.iso

//gcc
# gcc -o 命名 源文件 // 编译源文件并命名 , 只要命名在-o后面即可
# gcc 源文件 -o 命名 //

//宏可以没有值

//条件编译  -- 就是一个宏版本的if-else
#ifdef 宏    --如果该宏被定义,则执行 -- #define (宏)关键字..
   //...
#else        --否则执行这条 
   //...
#endif

//ifndef 是如果宏没有定义 ,即ifdef的否定

# ldd 可执行文件 //查看看可执行文件链接的库








$ linux的C语言头文件库位于 /usr/include


$ 库分两种 -- 库也是文件  -- linux下特有的
1.静态库: libXXXXXXXX.a

2.动态库: libXXXXXXXX.so

$ linux识别库:去掉前缀lib,去掉后缀,得到的就是库的名字,例如库/lib64/libc.so.6 -> libc-2.17.so的名字为c-2.17 <--> C语言的C标准库

$ windows下静态库为.lib文件 ,动态库为.dll文件 -- 两系统库体系不一样,原理一样

$ 代码运行必须要有语言的头文件和库文件

$ 证明linux的大部分命令是c语言写的 -->
# ldd ../命令 //看链接的库是否有c语言的c标准库 -- 前提是动态链接
//not a dynamic executable -- 非动态链接提示

// 链接是由编译器完成的,编译器负责寻找库,并链接上

$ 动态库 == 共享库
//只有只读属性 ,一般一个系统里只有1份

$ 动态链接:把库所在的地址拷贝到程序里
$ 静态链接:把程序需要的库直接拷贝到程序中

$ 动态库:专门让编译器,对用户程序进行动态链接的
$ 静态库:专门让编译器,对用户的程序进行静态链接的

$ 静态库的优点:健壮性强. 缺点:程序体积,内存/磁盘开销大,拷贝速度慢
$ 动态库的优点:程序体积小,节省空间,速度快  缺点:不够安全

$ 静态库VS动态库:linux默认使用的是动态链接

$ file命令和ldd命令搭配使用
# file 可执行文件  //查看可执行文件信息  -- 

//dynamically linked 动态链接
//statically linked 静态链接


$ /usr/bin/ld: cannot find -lc错误
//原因:在新版本的linux 系统下安装 glibc-devel、glibc和gcc-c++时，都不会安装libc.a. 只安装libc.so. 所以当 使用-static时，libc.a不能使用。只能报找不到libc了。
//解决:yum install glibc-static
//C++:yum install glibc-static libstdc++-static -y

$ LSB:linux中lsb是指linux标准基础，是“Linux Standards Base”的缩写，LSB是Linux标准化领域中事实上的标准，制定了应用程序与运行环境之间的二进制接口，保证了LINUX发行版同LINUX应用程序之间的良好结合。

$ ELF是linux下的可执行程序 ,对应windows的exe









// linux项目自动化构建工具make和makefile  --////生成一个可执行程序
{


//make是个命令,makefile是个文件(m不区分大小写,Makefile也可以)

$ makefile一般放在当前源码路径下

$ makefile是一个围绕依赖关系和依赖方法构建的自动化编译的工具

$ 创建makefile文件语法 
依赖关系 //语法中 目标文件:依赖文件列表 -- 目标文件依赖于依赖文件 -- 依赖文件可以有多个,用空格分隔
    依赖方法 //语法块要求开头必须是制表符table
依赖关系
    依赖方法

$ 依赖关系中,目标文件对应的依赖文件列表可以是空

# make命令的使用
1.默认第一个依赖关系不需要带目标文件,直接make就能执行一个依赖关系的依赖方法
2.要执行其他依赖关系,需要make 目标文件 

$ 多依赖关系/传递依赖关系使用栈结构(其他语法实现大多是栈结构),后进先出,--第一行依赖关系先入栈,后面依次入栈 -- 直到满足起始条件 
// 入栈过程会带着各自的依赖方法进栈

$ clean: //clean:是依赖关系,clean是目标文件,虽然他没有依赖文件.只要是依赖关系都可以有自己的依赖方法

符号学习:
1. $@ // 永远表示目标文件,依赖关系中冒号的左边
2. $^ // 表示依赖文件列表,依赖关系中冒号的右边



演示1:
out_name:src_file  //out 依赖于src
    gcc -o  out_name  src_file  //制表符开头
.PHONY:clean
clean:
    rm -f out_name  //

演示2: //传递依赖关系
out:out.o    
  gcc -o out out.o    
out.o:out.s    
  gcc -o out.o out.s -c    
out.s:out.i    
  gcc -o out.s out.i -S    
out.i:2.c    
  gcc -o out.i 2.c -E    
.PHONY:clean    //伪目标:总是被执行的
clean:                                                                              
    rm -f out     
    rm -f out.o    
    rm -f out.s

$ 使用make命令
# make //默认只执行第一组依赖关系,执行完第一组就终止 -- 执行其他依赖关系需要make+其他命令选项 / 第一条也可以加上命令选项(只有第一条可以省略)
# make clean //执行makefile中的clean语句块

//执行make命令时,会默认在当前目录去寻找makefile/Makefile文件,然后分析,处理... -- make和makefile的关系

//phony 假的 [ˈfoʊni]  -- 假执行 -- 没执行 -- 
$ .PHONY: //make命令关键字 -- 作用:"总是被执行的" -- 功能是每次都会重新执行,无论是否已被执行过
//linux提示::make: `out' is up to date. -- 意思是已经是最新的执行了 ,出现这条提示说明,make命令没有被执行,即:不是"总是被执行的"

$ 在Makefile中，不加.PHONY的目标也可以是伪目标，这是因为Makefile默认将没有依赖关系的目标视为伪目标。\
        伪目标通常表示一组操作或任务，而不是用于生成文件的目标。

//make是怎么检测源码有没有更新过? make通过检查源代码修改和可执行程序的生成时间来决定要不要执行,
// -- 因为同一版本的可执行程序永远是在源代码编写完成后才有的,即只要新的源代码的修改时间晚于对应的可执行程序,则说明程序不是最新的了
//扩展:vs2019下有时编译出问题,就清理项目再生成一次 -- 因为很多文件之前编译过了,编辑器不再重复编辑,这就有可能出问题,所以重新清理一下可能有效果

# touch 已存在的文件 // 把已存在的文件的所有时间都更新成最新时间 -- 摸一下就变了
$ touch后make就能再执行了


$ 对于多.c文件的makefile处理
{
out:main.c prog.c    //依赖文件列表
  gcc -o out main.c prog.c   //多个.c文件                                                 
.PHONY:clean    
clean:    
  rm -f out    
} 
--C语言include""会先扫描当前文件夹再扫描其他文件夹 -- 目前都放在同一目录就可以,
--头文件在预处理阶段会自动地拷贝到c文件中,所以不用带.h文件,只要.c文件即可

}

makefile{  //生成多个可执行程序

makefile文件演示:
CC = g++    
CFLAGS =    
LDFLAGS = -std=c++11    
    
FILE1 = server    
FILE2 = client    
    
//makefile中,第一组依赖关系就是要构建的目标文件
.PHONY:all                                                                   
all: server client    //让all只有依赖关系,没有依赖方法,即不做任何的构建过程

//然后通过执行依赖项的任务从而生成两个目标文件
    
server: server.cc    
  $(CC) $(LDFLAGS) -o $@ $^    
    
client: client.cc    
  $(CC) $(LDFLAGS) -o $@ $^    
    
# .PHONY:clean     //加不加无所谓,在Makefile中，不加.PHONY的目标也可以是伪目标，这是因为Makefile默认将没有依赖关系的目标视为伪目标。
clean:    
  rm -f $(FILE1) $(FILE2)






}

linux头文件类

$ unistd.h //linux中类似微软windows.h的库
{
unistd 是 "Unix Standard" 的缩写，它是一个C标准库头文件，主要用于提供对POSIX（Portable Operating System Interface for Unix）标准中定义的各种系统调用和常量的访问。unistd.h 头文件在Unix和Unix-like操作系统上广泛使用，用于实现与系统相关的操作，包括文件、I/O、进程管理等。

unistd.h 提供了许多与系统调用相关的函数和常量，包括但不限于：

文件操作： 通过 open()、close()、read()、write() 等函数来进行文件操作。

目录操作： 使用 opendir()、readdir() 等函数来进行目录操作。

进程控制： 使用 fork()、exec*()、wait*() 等函数来创建和管理进程。

环境变量： 使用 getenv() 和 setenv() 等函数来处理环境变量。

系统调用： 通过 syscall() 等函数可以直接调用底层系统调用。

常量定义： 包括文件描述符、错误码、路径最大长度等常量的定义。

系统资源限制： 使用 getrlimit() 和 setrlimit() 等函数来获取和设置系统资源限制。

unistd.h 是C标准库的一部分，为编程人员提供了与底层操作系统交互的接口，可以执行文件、进程、I/O 等各种操作。这个头文件允许程序在Unix和Unix-like操作系统上编写可移植的系统调用和操作系统相关代码。
}


fcntl.h
{
fcntl 是 "file control" 的缩写，表示文件控制。

<fcntl.h> 是一个C标准库头文件，通常在C和C++程序中使用，用于提供文件控制相关的函数和常量。这个头文件主要用于进行文件操作、文件描述符的控制以及文件锁定。以下是一些 <fcntl.h> 头文件中主要功能和常量的示例：

文件打开和创建： <fcntl.h> 包含了常量，例如 O_RDONLY（只读）、O_WRONLY（只写）、O_RDWR（读写），用于指定文件打开模式。

文件描述符控制： 这个头文件包含了函数如 open()、creat()（用于创建文件）、close() 以及 dup() 和 dup2()，用于操作文件描述符。

文件锁定： 使用 <fcntl.h> 中的函数来设置和管理文件锁定，以确保多个进程不会同时修改同一个文件，避免数据损坏。

I/O 操作： 包括 read() 和 write() 等函数，用于读取和写入文件。

文件属性和状态： <fcntl.h> 包含了一些与文件属性和状态相关的常量，如 F_GETFL、F_SETFL，用于获取和设置文件状态标志。

文件控制： 这个头文件中的常量和函数可以用于文件的控制操作，如 fcntl() 函数可用于改变已打开文件的属性或状态。

文件同步： 包括 fsync() 和 fdatasync() 等函数，用于刷新文件缓冲区，将数据写入磁盘。

<fcntl.h> 头文件是在Unix和Unix-like操作系统上广泛使用的，用于进行底层文件和文件描述符的控制。通过这个头文件，程序可以实现文件的读写、锁定、属性设置等操作，从而满足各种文件处理需求。
}


$ man 3 //linux 的C/C++语言手册






/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
linux中ctrl+s是暂停终端输入 -- 作用就是不能输入了,堵塞 --[锁定终端] //此时输入的数据都缓存在缓冲区中 -- 感觉很危险
-- 通过ctrl+q恢复 -- 恢复屏幕输出[解锁终端]







/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

$ sudo不能由普通用户直接执行,必须是信任的用户才可以
//用户 is not in the sudoers file.  This incident will be reported. //xx用户不在sudoers文件里,这个严重事件将被报告
$ sudoers路径:/etc/sudoers
//-r--r-----. 1 root root 4358 Dec 19  2022 sudoers //默认情况任何一个普通用户都没有权限修改,最多只有读权限 -- 只有root能修改

$ 增加信任用户:
.进入到/etc目录 ,打开sudoers文件,
.找到Allow root to run any commands anywhere所在行  //新机器一般在100行左右
.在下方找到root    ALL=(ALL)       ALL,然后复制一份在下一行
.把root改成用户名,即:用户    ALL=(ALL)       ALL



//8


1.认识\r\n
//c语言中字符分为a.可显字符(能够显示输出的) b.控制字符('\n','\t'等)
//认识换行-回车 :平常中新起一行是从当前行的位置进到下一行的行首,而计算机中,这一步其实是由两步操作完成的:1.进到下一行的同样位置 2.回到行首 (或者先回到行首再进下一行
//即 \n\r 或 \r\n
//而\n叫做换行(进到下一行的同样位置) \r叫做回车(回到行首)
// 一般编译器\n都会合并\n\r一起,实现新起一行的操作

2.缓冲区概念

\n在很多语言中具有刷新缓冲区的作用,即遇到\n会立刻将缓冲区的数据输出

//缓冲区有自己的刷新策略:
行缓冲:遇到换行符\n就刷新缓冲

缓冲区刷新方案有很多种:无缓冲,行缓冲,全缓冲..
//缓冲还有使用主动调用函数如fflush(stdout)刷新,进程退出时由系统自动刷新

\r的作用是将控制台的光标移动到行首
\r的神奇现象:如果在linux中打印一个长度小于命令提示符的数据,会发现没有打印的效果(打印的东西看不到) -- 其实就是光标移到了行首,然后命令提示符覆盖打印的数据
//发现 -- 在\r后的输出会把光标所在位置的原字符覆盖掉 -- 

凡是向显示器打印的内容都是字符,一个一个的字符输出-- putc()  -- 所以叫做 字符设备

$ 缓冲区处理方案与平台有关,不同不太不同处理方案


linux第一个小程序 -进度条

printf("  [\033[44m%-s\033[0m\r",bar);//c语言颜色为 \033[数字m "字符串" \033[0m   //0m:截至关闭颜色






















//git 

gitee和github区别:底层都是基于git的网站化git管理服务端

$ 查看git版本 -- 查看git是否安装
# git --version

sudo yum install -y git

# git clone 克隆地址 
//输入用户名:注册gitee/github的手机号或用户名或完整邮箱 -- 注册的账号
//账号密码

删除git仓库 // .git就是仓库
# rm .git -rf


# git add . //把当前目录下所有文件提交到暂存区
# git add [file1] [file2] ... //单独添加多个文件到暂存区 ,以空格分隔
# git add [dir] // 添加目录
# git add -A //这个命令会递归地将当前目录及其子目录中的所有更改和已删除的文件添加到暂存区。:解决add不了的问题



# git commit -m "修改信息" //提交到本地仓库  -- 提交暂存区到仓库区
# git commit [file1] [file2] ... -m [message]  //提交暂存区的指定文件到仓库区
# git commit -a  //提交工作区自上次commit之后的变化，直接到仓库区
# git commit -v //提交时显示所有diff信息
# git commit --amend -m "message" //使用一次新的commit，替代上一次提交(重做上一次commit),如果代码没有任何新变化，则用来改写上一次commit的提交信息  
// 不要随便重做 -- 把持不住


//提交代码必做
# git config --global user.name "提交用户名" //给别人看的
# git config --global user.email "提交邮箱"
# git config --list //查看提交用户和邮箱
# git config --global --list


# git status //显示有变更的文件
# git log //显示当前分支的版本历史, 查看提交日志 --按q退出历史记录列表
# git log --stat //显示commit历史，以及每次commit发生变更的文件
...

# git branch 列出所有本地分支
# git branch -r 列出所有远程分支
# git branch -a 列出所有本地分支和远程分支
# git branch [branch-name]  新建一个分支，但依然停留在当前分支
# git checkout -b [branch] 新建一个分支，并切换到该分支
# git checkout [branch-name]切换到指定分支，并更新工作区
 ...

 远程同步
# git fetch [remote]//下载远程仓库的所有变动
# git remote -v //显示所有远程仓库
# git remote -v //查看已添加的远程仓库
# git pull //取回远程仓库的变化，并与本地分支合并
# git push //上传本地指定分支到远程仓库

git clean 
...
-----------------------------------
Git常用命令大全：git命令基本用法
https://blog.csdn.net/hejinde/article/details/131229840


解决git每次提交和拉取代码需要输入用户名和密码问题
输入以下命令行：
# git config --global credential.helper store //之后等待下一次输入账户密码操作后(自动记住账号密码)即可

# git rm 文件 //
# git rm [file1] [file2] ... //删除工作区文件，并且将这次删除放入暂存区
# git rm --cached 文件 //文件从暂存区域移除，但工作区保留：


$ git如果是push到别的平台则需要的是邮箱+密钥
$ git如果是push到自己的平台,则只需密码


$$ git的问题解决:

一.git删除文件后提交不了:
如果删除了文件,则命令git会提交失败,此时必须要使用命令git rm删除掉远端中刚刚在本地删除的文件,然后才能提交



//颜色.....

一般系统默认的提示符形式是：[username@host 工作目录]$ 

$ 默认命令提示符规则  # echo $PS1 //[\u@\h \W]\$
@  : #就是普通字符
\d ：#代表日期，格式为weekday month date，例如：“Mon Aug 1”
\H ：#完整的主机名称
\h ：#仅取主机的第一个名字 //主机名
\t ：#显示时间为24小时格式，如：HH：MM：SS
\T ：#显示时间为12小时格式
\A ：#显示时间为24小时格式：HH：MM
\u ：#当前用户的账号名称 //用户名
\v ：#BASH的版本信息
\w ：#完整的工作目录名称
\W ：#利用basename取得工作目录名称，所以只会列出最后一个目录
#：#下达的第几个命令
$ ：#提示字符，如果是root时，提示符为：# ，普通用户则为：$
-----------------------------------
https://blog.51cto.com/u_11566825/2063370


2.设置颜色
在PS1中设置字符颜色的格式为：
[\e[F;Bm]，其中“F“为字体颜色，编号为30-37，“B”为背景颜色，编号为40-47。颜色表如下：

[\e[F;Bm]需要改变颜色的部分[\e[0m]
开始颜色输入：[\e[F;Bm]
结束颜色输入：[\e[0m]
　　　　F　Bm
　　　　30 40 黑色
　　　　31 41 红色
　　　　32 42 绿色
　　　　33 43 黄色
　　　　34 44 蓝色
　　　　35 45 紫红色
　　　　36 46 青蓝色
　　　　37 47 白色
　　　　
设置特殊显示　
　　　　 0 OFF，关闭颜色
　　　　 1 高亮显示 //亮瞎狗眼
　　　　 4 显示下划线
　　　　 5 闪烁显示 //跑马灯 黑闪黑闪
　　　　 7 反白显示 //背景与字体颜色反过来
　　　　 8 颜色不可见
-----------------------------------
https://www.cnblogs.com/ggzhangxiaochao/p/13141437.html

//修改主机名
# sudo hostnamectl set-hostname 新名字(不能是中文)

$ 我的设置: # PS1="\e[36m\][\u@\h \W\t]\\$\[\e[0m]" //复制到相应文件中

$ 写入~/.bash_profile或~/.bashrc只对当前用户生效。
$ 写入/etc/profile或/etc/bashrc对全部用户生效

$ source 命令：常用于重新执行刚修改的初始化文件。如/etc/profile ， bash_profile， bashrc?通过 source命令 在不重启的情况下生效。//刷新
$ . 命令 //和等价于source命令,让配置文件立即生效
PS1="[\e[37;1m]  [  [\e[31;1m]\u [\e[36;1m]@ [\e[33;1m]\h [\e[35;40m]\W[\e[37;1m]  ]   [\e[33;1m]\$[\e[0m]




//GDB gdb

# sudo debuginfo-install glibc-2.17-326.el7_9.x86_64 libgcc-4.8.5-44.el7.x86_64 //环境

readelf -S 文件 //读elf格式的可执行程序的二进制文件

# gdb 文件  //backtrace
# quit或q   //退出gdb 

# gdb 有debug信息的可执行文件
# l //list -- 显示部分代码
# l+n //从哪一行开始显示
# l file:行号/函数名 //
# b 行号 //breakpoint -- 给哪行打断点
# d/delete 断点编号 //删除断点
# d breakpoints // 删除所有断点
# r // run//执行 -- 到断点处停下来
# info b //查看所有打的断点 -- 断点有编号Num,依次递增,不会循环 ,直到退出gdb
# disable Num //暂停断点
# disable breakpoint Num// 全称
# enable Num //启用断点 -- 使能
# enable breakpoint Num// 全称
# n/next //逐过程
# s/step //逐语句 --步骤 - 可能会进到库的代码 -- 所以要注意用n跳出去
# until 行号 //在函数内,指定位置跳转,执行完区间代码.直接运行到指定行 -
# finish // 运行完当前函数
# c/continue   //运行到下一个断点
# f/frame   //简写f, f 0 切换到栈0，即栈顶

# set var：修改变量的值 -- 用的情况比较少,在循环里i,j什么的可能好用

//命令中的文件是源文件,不是可执行程序 -- 可能有多个源文件,所以能带文件名 -- 

//调用函数要压栈 --  
# bt/backtrace //查看调用栈
  #0  addToTop (top=100) at gdb.c:6             //压栈
  #1  0x00000000004005bc in main () at gdb.c:22 //栈底

# p 变量 //查看当前变量的值
# display 变量 //长监视 -- 每次都会自动刷新 -- 会生成和断点一样的编号 (支持:内置类型,自定义类型,stl...)
# undisplay 编号 // 需要编号才能删除
# info display // 查看所有长监视的变量
# info/i locals // 查看局部变量的值   

---- 所有的info都可以简写成i , i+首字符可以提示语法

//指定(可带文件名)关键字打断点: #b (文件名:)关键字 //
//遇到不能打断点的地方,断点对进到不能打的下下....一行,直到遇到能打断点的位置

//breakpoint already hit 1 time //断点已经命中一次 
//no breakpoint or watchpoint //没有断点或观察点
//watchpoint //观察点 -- 没有被激活的

//gdb会自动记忆最近一次的命令 -- 回车重复上次命令 -- 如list后回车会将剩下的代码依次打印出来


//测试人员一般只要release的可执行程序
//gcc/g++默认生成的可执行程序是release版本\
# gcc ... -g  //修改为生成debug版本

# readelf -S 可执行文件 //
在Linux下，readelf -S命令用于显示目标文件或共享目标文件的节表信息。
它可以列出目标文件的所有节（section）的信息，包括每个节的名称、类型、大小、偏移量等。其中，节是目标文件中的一些逻辑段，用于存储程序的代码、数据和符号表等信息。
通过readelf -S命令，用户可以快速查看目标文件中包含的各个节的信息，有助于了解程序的结构和调试信息。此外，readelf -S命令还可以用于分析和调试程序，例如确定程序的内存映像、调试符号表等
————————————————
https://blog.csdn.net/m0_65379664/article/details/130382886

# readelf -S elf文件 | grep -i debug // -i忽略大小写,过滤出所有带debug的信息 -- 没有说明不是debug文件



// --- 9 --- 

//linux可以运行,编写各种主流语言(主要是后端语言 -- 需要部署环境 -- 很多其他语言有需要linux服务器的地方) 

一台台机器 -- 一台台冯诺依曼机
冯诺依曼体系 -- 是硬件结构  -- 目前大部分计算机,服务器都遵守冯诺依曼体系
计算机能力 -- 木桶原理(能装多少水,取决于最低的木板) -- CPU快,外设慢->内存:解决速度不匹配问题 
CPU只从内存读取数据,外设需要装入内存才能被CPU读取,运行; 寄存器很快,也可以存数据,但寄存器很贵 -- 计算机是通过技术手段打造出来的性价比产物

外设只会和内存打交道(数据层面)
-- 外设有些控制信号可以直接和CPU沟通
//不考虑缓存情况，冯诺依曼体系的CPU能且只能对内存进行读写，不能访问外设(输入或输出设备)

因为有内存存在,我们可以对数据做预加载(从外设取到内存),这时如果CPU需要进行数据运算的时候直接从内存中取,就不需要再访问外设了;

通过内存 -- CPU可以先将数据存在内存中,合适时可以一次写入到外设 -- 减少与外设沟通次数,减少I/O次数,提高效率


数据(传输过程)流向是由硬件结构决定的

操作系统是软件 -- 一款对软硬件资源管理的软件
    硬件局限性于 -- 控制不了数据流向(调度)

操作系统如何对硬件做管理
1.管理者和被管理者可以不直接沟通 -- 不需要直接沟通
2.管理者和被管理者没有直接沟通,那如何进行管理
管理的本质:对被管理对象的数据做管理 -- 决策
3.管理者如何拿到被管理者的数据?
先描述,再组织 --  描述:语言  -- 组织:数据结构  -------> 对管理做建模

操作系统 -- (硬件)驱动 -- 硬件(软件)
每个硬件都有对应的硬件驱动,操作系统通过硬件驱动获取到信息,操作系统其抽象(面向对象)提取,构建成一个设备结构体,然后构建结构体结点,然后以某种数据结构管理起来

操作系统为什么要对软硬件资源做管理? 计算机本质是为人服务,操作系统管理好能更好的为人提供服务
    操作系统对下通过管理好软硬件资源(手段),对上给用户提供良好(安全,稳定,高效,功能丰富等)的执行环境(目的)

操作系统也能对软件做管理 -- 和硬件类似,管理软件可以直接管理, 管理硬件需要驱动

操作系统能给我们提供非常良好的服务,并不代表操作系统会相信我们.相反,操作系统不相信任何人!!

系统调用 -- 在linux中就是操作系统提供的C函数 
-- 系统调用使用成本很高(需要懂系统),所以在此之上,又有了 GUI 或  shell和工具集   或编程语言和库函数(封装了系统调用); (应用层)其他高级应用再基于外壳之上..

(系统调用一定是接口,接口不一定是系统调用)

目前我们写的代码基本都是应用层代码


硬件无法知道CPU需要自己什么信息,无法提前将数据加载进内存中 -- 操作系统负责这方便工作,操作系统通过算法实现预加载 -- 局部性原理
加载:操作系统把数据从外设到移动内存

库函数大部分时对系统调用的封装.  -- System Call
   不是所有库函数都是系统调用的封装,有些库函数没有访问硬件,并不是系统调用 

库函数很多是系统调用的组合后提供更丰富的功能 -- 提高开发效率



/////////////进程/任务  -- task
任何启动并运行程序的行为,都是由操作系统帮助我们将程序转换成进程 -- 进程:完成特定的任务

进程控制块:PCB(win) / task_struct(linux) -- 结构体结点/内核数据结构 -- 提取了进程的所有属性


task_struct是PCB的一种
在Linux中描述进程的结构体叫做task_struct。task_struct是Linux内核的一种数据结构，它会被装载到RAM(内存)里并且包含着进程的信息。

task_ struct内容分类
{
标示符:     描述本进程的唯一标示符，用来区别其他进程。
状态:       任务状态，退出代码，退出信号等。
优先级:     相对于其他进程的优先级。
程序计数器: 程序中即将被执行的下一条指令的地址。
内存指针:   包括程序代码和进程相关数据的指针，还有和其他进程共享的内存块的指针
上下文数据: 进程执行时处理器的寄存器中的数据[休学例子，要加图CPU，寄存器]。 I／O状态信息: 包括显示的I/O请求,分配给进程的I／O设备和被进程使用的文件列表。
记账信息:   可能包括处理器时间总和，使用的时钟数总和，时间限制，记账号等。
其他信息
}

linux中所有运行在系统里的进程都以task_struct链表的形式存在内核里。

进程 = 进程控制块+内存中数据/代码
     = 内核关于进程的相关数据结构+当前进程的代码和数据

进程管理:管理PCB

操作系统对进程的管理 == 描述+组织 == 对进程控制块的数据结构进行CRUD 


无论用户需求是什么,都是操作系统对内存的部分数据作描述和组织

文件 = 内容+属性,但PCB中的属性与文件中的属性有关系但关系不大,PCB中主要是维护由操作系统创建的一些数据.有关系地方是在需要获取文件属性时需要


//linux 进程命令

用户级工具ps
# ps axj | grep myprocess //查看进程 -- 只查看myprocess进程
# ps axj | head -1 && ps axj | grep myprocess //先管道得到ps axj的第一行(各属性名称), 查看myprocess进程  //管道|优先级比&&高
# ps axj|head -1 && ps axj|grep myprocess |grep -v grep //过滤掉带grep这行 , ps axj|grep后会多一个无关项,过滤掉好看一点

$ 测试执行程序是不是进程 - 执行同一个程序两次 -- 查看是否是同一个可执行程序的两个不同的进程
[chj@expiration1102 1.2进程学习 16:52:10]$ ps axj|head -1 && ps axj|grep myprocess |grep -v grep
 PPID   PID  PGID   SID TTY      TPGID STAT   UID   TIME COMMAND
19970 20647 20647 19970 pts/3    20647 S+    1002   0:00 ./myprocess
20716 20738 20738 20716 pts/4    20738 S+    1002   0:00 ./myprocess
//PID是每个进程的编号

# ps aux | head -1
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND

ps
{
# ps -u //只看用户打开的进程
# -e 或 -A：显示所有进程，包括其他用户的进程。
# -l：以长格式显示进程信息，包括更多的详细信息如F字段（进程状态）和NI字段（优先级）。
# -aux：显示所有用户的所有进程的详细信息，通常与grep一起使用以查找特定进程。
# -p：仅显示指定PID的进程信息。
   //ps -p PID

# -C：仅显示具有指定命令名的进程。
    //ps -C process_name

# -t：显示与指定终端相关的进程。
    //ps -t tty_number

# -o：自定义输出格式，可以选择要显示的字段。
    //ps -o pid,ppid,cmd
}



# ls /proc   // 保存进程属性的目录 -- 内存级的文件系统(磁盘上不存在)

/proc内以数字命名的目录是进程信息文件,其名字就是进程的PID

进程文件内其中有两行数据 -- 目前能看懂的,可以证明是执行的程序的进程
lrwxrwxrwx 1 chj chj 0 Sep 14 21:11 cwd -> /home/chj/git_repositories/linux_code/1.2进程学习
lrwxrwxrwx 1 chj chj 0 Sep 14 21:11 exe -> /home/chj/git_repositories/linux_code/1.2进程学习/myprocess

如果中断程序运行,则该进程文件会直接删除
ls: cannot open directory .: No such process //正在访问的目录也会删除
-bash: cd: ..: No such file or directory //cd .. 也执行不了


$$$$  学习第一个系统调用
pid_t getpid(void)  // 获取进程的PID  -- 谁调的getpid就返回谁的pid
pid_t就是int
头文件为#include<unistd.h> 和#include<sys/types.h> //包含两个才不会报错
返回值为进程PID

pid_t getppid(void) //获取父进程id  
$ 在测试父进程与子进程过程中,发现每一次重新执行程序,子进程PID改变,但父进程PID不会改变. -- 父进程是谁?  -- bash
在通过ps axj|head -1 && ps axj|grep 父进程PID |grep -v grep 查看后发现,父进程是bash
1.bash命令行解释器,本质上也是一个进程
2.命令行启动的所有程序,最终都会变成进程,而该进程对应的父进程都是bash -- (对应上之前学习的bash,bash执行的命令都交给子进程去执行)


$ 杀进程命令
# kill -9 PID  // 子进程,父进程,bash都能杀
//杀掉bash后,所有命令都无法正常执行了,所以为了bash安全,bash通过创建子进程方式执行命令
--- linux中没有母进程概念

$$$$ 如何创建子进程 ?
{
系统创建进程有windows打开可执行程序,linux:./可执行程序

$ 创建子进程函数
pid_t fork()         //叉子
头文件 #include<unistd.h>
返回值:
On  success,  the  PID of the child process is returned in the parent, and 0 is returned in the child. 
On failure, -1 is returned  in  the  parent,  no  child process is created, and errno is set appropriately.
成功后，在父进程中返回子进程的PID，在子进程中返回0,父进程返回>0的数。失败时，在父进程中返回-1，不创建子进程，并适当设置errno。
效果:父子进程代码共享，数据各自开辟空间，私有一份（采用写时拷贝）

fork在返回时,父子进程都有了,分别在父子进程中ruturn,父进程中return>0,子进程中return 0,总共return两次.返回时发生写实拷贝 -- 看进程地址空间

程序:
printf("AAAAAAAAAAAAAAAAAAAAAAA; pid:%d; ppid:%d; \n",getpid(),getppid());
pid_t ret = fork();                                                                                                                   
printf("BBBBBBBBBBBBBBBBBBBBBBB; pid:%d; ppid:%d; ret:%d; &ret:%p; \n",getpid(),getppid(),ret,&ret);
结果:
AAAAAAAAAAAAAAAAAAAAAAA; pid:23641; ppid:23234; 
BBBBBBBBBBBBBBBBBBBBBBB; pid:23641; ppid:23234; ret:23642; &ret:0x7ffc3c8461fc;  //创建子进程成功,返回值是子进程PID
BBBBBBBBBBBBBBBBBBBBBBB; pid:23642; ppid:1; ret:0; &ret:0x7ffc3c8461fc; //子进程的返回值是0
发现:有两个值地址相同的不同值 -- 说明该地址不是物理地址(真实地址),而是间接地址 -- 写时拷贝的体现


$ 执行流 -- 多执行流 -- 宏观现象和单执行流很多差异,如if和else同时存在

$ fork作用
a.fork之后,执行流会变成两个执行流
b.fork之后,谁先运行由调度器决定
c.fork之后,fork之后的代码共享,通常我们通过if和elseif来进行执行流分流
d.fork之后,return需要为两个执行流执行返回代码,即产生两个返回值

$ fork原理: 
1.-- 拷贝大部分父进程的PCB,其中指向和父进程同样的内存块 . 小部分属于子进程私有,如子进程自己的PID
2.-- 代码共享 -- 代码只读,不可修改,不影响
3.-- 写时拷贝,当有一个执行流尝试修改数据时,OS会自动给当前进程触发写时拷贝
4.-- 进程具有独立性:1.销毁子进程不影响父进程;2.销毁没有父子关系的进程不会影响别的进程



}

$ PCB可以维护在不同的队列中 -- 调度

$ 代码是线性执行的 -- > 我们申请的资源是线性申请的/串行申请 -- 多进程也一样,各自申请各自的

进程状态:
$ 阻塞态: 进程因为等待 某种条件就绪 ,而导致的一种不推进的状态 ,即不被调度,宏观上如卡住了 : 阻塞一定是在等待某种资源,在OS管理的下排队等待
阻塞:进程等待某种资源就绪的过程
为什么阻塞/为什么进入阻塞态? 进程要通过等待的方式,等具体资源被其他对象用完后,再被自己使用
如挂到网卡资源等待队列,键盘等待队列 ... 等各种资源等待队列

$ 挂起态:
内存资源紧张时,会把某些阻塞进程交换到磁盘中(释放内存,腾出空间)  -- 挂起状态 ,全称阻塞挂起状态 -- 特殊的阻塞态

//运行态:在运行队列中,可以随时被调度

$ linux中新建状态就是运行态R,没有新建状态,就绪状态也是R -- 操作系统学科中有新建状态,就绪状态,但linux没有
//操作系统学科中是所有具体操作系统的集合,和具体操作系统不同.不同的具体操作系统有不同特点,不一定都有所体现
//操作系统学科又称计算机中的哲学

$$$$ linux进程状态数组task_state_array
 The task state array is a strange "bitmap" of reasons to sleep. Thus "running" is zero, 
 and you can test for combinations of others with simple bit tests.
 任务状态数组是一个奇怪的睡眠原因“位图”。因此，“运行”为零，您可以通过简单的位测试来测试其他组合。

$ 进程状态数组  -- task_struct中有int status用于表明该进程的状态
static const char * const task_state_array[] = {
"R (running)", /* 0 */
"S (sleeping)", /* 1 */ //linux特有的休眠状态
"D (disk sleep)", /* 2 */
"T (stopped)", /* 4 */
"t (tracing stop)", /* 8 */
"X (dead)", /* 16 */
"Z (zombie)", /* 32 */
};

一般来说,看一个进程是什么状态,可以看状态,也看这个进程在哪里排队.大部分进程不是运行就是阻塞态

R运行状态（running）: 并不意味着进程一定在运行中，它表明进程要么是在运行中要么在运行队列里。运行队列struct task_struct *runquque;
S睡眠状态（sleeping): 意味着进程在等待事件完成（这里的睡眠有时候也叫做可中断睡眠（interruptible sleep））。
D磁盘休眠状态（Disk sleep）有时候也叫不可中断睡眠状态（uninterruptible sleep），在这个状态的进程通常会等待IO的结束。
T停止状态（stopped）： 可以通过发送 SIGSTOP 信号给进程来停止（T）进程。这个被暂停的进程可以通过发送 SIGCONT 信号让进程继续运行。
X死亡状态（dead）：这个状态只是一个返回状态，你不会在任务列表里看到这个状态。
Z(zombie)-僵尸进程:
僵死状态（Zombies）是一个比较特殊的状态。当进程退出并且父进程（使用wait()系统调用,后面讲）没有读取到子进程退出的返回代码时就会产生僵死(尸)进程
僵死进程会以终止状态保持在进程表中，并且会一直在等待父进程读取退出状态代码。
所以，只要子进程退出，父进程还在运行，但父进程没有读取子进程状态，则子进程会进入Z状态
僵尸进程是无法被杀死的 kill-9也不行,因为谁也没法杀死一个死去的东西(进程)
// defunct

僵尸进程危害
.进程的退出状态必须被维持下去，因为他要告诉关心它的进程（父进程），你交给我的任务，我办的怎么样了。可父进程如果一直不读取，那子进程就一直处于Z状态？是的！
.维护退出状态本身就是要用数据维护，也属于进程基本信息，所以保存在task_struct(PCB)中，换句话说，Z状态一直不退出，PCB一直都要维护？是的！
.那一个父进程创建了很多子进程，就是不回收，是不是就会造成内存资源的浪费？是的！因为数据结构对象本身就要占用内存，想想C中定义一个结构体变量（对象），是要在内存的某个位置进行开辟空间！
.内存泄漏?是的！
.如何避免？ -- learn

S:休眠状态 -- 阻塞状态的一种,不在CPU运行,而是在等待某种资源.但确实是在运行队列.由于CPU很快,外设很慢,所以往往在宏观上表现为S,演示:死循环printf可以发现是S
   在linux中被称为"可中断休眠",演示:scanf()在等待时就是暂停状态,也可以通过结束程序达到中断.即S状态可以被终止,也可以暂停
   例如:拷贝文件到磁盘,则进程进入S,直到拷贝完成

D:不可中断休眠,普通开发一般很难遇到,而做系统管理,运维,IO,存储的经常会遇到
//ps:linux会杀进程
为了保护某些重要的进程不被杀死,所以有了D状态,目的是为了保护某些重要的进程不被杀死.
D状态下的进程无法被杀死,即便是操作系统也不能,甚至无法正常关机,只能断电源(数据损失).只有当D状态的进程恢复时才能杀死该进程
//一般情况下,D状态很难看到(99％),D进程一般都很快执行完毕.但如果D状态有且持续,则可能D进程所在的设备已经快不行了.原因有磁盘快满了,压力过大.再多几个D可能就直接挂掉,宕机了

T:暂停状态
$$ 命令学习: kill -l // 显示kill相关的命令
//   18) SIGCONT	19) SIGSTOP
# kill  -19或-SIGSTOP   PID //暂停进程  Terminated   Stopped  //STAT:S+ --> T
# kill  -18或-SIGCONT   PID //继续进程  ,但会将进程转移到后台 //STAT:T  --> S //没有＋号了,说明进入后台运行
# kill  -9 或-SIGKILL   PID //杀死进程  Killed
//SIG : signal 信号 ,TERM terminate 终止
# killall 进程名 //杀掉相关进程的所有进程

※ # jobs -l //显示后台的任务和PID
// 运行中（Running）， 已停止（Stopped）, 已终止（Terminated）

$ 进程状态STAT带+说明是在前台运行,不带+说明是后台运行
在前台运行则可以通过前台终端命令控制,后台则一些终端命令如前台命令ctrl+C等无效,只能使用shell:kill -9 PID

T 和 S的区别:T往往是操作系统为了阻止某些不合法的任务或用户主动暂停.S是等待资源的阻塞状态
而t(tracing stop) 追踪式暂停:用户主动暂停,如gdb调试断点
$ 运行到断点暂停本质就是进程暂停
验证: gdb打断点,ps axj可以发现STAT为t

X(dead): 死亡状态 -- 瞬时状态,难以观察

$ linux中没有新建态,就绪态等.只有R,运行态,一新建就是R状态




$ main函数的返回值是进程退出码 -- 在操作系统/网络/测试用例等方面有作用


# echo $?  // 查看当前进程结束后的进程退出码 
//bash命令也是进程/程序,运行一个命令后也可以使用echo $?查看进程退出码

$ 如果一个进程推出了,立马X状态,立马退出,作为父进程或OS,有没有机会拿到退出结果呢? --拿不到
所以:linux进程退出时,一般进程不会立即彻底退出,而是要维持一个Z状态,也叫做僵尸状态,--方便后续父进程或OS读取该子进程退出的退出结果 -- 可以甄别退出的原因是什么
//进程具有独立性,子进程退出时无法把数据返回给父进程

演示: fork一个子进程,杀死子进程后提示defunct:失效的,死了的
[chj@expiration1102 2status 22:49:08]$ ps axj|head -1&&ps axj|grep out|grep -v grep
 PPID   PID  PGID   SID TTY      TPGID STAT   UID   TIME COMMAND
 2595  3736  3736  2595 pts/2     3736 S+    1002   0:00 ./out
 3736  3737  3736  2595 pts/2     3736 Z+    1002   0:00 [out] <defunct>

 //僵尸进程如果不回收,会一直占用资源.操作系统也要维护僵尸进程的PCB -->内存泄露

 ※shell命令
 # while :; do ps axj|head -1 && ps ajx|grep a.out|grep -v grep; echo '-------------------'; sleep 1;done

//正常写的程序作为父进程时,我们是看不到僵尸状态的,因为程序一结束就会被bash回收 -- 程序也是bash的子进程 -- 我们写的不对的fork子进程才能看到僵尸进程 -- 内存泄露

$ 1号进程是操作系统, init进程(1号进程)
如果子进程没结束,而父进程先结束了,则子进程的父进程会变为操作系统(1号进程)  
   -- 子进程会被OS自动领养(通过让一号进程成为新的父进程) -- 被领养的进程,叫做:孤儿进程 (Orphan Process)--- 认领和领养机制
   -- 如果不领养会发生什么? 后续子进程结束后,无人回收,-->内存泄露
   -- 所以没有父进程后则自动被OS领养,用于回收子进程




$$$$环境变量environment variables:由系统开机之后,帮我们维护的一些系统运行时的一些动态参数

环境变量一般是指在操作系统中用来指定操作系统运行环境的一些参数,
如：我们在编写C/C++代码的时候，在链接的时候，从来不知道我们的所链接的动态静态库在哪里，但是照样可以链接成功，生成可执行程序，原因就是有相关环境变量帮助编译器进行查找。
环境变量通常具有某些特殊用途，还有在系统当中通常具有全局特性

常见环境变量
PATH : 指定命令的搜索路径
HOME : 指定用户的主工作目录(即用户登陆到Linux系统中时,默认的目录)
SHELL : 当前Shell,它的值通常是/bin/bash。
USER : 当前用户

// echo PATH   //打印PATH
// echo $PATH  //读取PATH的内容 //  /usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/chj/.local/bin:/home/chj/bin
-- '$'符号可以读取文件内容,类似C语言的指针* 

$ 环境变量可以存放多个地址,以:作为分隔符,分隔出多个地址,读取顺序从左向右依次寻找

$ 为什么系统命令不用带./也能运行,而我们写的程序却需要./才能运行?
1.首先./是相对路径 --> 是一条明确的位置. 所有程序都需要有路径才能运行
2.执行程序时会先检查环境变量内路径所指的目录,在目录内找到就能执行,找不到就不能执行.显然,指令在其中,路径明确.而我们的程序不在.
所以,我们的程序必须指明路径.当然,命令也可以带路径


$ 在linux中,把可执行程序,拷贝到系统默认路径下,让我们可以直接访问的方式 == 相当于linux下的软件安装
-- rm掉则就是卸载

$ export PATH=$PATH:[newPATH]  -- 临时修改 PATH //重新登录后恢复
$ 永久修改所有用户vim /etc/profile
$ 永久修改某个用户vim ~/.bashrc


[chj@expiration1102 ~ 14:47:50]$ env  //查看环境变量
XDG_SESSION_ID=170
HOSTNAME=expiration1102  //主机名
TERM=xterm
SHELL=/bin/bash   //shell程序
HISTSIZE=1000     //历史命令存储上限
SSH_CLIENT=210.38.241.42 14847 22  //登录的主机
SSH_TTY=/dev/pts/4
USER=chj    //当前登录的用户 -- 切换成root后不变

# set  //查看更详细的环境变量

# unset 变量  //删除本地变量和环境变量
参数：
 -f 仅删除函数。 
 -v 仅删除变量。//默认


LD_LIBRARY_PATH=:/home/chj/.VimForCpp/vim/bundle/YCM.so/el7.x86_64 //动静态库learn...

//配色方案
LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=01;05;37;41:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.jpg=01;35:*.jpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.axv=01;35:*.anx=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=01;36:*.au=01;36:*.flac=01;36:*.mid=01;36:*.midi=01;36:*.mka=01;36:*.mp3=01;36:*.mpc=01;36:*.ogg=01;36:*.ra=01;36:*.wav=01;36:*.axa=01;36:*.oga=01;36:*.spx=01;36:*.xspf=01;36:

MAIL=/var/spool/mail/chj
PATH=/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/chj/.local/bin:/home/chj/bin //可执行程序的搜索路径
PWD=/home/chj  //当前用户所在路径
LANG=en_US.UTF-8  //当前编码
HISTCONTROL=ignoredups
SHLVL=1
HOME=/home/chj //当前所登录用户的家目录
LOGNAME=chj //当前的登录用户 -- 切换成root后不变
SSH_CONNECTION=210.38.241.42 14847 172.19.52.41 22
LESSOPEN=||/usr/bin/lesspipe.sh %s
XDG_RUNTIME_DIR=/run/user/1002
_=/usr/bin/env


$ main函数最多可以带三个参数
int main(int argc,char* argv[],char* envp[]){return 0};
//char* envp[] //envp是环境变量表, 存放C风格字符串的指针数组  -- 编译器会自动生成并传参进去  //envp:environment variables pointer
//envp的有效元素的下一位存放NULL(表结构).env是environment的缩写
//表结构遍历表不需要额外加判断,到最后一个是null或0自动不满足条件
//char* envp[] == char** envp

$ 指针和指针变量有区别.
指针是一个地址,凡是具有指向能力的数据都可以是指针.
指针变量是一个变量,变量在内存中占有4/8字节,具有数据存储和被修改的能力.保存指针数据的变量叫做指针变量

//1.通过一下代码可以验证envp是一张环境变量表
#include<stdio.h>
int main(int argc,char* argv[],char* envp[])
{
  for(int i = 0; envp[i];++i)
  {
    printf("envp[%d]->%s\n",i,envp[i]);       
  }
  return 0;
}

//2.同样可以通过以下代码获取环境变量表
#include<stdio.h>
#include<unistd.h>
int main()
{
  extern char** environ; //unistd内的指针变量:环境变量表,需要声明才可使用                                                 
  for(int i = 0; environ[i];++i)
  {
    printf("envp[%d]->%s\n",i,environ[i]);
  }
    return 0;
}

$ char *getenv(const char *name); //根据环境变量名获取环境变量
#include <stdlib.h>


$ 环境变量本质就是一个内存级的一张表,这张表由用户在登录系统时,操作系统自动给特定的用户形成属于自己的环境变量表
-- 环境变量的内容是从系统的相关配置文件中读取来的
用户环境变量位于~目录下的
-rw-r--r--   1 chj  chj    193 Oct 31  2018 .bash_profile
-rw-r--r--   1 chj  chj    434 Sep 11 22:33 .bashrc

全局环境变量位于/etc下的
-rw-r--r--.  1 root root     2853 Oct 31  2018 bashrc



$ 环境变量中的每一个都有自己的用途,有的是进行路径查找,有的是进行身份确认,有的是进行动态库查找,有的是用来进行确认当前路径等等.每个环境变量都有自己的特定的应用场景
每个元素都是kv的 -- <name ,内容>


linux中变量... 
[chj@expiration1102 ~ 20:35:28]$ myval=100
[chj@expiration1102 ~ 20:35:35]$ echo $myval //可以创建一个变量
100

这个变量如果是环境变量,则会尾插入在环境变量表.. 其他变量则尾插在其他表(如果存在). 还可能把一个动态开辟的表插进已有的表,再或者另开一个表维护...
内存级就是内存中shell正在维护的表..,数据是由系统的相关配置文件中读取而来.后面加入的变量是直接写在内存,没有写在文件,关闭内存可能就没了
这些表是由shell维护的
例如export可以直接导入到内存级的environmentVariablesTables

$ 环境变量能被所有的子进程继承,验证,export一个变量,然后getenv(),可以证明
环境变量可以被相关的子进程继承下去 -- 环境变量具有全局属性

//main函数是父进程调用...通过一些系统调用..

$ shell的本地变量,只在shell内部有效,不可以给子进程继承,可以通过export 本地变量//导入,就能被继承了

linux shell脚本执行命令时创建子进程问题（特定的情况，例如后台运行管道分支或子shell等，脚本可能会创建子进程执行命令）
Shell脚本在执行每个命令时，不一定会创建子进程。
在大多数情况下，每条命令都在主进程中依次执行，不会创建子进程。
但是，当遇到特定的情况，例如后台运行、管道、分支或子shell等，脚本可能会创建子进程。

//linux下一些奇怪的命令.如'.' , ']' , 

$ 命令行中输入的命令就是一个字符串,以空格为分隔符分隔的就是一个一个的子串
例结构: 可执行程序 -命令选项1 -命令选项2 -命令选项3 ...
         0号子串     1号        2号        3号      ... 
        
int main(int argc,char* argv[]){return 0};
argv[0] 就是 0号子串
argv[1] 就是 1号子串
argv[2] 就是 2号子串
...
argv是表结构,也是以NULL结尾.接收的就是命令行中的各个子串构成的表 -- 叫做命令行参数 -- 一般在linux才用得到,windows很少使用命令行
argc是表元素个数,有多少个子串,argc就为多少


command line parameter
argc: argument counter 
argv: argument value 




//优先级

优先级和权限:能or不能
优先级:已经能,但是谁先谁后的问题

为什么会有优先级? 资源太少,资源不足 -- 计算机中CPU资源有限

[chj@expiration1102 linux_code 22:45:04]$ ps -l
F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
0 S  1002 10249 10248  0  80   0 - 28920 do_wai pts/1    00:00:00 bash
0 T  1002 12326 10249  0  80   0 - 38008 do_sig pts/1    00:00:00 AppRun
0 R  1002 13810 10249  0  80   0 - 38336 -      pts/1    00:00:00 ps

[chj@expiration1102 ~ 10:22:25]$ ps -al
F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
0 R  1002 14684 14607  0  80   0 - 38328 -      pts/1    00:00:00 ps


//PRI:priority 优先级:即进程的优先级,就是程序被CPU执行的先后顺序,PRI越小进程的优先级越高.进程的PRI基本都是80,
//NI:nice  nice值:代表当前进程所对应的优先级的修正数据,nice值取值范围是-20至19,[-20,19],一共40个级别.一般nice值都是0
NICE:在LINUX系统中，Nice值的范围从-20到+19（不同系统的值范围是不一样的），正值表示低优先级，负值表示高优先级，值为零则表示不会调整该进程的优先级。具有最高优先级的程序，其nice值最低，所以在LINUX系统中，值-20使得一项任务变得非常重要；与之相反，如果任务的nice为+19，则表示它是一个高尚的、无私的任务，允许所有其他任务比自己享有宝贵的CPU时间的更大使用份额，这也就是nice的名称的来意。
https://www.jianshu.com/p/3c078505fffa
//UID(User Identify):user-ID,和用户名的标识,和用户名一对一对应,操作系统用UID标识用户

PRI(new) = 80 + nice ,NI[-20,19], PRI[60,99] //每次调整都是80开始

$ 虽然可以手动调整PRI,但是调度器...对PRI调整的尺度不会太大,尽可能公平. 我们基本也不会去调整优先级 -- 基本全是默认

调整有很多方法,有nice/renice命令,有setpriority(),有top
top方法:进入top,按r(renice),输入PID,输入nice值,回车即可修改

进程具有
1.竞争性:争夺有限的CPU资源
2.独立性:资源独享,多进程运行期间互不干扰,不受其他进程影响
3.并行:真正同时进行
4.并发:多个进程在一个CPU下采用进程切换的方式,在一段时间内让多个进程得以推进的现象 -- CPU疯狂调度,一个进程执行一段时间就被剥离CPU,让下一个进程使用.CPU很快,快到感觉不出来





进程的独立性:
进程 = 内核数据结构+代码和数据  

//父子进程即使是同一份代码,加载进来的数据也会共享,而是各自维护一份.
但是,观察使用同一份代码的父子进程的信息,发现对同一个变量的变量地址是相同的,但父子进程的变量值可以相同 -- 说明我们在语言层面用的地址不是物理地址
--- > 这个地址叫做线性地址或虚拟地址

类型是在应用层实现的,本质是偏移量,通过类型+数据的首地址可以确定一个数据

进程地址空间  -- 就是操作系统画的一张大饼--虚拟内存
//虚拟地址 == 线性地址
                             
                                        操作系统
                                          管理
进程PCB  ------------------------------- 进程地址空间  ------------------------------------- 内存

进程地址空间本质就是内核数据结构struct mm_struct{}  //memory manage struct

每个进程都有自己的地址空间，这意味着每个进程都有自己的内存地址范围，不会与其他进程冲突。

进程地址空间中的地址是虚拟地址,我们代码平常访问的地址就是虚拟地址
进程地址空间内区域划分就是对各种数据/对象结构体定义后对其赋值约束 -- 数据区,栈区,进程块大小...等等
---- 对线性区域进行指定star和end即完成区域的划分
进程地址空间会根据当前系统自动确定范围,32位则默认4GB,

进程地址空间通常被划分为几个部分：
代码段：存储程序代码的内存区域。
数据段：存储程序运行时所使用的数据的内存区域。
堆：动态分配内存的区域。
栈：存储函数调用时所需的数据(如参数、返回地址和临时变量)的区域。
struct mm_struct
{
    long code_start;
    long code_end;
    long init_start;
    long init_end;
    ...
    long brk_start; //堆
    long brk_end;
    long stack_start;
    long stack_end;
}

各种区域的限定区域内的地址就是虚拟地址/线性地址

修改各种区域的大小就是修改进程地址空间内的边界值  -- 简单理解

每个进程在执行时，都会使用自己的地址空间。进程间通信时，必须通过操作系统提供的机制来实现，因为不同进程之间的地址空间是独立的。

进程地址空间32位机器为4GB，64位机器为64GB或1TB：
//每个进程的进程地址空间都是这么大,但不代表进程享有这么多空间.进程使用空间也是需要申请的.会有物理内存不够时申请内存失败

代码中我们一般对变量取地址取的是首地址(低地址),而如何判断一个变量所占的空间和地址规划,则是由类型决定(软件层,本质是偏移量)

我们在用C/C++语言所看到的地址，全部都是虚拟地址！物理地址，用户一概看不到，由OS统一管理
程序的地址空间’是不准确的，准确的应该说成 进程地址空间

一个进程:
PCB -------------  进程地址空间 -------------  页表 ------------------  物理内存


父子进程 -- 子进程会建立一份基本和父进程一样的数据 -- 未发生写实拷贝时:
父:PCB ------- 进程地址空间 ----- 父页表  --- 物理内存 --- 子页表 ----- 进程地址空间 ------ 子PCB 
                                  虚1|实1                  实1|虚1                                               

如果子进程有数据发生修改,则发生写时拷贝:(不作修改时指向和父进程一样的物理地址,写的时候再拷贝一份到新空间另作修改,不会影响原数据) -- 体现进程独立性
父:PCB ------- 进程地址空间 ----- 父页表  --- 物理内存 --- 子页表 ----- 进程地址空间 ------ 子PCB 
                                  虚1|实1                  实2|虚1                                               

如果是父进程先发生修改,那则是父进程发生写时拷贝???? 不确定

fork在返回时,父子进程都有了,分别在父子进程中ruturn,父进程中return>0,子进程中return 0,总共return两次.谁先返回就是谁先发生写实拷贝


进程地址空间和物理内存之间通过页表和MMU(memory manage unit)进行映射和转化

页表是KV结构,K存虚拟地址,V存物理地址



虚拟地址空间是操作系统内部为进程创建出来的一种具体的数据结构对象,让进程有统一的视角去看待对应的物理内存,可以让进程管理和内存管理独立开来


虚拟地址空间是发展的产物 -- 初期是直接映射的
这样会存在安全问题,如果我们写的代码不正确,则有可能会直接修改到其他数据,-->会破环系统

$ 虚拟地址空间的作用
1.防止物理地址被随意访问,保护物理内存与其他进程
如果没有虚拟地址,那么会很不安全.有了之后呢,会带一层软件层去保护,识别,判断 -- 有读写检查,越界检查(区域),权限检查...
如不允许修改字符串常量,因为字符串常量的页表权限只读.
还有代码也是只读的--- 对应页表的权限全是只读

2.解耦合 进程管理和内存管理通过页表来沟通,
a.malloc向内存申请空间时,操作系统不会立即提供
b.操作系统一般不允许有任何的浪费或不高效
c.申请内存不一定立马使用 -- 浪费 -- 在申请成功后和使用前这一段时间不使用的话,那么这块空间是处于闲置状态的...
所以:操作系统只会在地址空间中申请一i快内存(此时物理地址处为空),等到真正使用时再分配真实内存空间(提供物理内存) -- 缺页中断 机制

3.可以让进程以统一的视角,看待自己的代码和数据
我们编写的代码在编译成可执行程序的时候,会按区域规则分好各个数据段了.在执行可执行程序,加载到内存时,会按一定规则将各数据段依次加载到内存.
即源代码在被编译的时候,就是按照虚拟地址空间的方式进行对代码和数据早就已经编号好了对应的编制 -- 如linux的ELF格式(百度查阅内部结构)
https://baike.baidu.com/item/ELF/7120560?fr=ge_ala

虚拟地址空间不仅会影响操作系统,还会让编译器遵守这样的规则

写时拷贝保证了父子进程的独立性 
写时拷贝是一种按需申请资源的策略 -- 与操作系统不允许浪费资源设定相符
一般只有数据可以发生写时拷贝,多进程时代码也可能发生写时拷贝

fork在网络/服务器中常用
fork失败原因有
1.内存不足
2.系统不允许用户创建太多进程
3.异常退出,如ctrl+c


# echo $?  //取得最近一次进程的退出码,取完就没了

进程退出情况分类 
a.正常退出(1.结果正确 2.结果不正确)  -- 提供进程退出码.供用户进行进程退出健康状态的判定 -- 可用可不用
b.奔溃了(进程异常)[操作系统信号 - 奔溃的原因: 进程因为某些原因,导致进程收到了来自操作系统的信号,如kill -9 ]

//打印c语言错误码表 char* strerror(int errnum);  //errnum：错误编号 errno。
 #include<stdio.h>
 #include<string.h>
 int main()
 {
   for(int i = 0; i<200 ; ++i) //不同平台码表不一样 --  一般不超过255个
   {
     printf("%d : %s\n",i,strerror(i));                         
   }
   return 0;
 }

 也可以自己定义退出码
 const char* err_string[]=
 {
    "success",
    "error",
    ...
 }

 进程退出方式
 1.return -- main函数中return才是进程退出 ---    进程执行其实是main执行流执行
 2.exit函数退出
 void exit(int status): <stdlib.h> -- exit可以在代码的任何地方结束进程 -- status是进程退出码,等价于main的return
 exit内封装了_exit(系统调用) -- void _exit(int status):<unistd.h>  --- _exit很直接,从系统内直接关闭进程,不会刷新缓冲区什么的 -- main

 exit和_exit区别:
 1.exit会先执行用户定义的清理函数,然后再冲刷缓冲,关闭流等,在向内核(kernel)申请关闭进程(_exit)
 2._exit是直接向内核申请关闭进程
 即exit的最后一步是调用_exit

 缓冲区不在操作系统内 -- 在用户层中(C/C++库)
    如果在系统内的话_exit也会刷新缓冲区


进程退出方式:信号+退出码方案 // 信号(异常)或退出码(正常退出结果对不对)



什么是进程等待?
 进程等待就是通过系统调用,获取 子进程退出码或退出信号 的方式,顺便释放内存问题 -- 获取子进程信息,然后释放子进程

进程等待的目的
1.避免内存泄露
2.获取子进程执行的结果(如果必要) -- 根据进程退出方式

如何进程等待?
系统调用wait/waitpid

 wait : wait for process to change state
声明: pid_t wait(int *status);
头文件 <sys/types.h> <sys/wait.h>
功能:父进程一直在等待子进程,子进程不退出,父进程也不会退出  -- 子进程一挂就能回收了
返回值:
wait(): on success, returns the process ID of  the  terminated  child;  on  error,  -1  is returned.
wait（）：成功时，返回被终止子进程的进程ID；出现错误时，返回-1。


waitpid:/
pid_t waitpid(pid_t pid, int *status, int options);

参数:
1.pid
如果pid>0,(是进程号) 则waitpid会一直等待该进程
如果pid == -1 , 则等待任何一个进程,等价于wait

2.status 状态码
int* status:输出型参数
32位位图结构 --
0000 0000 0000 0000 | 0000 0000 0000 0000
第16-31位不使用         
第8-15位:退出码(exit code):退出码:return或exit的status //打印退出信息的编号
第0-6位:退出信号(exit signal),终止信号:0为正常退出,即没有收到信号(只有信号为0时才看退出码,此时退出码为0的进程才是正确执行).如果退出码不为0,虽然正常执行,但是结果不对
          如果退出码不为0,则
第7位(core dump标志) ... 

3.options
a.WNOHANG:W(wait) NO(没有) HANG(夯住了:一般机器卡顿时,网络堵塞时我们称为夯住了) 
让进程立刻返回,不等待进程 
b.0:一直等待 -- 阻塞等待

在C语言中，你可以使用一些宏来处理进程退出码，其中最常见的宏是WIFEXITED，它用于检查进程是否正常终止，并且可以获取进程的退出码。
1.WIFEXITED(status):如果进程正常终止，WIFEXITED(status)将返回一个非零值，否则返回0。
     "W" 表示 "wait"，"IF" 表示 "if"，"EXITED" 表示 "exited"//表示 "如果进程已经退出"。
2.WEXITSTATUS(status): 这个宏用于获取正常终止的进程的退出码。如果WIFEXITED(status)返回非零值，你可以使用WEXITSTATUS(status)来获取进程的退出码。
    "W" 表示 "wait"，"EXITSTATUS" 表示 "exit status"。 表示 "等待并获取退出状态"。

3.WIFSIGNALED(status) - "W" 表示 "wait"，"IF" 表示 "if"，"SIGNALED" 表示 "signaled"。
    因此，WIFSIGNALED(status) 表示 "如果进程因信号终止"。这个宏用于检查进程是否因为接收到信号而终止。
4.WTERMSIG(status) - "W" 表示 "wait"，"TERMSIG" 表示 "termination signal"。
因此，WTERMSIG(status) 表示 "等待并获取终止信号"。这个宏用于获取导致进程终止的信号的编号。如果WIFSIGNALED(status)返回非零值，你可以使用WTERMSIG(status)来获取信号的编号。


返回值: -- 返回等待成功的子进程,>0  .失败返回-1 --  一般只有pid出错了才会失败
waitpid():  on  success,  returns  the process ID of the child whose state has changed; if WNOHANG was specified and one or more child(ren) specified by pid exist, 
but have not  yet changed state, then 0 is returned.  On error, -1 is returned.
成功时，返回状态已更改的子进程的进程ID；如果指定了WNOHANG(非阻塞轮询)并且存在由pid指定的一个或多个子进程（ren），
但尚未改变状态，则返回0。出现错误时，返回-1。


pid_ t waitpid(pid_t pid, int *status, int options);
返回值：
 当正常返回的时候waitpid返回收集到的子进程的进程ID；
 如果设置了选项WNOHANG,而调用中waitpid发现没有已退出的子进程可收集,则返回0；
 如果调用中出错,则返回-1,这时errno会被设置成相应的值以指示错误所在；
参数：
 pid：
 Pid=-1,等待任一个子进程。与wait等效。
 Pid>0.等待其进程ID与pid相等的子进程。
 status:
 WIFEXITED(status): 若为正常终止子进程返回的状态，则为真。（查看进程是否是正常退出）
 WEXITSTATUS(status): 若WIFEXITED非零，提取子进程退出码。（查看进程的退出码）
 options:
 WNOHANG: 若pid指定的子进程没有结束，则waitpid()函数返回0，不予以等待。若正常结束，则返回该子进
程的ID。


学习使用信号1~31号信号 -- 这些信号都是宏 #define SIGHUP 1  //信号也是一个数字
[chj@expiration1102 ~ 18:34:02]$ kill -l
 1) SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL	 5) SIGTRAP
 6) SIGABRT	 7) SIGBUS	 8) SIGFPE	 9) SIGKILL	10) SIGUSR1
11) SIGSEGV	12) SIGUSR2	13) SIGPIPE	14) SIGALRM	15) SIGTERM
16) SIGSTKFLT	17) SIGCHLD	18) SIGCONT	19) SIGSTOP	20) SIGTSTP
21) SIGTTIN	22) SIGTTOU	23) SIGURG	24) SIGXCPU	25) SIGXFSZ
26) SIGVTALRM	27) SIGPROF	28) SIGWINCH	29) SIGIO	30) SIGPWR
31) SIGSYS	34) SIGRTMIN	35) SIGRTMIN+1	36) SIGRTMIN+2	37) SIGRTMIN+3
38) SIGRTMIN+4	39) SIGRTMIN+5	40) SIGRTMIN+6	41) SIGRTMIN+7	42) SIGRTMIN+8
43) SIGRTMIN+9	44) SIGRTMIN+10	45) SIGRTMIN+11	46) SIGRTMIN+12	47) SIGRTMIN+13
48) SIGRTMIN+14	49) SIGRTMIN+15	50) SIGRTMAX-14	51) SIGRTMAX-13	52) SIGRTMAX-12
53) SIGRTMAX-11	54) SIGRTMAX-10	55) SIGRTMAX-9	56) SIGRTMAX-8	57) SIGRTMAX-7
58) SIGRTMAX-6	59) SIGRTMAX-5	60) SIGRTMAX-4	61) SIGRTMAX-3	62) SIGRTMAX-2
63) SIGRTMAX-1	64) SIGRTMAX	

没有0号信号
SIGFPE 8 为除零
SIGKILL 9 为主动杀死
11) SIGSEGV 为空指针异常/野指针

wait和waitpid如何拿到进程数据?   -- 父进程是如何拿到子进程的退出信息的
1.进程PCB内部有两个属性:int exit_code和int exit_signal 
其中main函数会把进程退出码写到exit_code中,操作系统会把信号/异常信息写到exit_signal中
2.通过系统调用wait和waitpid访问内核中的task_struct(PCB)取得数据并设置到输出型参数status中 -- 系统调用有权限访问内核

父进程在wait的时候,如果子进程没有退出,父进程在干什么? --- 只能一直调用wait/waitpid等待 -- 阻塞等待 -- 直到子进程完成后再唤醒父进程
子进程PCB内有task_struct *parent; // 通过它可以找到父进程
这过程父进程状态: R->S->R

非阻塞轮询:即wait不会一直等待进程,而是多次检查 -- waitpid(pid,status,WNOHANG)




$ 创建子进程的目的是什么? --- 让子进程帮我执行特定的任务
1.让子进程执行父进程的一部分代码 -- 但代码的归属权还是属于子进程
2.如果想要子进程指向一个全新的程序代码呢? -- 进程的程序替换 /为什么要有进程的程序替换

子进程
功能1:在原来的代码的基础上进行
功能2:执行不同的,全新的代码


$$$$$ shell 里的进程替换(Process Substitution)  

$ exec系列函数
SYNOPSIS/synopsis :概要
       #include <unistd.h>

       extern char **environ; //系统环境变量表指针

//加载器
       int execl(const char *path, const char *arg, ...);
       int execlp(const char *file, const char *arg, ...);
       int execle(const char *path, const char *arg, ..., char * const envp[]);
       int execv(const char *path, char *const argv[]);
       int execvp(const char *file, char *const argv[]);
       int execvpe(const char *file, char *const argv[], char *const envp[]);
       
       * int execve(const char *filename, char *const argv[], char *const envp[]);//系统调用 -- 其他6个都是封装了execve
       //没有execlpe

//使用注意,命令行参数必须要以NULL结尾


$ 命名理解
这些函数原型看起来很容易混,但只要掌握了规律就很好记。
l(list) : 表示参数采用列表
v(vector) : 参数用数组
p(path) : 有p自动搜索自己的环境变量PATH
e(env) : 表示自己维护环境变量 -- 不带e的就是使用系统环境变量

//执行程序流程:1.找到该程序(路径) 2.如何执行该程序(命令选项)

$ 只有execve是真正的系统调用,其它五个函数最终都调用 execve,所以execve在man手册 第2节,其它函数在man手册第3节。



exec的返回值:
RETURN VALUE
       The exec() functions return only if an error  has  occurred.   The return value is -1, and errno is set to indicate the error.
       exec（）函数仅在发生错误时返回。返回值为-1，并设置errno以指示错误

exec替换成功后不会有返回值,虽然声明带了返回值int,也没必要看了,因为查看返回值的代码都被替换掉了,有也看不到 -- 应该是有的,只是看不到了

exec失败:返回-1,并会继续执行后面的代码

子进程exec成功后,父进程可以通过退出码去检查exec后的代码执行的如何了


$ 接口解析 
# exec要么带v,要么带l 
 -- 只要有arg就一定要传 "程序名" , ... ,NULL ,数组也一样,结尾要带NULL
# 不带e的接口是会默认继承父进程的环境变量表的,即exec(...) 等价 exece(...,environ);

1.execl
参数path:是程序路径.绝对路径或相对路径都可以. arg是命令行参数,和main的命令行参数一样,按命令拆分成字符串的格式一样,一个一个传进去,最后以NULL结尾
2.execv
参数path和execl一样,只是arg换成了argv,即一个一个传的参数换成了传字符串数组,数组元素就是execl的arg序列,最后以NULL结束
3.execlp
参数arg和execl一样,一个一个传命令子串. 参数file是程序名称,而程序路径由系统自动从环境变量中查找
4.execvp
5.execle
参数envp是自定义环境变量 -- 一般用于在子进程不想使用父进程的环境变量的时候 --
自定义环境变量表 -- 自定义环境变量会覆盖式(清空原来的环境变量)写入
# putenv 将自己的环境变量加到系统的环境变量中
    头文件:#include<stdlib.h>
DESCRIPTION
       The  putenv()  function  adds  or changes the value of environment variables.The argument string is of the form name=value.
       If  name  does  not  already exist  in  the environment, then string is added to the environment.  
       If name does exist, then the value of name in the environment is  changed  to  value.
       The  string pointed to by string becomes part of the environment, so alteringthe string changes the environment.
说明
        函数的作用是添加或更改环境变量的值。参数字符串的格式为name=value。
        如果名称在环境中不存在，则字符串将添加到环境中。
        如果name确实存在，则环境中name的值将更改为value。
        字符串指向的字符串成为环境的一部分，因此更改字符串会更改环境。

## 操作系统能通过带e的exec把环境变量传给子进程 -- 子进程就获得了自己的环境变量

任何一个子进程都是fork后再exece执行的    验证: bash中export一个变量,fork并execle得到孙子进程,验证孙子进程的环境变量已继承bash的环境变量 

$ exec是系统调用 -- 只要是进程都能调用.所有程序最后都是进程,所有任何语言都可以


$ 创建进程时,先创建PCB再把数据从磁盘加载到内存 -->创建子进程时,先创建PCB,再exec加载进内存...
    即父进程先调用exec,再去调用了其他程序的main...

$ 程序替换只会影响当前调用的进程:谁调了exec就替换谁 --- 进程的独立性 --> 子进程则会发生写时拷贝(代码区),不影响父进程
       --- 在单进程时代码区一般不可修改 ,多进程时为了进程的独立性需要对代码区作修改


C++源文件可以使用“.c++”，“.cc”，“.cxx”作为后缀名

$ 程序替换:老进程使用了全新的程序(没有创建新的进程) - 原来的代码被用新的代码替换掉了 --- 内存代码段中旧代码被新代码覆盖了,不再执行旧代码
只在必要时就该页表的映射关系,而内核数据结构并不做任何的修改



$$$$ 简易shell

不是所有命令都让子进程去执行,需要自己做的命令被称为内建命令


内建/内置命令:让bash自己执行的命令  -- 如cd这样的,不应该让子进程跑的,如果给子进程执行,则是子进程改了目录,而bash没改目录.没有意义
{
int chdir(const char *path); -- 系统调用:用于改变调用该接口的进程的工作路径 
头文件:#include <unistd.h>
参数path:要更改的路径

# type 命令 // 说明某条命令是内建命令还是外部程序




$ 一般用户自定义的环境变量,在bash中要用户自己来维护,不要用一个经常被覆盖的缓冲区来保存环境变量
     如argv,如果环境变量保存在argv,因为argv经常要用来存放解析后的命令子串,维护不当有可能会覆盖掉环境变量,导致环境变量失效 
     --- 解决方法可以将argv解析出的环境变量转移到其他变量保存
//几乎所有的环境变量命令都是内建命令         
//只要维护好了bash自己的环境变量,子进程会自动继承父进程的环境变量





}



$$$$$$$文件

$ linux中,文件被打开,OS会对被打开的文件进行管理,即要创建对应的内核数据结构  ---   和进程类似  

$ 文件可以被分成两大类  1.磁盘文件(文件系统)  2.被打开的文件(文件操作)

//文件可以同时被多个进程打开

# du -b/k/m 文件   //显示文件大小
# du -h 文件/目录/路径/通配符  //自动单位 
//linux以4kb为单位的,空文件内存为0,不足4k的文件显示为4kb


$ c语言文件模式/权限
{
 r      Open text file for reading.  The stream is positioned at the beginning of the file.

 r+     Open  for reading and writing.  The stream is positioned at the beginning of the file. 
 // r+和w+都是读写方式打开,区别是r+不创建文件

 w      Truncate file to zero length or  create  text  file  for writing.   The  stream is positioned at the beginning of the file.

 w+     Open for reading and writing.  The file is created if it does  not  exist, otherwise it is truncated.  The stream is positioned at the beginning of the file.

 a      Open for appending (writing at end of file).   The  file is  created  if  it does not exist.  The stream is posi? tioned at the end of the file.

 a+     Open for reading and appending (writing at end of file). The  file  is created if it does not exist. The initial file position for reading is at  the  beginning  of  the file,  but  output  is always appended to the end of the file.
}


linux文件系统调用


打开文件open
声明:
    int open(const char *pathname, int flags);
    int open(const char *pathname, int flags, mode_t mode);

头文件:
       #include <sys/types.h>
       #include <sys/stat.h>
       #include <fcntl.h>

RETURN VALUE(fd:file descriptor)
       open()  and creat() return the new file descriptor, or -1 if an error occurred (in which case, errno is set appropriately).

int open(const char *pathname, int flags, mode_t mode);		
功能：打开或创建文件
pathname：文件路径
flag：打开文件时的权限
	O_RDONLY	只读 ReaD only
​	O_WRONLY	只写 WRite only
	O_RDWR		读写 ReaD WRite
​	O_CREAT		文件不存在时则创建 create
​	// O_EXCL			配合创建使用，文件存在时出错 //待学
​	O_TRUNC		清空 truncate //默认不清空
​	O_APPEND	追加 append //追加和清空逻辑互斥,正常不会同时出现
mode：创建文件时的权限	mmm	与chmod的权限设置方式一致
返回值：
	文件描述符
​	失败返回-1
————————————————
https://blog.csdn.net/weixin_51420051/article/details/110937524


// close目前仅掌握使用方法....


OS接口传递标记位的方式 -- 位图
{
int flags; --> int有32个比特位,每一个比特位对应一个标记位,一个int可以同时传32个比特位,足够使用

}


linux关闭文件接口close
声明:
    int close(int fd);
头文件:
       #include <unistd.h>
返回值:

       
自定义掩码umask
声明:
    mode_t umask(mode_t mask);
头文件:
       #include <sys/types.h>
       #include <sys/stat.h>
RETURN VALUE
       This system call always succeeds and the previous value of the mask is returned.
返回值:此系统调用始终成功，并返回掩码的上一个值。    

使用:用户设置的umask优先于系统默认的umask --- 就近原则
umask(0000) // 注意:0开头是八进制数字


$ write //linux写入接口
声明:
    ssize_t write(int fd, const void *buf, size_t count);
头文件:
        #include <unistd.h>
返回值:
        返回实际写入字节数,0为没有写入任何字节,失败返回-1
描述:
    count是一次最多写入的字节数


$ snprintf //把缓冲区写入到字符串接口
声明:
        int sprintf(char *str, const char *format, ...);
Return value
    Upon  successful return, these functions return the number of characters printed (excluding the null byte used to end output to strings).
返回值
    成功返回后，这些函数将返回打印的字符数（不包括用于结束字符串输出的空字节）。


$ read() //linux从文件读入接口
声明:
    ssize_t read(int fd, void *buf, size_t count); 
头文件:
    #include<unistd.h>
返回值:
    返回实际读入的字节数
描述:
    count是一次最多读取的字节数,返回值是读到的字节数





$$$$ 文件描述符fd -- file_descriptor

生命周期:随进程结束而关闭

$ 任何一个进程在启动时,默认会打开当前进程的三个文件:
         标准输入,     标准输出,      标准错误      ---- 本质都是文件
C语言:    stdin         stdout         stderr       ---- 文件在语言层的表现 FILE *stdin;FILE *stdout;FILE *stderr
C++  :     cin           cout           cerr        ---- 同上,不过是一个类
         键盘文件      显示器文件     显示器文件    ---- 设备文件
fd码 :     0              1              2          ---- 文件描述符descriptor

//通过a.out > log.txt 发现:标准错误不会进入文件,而是直接到显示器
$ 标准输出和标准错误都会向显示器打印,但其实不一样

$ 由于进程的三个文件会自动打开,所以不需要我们手动打开,可以直接调用输入输出

$ 我们打开的文件的文件描述符fd为什么最小是3? 因为进程启动时默任启动了3个标准文件,分别是0,1,2. 所以fd只能是3开始.
    而后续打开的文件的fd可以是依次递增的:3,4,5,6,7,8... ------------------数组下标(open的返回值)
    也可以不是递增的,如果中途关闭某个文件,那这个文件的位置就会被回收,下一个新打开的文件就是使用该下表 
-- 进程中,文件描述符的分配规则:在文件描述符中,最小的,没有被使用的数组元素,分配给新文件
// 验证:如果把0或1或2号关闭了再分配,会发现不是std而是新文件了


$$ 进程与文件

$ 内存中文件描述与组织
1.文件也和进程一样,OS会对每一个打开的文件进行管理,在内存中构建struct file结点,该结点存放了文件的元数据,文件的操作方法及缓冲区等,并组织成结点为struct file的数据结构.
2.一个进程可以打开多个文件,每一个进程与文件都是是1:n的关系,所有文件的struct都在OS所管理的文件内核数据结构中.

$ 进程管理自己打开的文件的方式
3.OS为进程定义了一个struct file_struct结构体结点. 能够维护进程与由该进程打开的文件的映射关系,快速为进程找到自己打开的文件, 
4.该结构体内定义了一个数组,类型为struct file *fd_array[],内存放了进程自己打开的文件的struct file.通过遍历数组就能找到对应的文件.
默认前3个存放了标准文件,即下标0,1,2分别存放标准输入,标准输出,标准错误stdin,stdout,stderr
5.进程控制块task_struct中定义了struct files_struct *files指针变量,该指针变量files指向了struct files_struct结构体 ===  进程 - files_struct - fd_array - 文件
7.对新打开的文件OS会遍历数组,找到空位后插入,并返回下表 --- 哈希表,映射表
8.要找到对应的文件,只需要通过对应下标元素就能得到文件结构体的地址

10.实现了进程管理与文件系统的解耦合,只通过指针和文件描述符耦合,联系.没有深度联系 -- 用地址方式轻耦合,用数组下表进行快速索引

9.每个文件都有一个缓冲区,这个缓冲区位于file结点内,而所谓的IO类read,write函数,本质是拷贝函数,--- 用户空间和内核空间进行数据的来回拷贝,
write用于把内容拷贝到文件缓冲区.至于什么时候从文件缓冲区写入到磁盘指定位置(缓冲区刷新)则由操作系统决定 -- 不同操作系统对应不同的刷新策略
read是把内容从磁盘拷贝到文件缓冲区中,等需要时再拷贝到我们指定的缓冲区

11.一个文件只会被打开一次,即只有一个文件结构体,其他进程打开这个文件不会再构建文件结构体
    文件结构体内部有对应的引用计数,记录了多少个进程打开该文件


$$$$ 理解linux下一切皆文件
-------------------------------------------------------------------------------------------------------------


我们使用操作系统都是通过进程的方式进行的 -- 如QQ,微信,浏览器等等各种程序都是进程-- 进程的视角就是用户的视角 -- 人类访问计算机都是以进程为载体进行访问的
而进程只能看到文件,所以一切皆文件


                     task_struct  -> (*files) ->  files_struct                                                       
                                                                           
                     files_struct  -->  _____                                                      
                                       | ....                                                      
进程      --                           | ...                                                      
                                       | file* -|0| _                       <-- stdin
                                       | file*  |1|  |                      <-- stdout
                                       | file*  |2| - - file* fd_array[]    <-- stderr                    
               |---------------------- | ...   -|n|                         <-- 其他文件                               
               |                       |_____       ------------------|             
               |                                                      |                                      
              \|/                                                    \|/                                      
--------------------------------------------------------------------------------------------------------------                                                                                                   
                                                                                                               
              struct file                                         struct file                                      
             {                                                  {                                                                   
              //文件权限                                         //文件权限                                                      
              //文件的大小                                       //文件的大小                                                    
              // ...                                             // ...                                                          
              //当前文件对象自己的缓冲区                         //当前文件对象自己的缓冲区                                                                                                          
文件对象  --                                                                                                                                                                                         
              int (*readp)(int fd,char buffer[],int size);       int (*readp)(int fd,char buffer[],int size);                                                                         
              int (*writep)(int fd,char buffer[],int size);      int (*writep)(int fd,char buffer[],int size);                                                                       
              //其他函数指针 ...                                 //其他函数指针 ...                                                                                                                  
             }                                                  }                                                         ...                                                                                 
              通过函数指针,再面对底层不一样的驱动程序时只需要调用对应底层的方法就可以了,不需要关心底层实现的差异化
              操作系统只需要把上层的数据拷贝到缓冲区里,再调用底层不同设备对应的读写方法就可以把数据放到不同的外设里 ----- 因此从linux上层看,以下一切皆文件
              无论底层再怎么差异化,linux通过函数指针的方式屏蔽了他们的差异
              
              --- C语言设计面向对象的方法
-------------------------------------------------------------------------------------------------------------
                    ...(其他接口)
驱动程序  --        read_keyboard();                                 read_screen();(空)                                    read_netcard();  
                    write_keboard();(空)                             write_screen();                                       write_netcard();
-------------------------------------------------------------------------------------------------------------
外设      --            键盘                                           显示器                                                  网卡                       ....





---------
$ 操作系统层面,必须要通过fd才能找到文件

$ 任何语言IO一定会使用write和read,而使用WR和RD一定要由fd,所以一定会封装了fd. 如C语言的FILE结构体就封装了fd(_fileno). --> C++的cin,cout等也一定封装了fd
 
 //C语言静态库后缀名一般为.so ,动态库一般为 .a 
 //C语言动静态库路径 /lib64 或/usr/lib64
 //C语言头文件路径   /usr/include



 作业1:模拟输出,输入,追加重定向
 1.分别关闭stdin ,stdout,stderr

 $ 输出重定向和追加重定向都是往1号文件输入
   close(1);
   int fd =  open(LOG,O_WRONLY|O_CREAT|O_APPEND,0666);    //追加重定向
   int fd =  open(LOG,O_WRONLY|O_CREAT|O_TRUNC,0666);     //输出重定向

 作业2:观察1和2号fd,使用a.out > file

 $ 标准输出和标准输入不一样.输出的文件不一样,out是1号文件,err是2号文件
 //输出重定向只改1号重定向,不改2号重定向

 作业3:将输出到stdout的数据重定向到文件1,将输出到stderr的数据重定向到文件2

 $ stdout和stderr作用不同,目的是将正常信息和错误信息分开 -- 方便错误调试,如果混在一起,看起来很麻烦


 总结:
 重定向的完整写法:
 输出重定向# command n>file  //n是下表,是fd.  1可以省略,默认不带数字就是1.    n>1后就不能省略
 输入重定向# command<n file   //n默认是0(stdin) ,默认省略.                    n>0后就不能省略

 特殊: 2>&1  //2重定向成1 -- 理解成文件名是地址,1不是地址,需要取地址 //把1中的内容写到2里

 //代码角度 从右往左识别


 #include <unistd.h>

int dup2(int oldfd, int newfd);

oldfd 是要复制的原文件描述符。
newfd 是要将原文件描述符复制到的目标文件描述符。
dup2() 的基本工作原理如下：

1.如果 newfd 已经打开，则 dup2() 会先关闭 newfd。
2.然后，dup2() 会将 oldfd 复制到 newfd，使得它们指向相同的文件描述符表项。这意味着它们将共享相同的文件状态信息，包括文件偏移和文件状态标志（例如，读写模式）。
3.如果 newfd 和 oldfd 的值相同，dup2() 会直接返回 newfd，并且不会关闭它。


官方原话:
makes newfd be the copy of oldfd, closing newfd first if necessary, but note the following:

*  If oldfd is not a valid file descriptor, then the call fails, and newfd  is not closed.
*  If oldfd is a valid file descriptor, and newfd has the same value as oldfd,  then dup2() does nothing, and returns newfd.

使newfd成为oldfd的副本，必要时先关闭newfd，但请注意以下内容：

*如果oldfd不是有效的文件描述符，那么调用将失败，并且newfd不会关闭。
*如果oldfd是一个有效的文件描述符，而newfd的值与oldfd相同，则dup2（）不执行任何操作，并返回newfd。



$$$$ 缓冲区

缓冲区结构
                 内存                           外存(没有加载进内存的)
语言缓冲区 -- 文件缓冲区(包括外设文件,如显示器) -- 磁盘


$ 三种语言级缓冲策略
1.无缓冲 //来一个刷新一个    -- 
2.行缓冲 //遇到换行符就刷新  -- 输出的文件是显示器文件时刷新策略是行缓冲
3.全缓冲 //写满缓冲区再刷新  -- 输出的对象是普通文件时刷新策略是全缓冲

为什么要有缓冲区? 
    因为系统调用需要时间,时间成本较高,使用缓冲区策略能节省调用者时间 --- 减少刷新次数,减少调用系统接口次数

C库的缓冲区在FILE结构体中,每次打开文件都会生成 -- FILE结构很复杂

系统调用write没有缓冲区,直接写给操作系统指定的输出对象(文件)了 
-- 至于什么时候从文件缓冲区写到内存,属于操作系统的策略



用户强制从系统刷新到磁盘 -- synchronize a file's in-core state with storage device -- 将处于核心状态的文件与存储设备同步
声明 int fsync(int fd);
头文件#include <unistd.h>

printf函数输出的实际是一个一个的字符,并不是千百十量级的打印 -- 就像人写字一样,也是一个一个字的写
--- printf实际是 格式控制 功能的函数,将不同类型的数据转换成一个一个字符




$$$$ 磁盘文件

打开的文件
1.管理文件 -- 先描述再组织 -- struct file
2.进程的关联问题 -- 文件描述符
3.文件的读写问题 -- 语言级别和内核级别的缓冲区
4.刷新问题 -- 刷新策略

没打开的文件
5.文件如何合理存储问题 -- 
合理存储能够 a.快速定位 b.快速读取和写入 
-- 
如何标识文件:a.文件名 

...













--------------------------------------------------------------------------------------------------
磁盘的物理结构
1.了解磁盘结构
 磁盘(机械硬盘...)是我们计算机上唯一的机械设备 -- 磁盘与固态硬盘物理结构不一样,磁盘是机械结构,ssd是电子结构

 扇区(sector): 将磁道划分为若干个小的区段, 就是扇区. 虽然很小, 但实际是一个扇子的形状, 故称为扇区. 每个扇区的一般大小为512字节.


磁盘结构: https://www.cnblogs.com/lsgxeva/p/15641934.html
柱面(磁道)磁头扇区CHS定位法

C:cylinder 柱面
H:head     磁头
S:sector   扇区



2.逻辑抽象
OS不能直接和使用硬件,要和磁盘做好解耦工作 -- 因为OS是软件,而硬件会更新换代,一旦硬件发生变化,没有解耦的操作系统则将不能正常使用...
a.设磁盘扇区为512字节(固定),这是很小的基本IO数据量.而OS实际进行IO是4KB(可以调整)
--- 基本单位是OS与外设交互时的一次读写大小,无论需要的数据多小,1B也要读4KB --- 即一块 -- 所以磁盘设备一般称为块设备
--- 文件系统读取时按一块进行进行读取
--- OS按块读取数据能减少IO次数 ,能解耦合...
-- OS需要一套新的地址(独立一套) 来进行块设备的访问 

引入:计算机领域中一种耦合与解耦合的解决思想: 在软件和软件或软件和硬件中增加一层新的软件层就可以提出新的解决方案
软件学科有一条公理:在任何的软件中,没有解决方案时,可以增加一层软件层来增加解决方案.

$$ 定位扇区的方式:LBA 定位扇区方式:
{
磁道 - 扇区 展开图(将一条磁道断开成一条直线,然后依次连接后面的磁道)
        [0][1][2][3][][][][][][][][][][][][][] ...         [0][1][2][3][4][5][][][][][][][][][][][][][]
磁道0:/  数组下标 -- 逻辑抽象                       磁道1;/     

逻辑块地址(Logical Block Address, LBA)是描述计算机存储设备上数据所在区块的通用机制，一般用在像硬盘这样的辅助记忆设备。
LBA可以意指某个数据区块的地址或是某个地址所指向的数据区块。现今计算机上所谓一个逻辑区块通常是512或1024位组。

一个LBA地址就对应一块扇区 -- LBA+连续读取8个扇区就得到一个块

}

OS把LBA地址的块当作一种类型,和语言类型一样,首地址+偏移量方式得到下一块 -- 一块=n个扇区

$$ 磁盘与OS互相转换  LBA < -- > CHS
H=heads per cylinder，每个磁柱的磁头数 -- 默认为1,忽略
S=sectors per track，每磁道的扇区数
#c=   lba / ( S*H )
#h= ( lba/S ) % H
#s= ( lba%S ) + 1

LBA -> CHS : 设一个盘面有5000个扇区,设一个磁道有1000个扇区.而有其中一个LBA是6500,求CHS
H(先确定在哪一面,即确定哪个磁头): int h = 6500/5000 = 1 ; 所以在第2个磁头,自低向上第二面上.即1号盘面
C(求第几柱面,即第几个磁道): int c = 6500/1000= 6 ;  // 6号磁道,第7个磁道 //自底向上的所有盘面的所有磁道都连在一起
S: int s = 6500%1000 = 500 ; //一个磁道的第500号扇区



CHS -> LBA：
H=heads per cylinder，每个磁柱的磁头数 -- 默认为1,忽略
S=sectors per track，每磁道的扇区数
 lba = ( c*H + h )*S +  s - 1
 lba = ( c+h )*S + s - 1
  
总结:OS对磁盘管理转化成了对数组的管理 -- 先描述再组织  -- struct block{};


3.文件系统
文件系统分为两套:磁盘上的和内存中的. 我们编程一般指内存中的.

$$ 分区分组管理

对磁盘分区 struct disk{struct part[5]; //...};
分区大小   struct part{int lba_start; int lba_end; //... }; //part:区域
对区分组   struct part{struct part group[100]; //... };     //两个struct part一样的,取其内容

一个磁盘可以分成几个区,每个区可以分成多个组Block group 0,1,2,...

Boot_block
1.每个区开头会有一点区域Boot_Block用于保存操作系统启动相关的内容.如分区表,操作系统的镜像地址等,一般位于0号盘面的0号磁道的1号扇区开始保存着,在C盘的某个区域.
2.一般开机至少要做两件事情,第一步先找到磁盘设备并加载磁盘的驱动程序,第二步是加载的分区表(识别出C,D,E盘...),
    然后再从特定分区的开始位置读取到操作系统对应的镜像的地址,然后找到操作系统在磁盘的位置,然后加载操作系统
3.一般如果因为一些原因而导致了Boot_Block的数据丢失,如数据刮花了,数据没了,那么操作系统就不能启动了
4.除了Boot_Block这个区域是与开机相关外,其他区域都是与数据相关
5.Boot_Block也可能有备份 -- 看文件系统 -- 但规定开机只找0号盘面0号柱面1号扇区

文件 = 内容+属性
linux中文件和内容是分离的 -- linux把文件内容和文件属性分离
文件的内容和属性都要以块的形式,被保存在磁盘的某个位置

在一个分组中,主要字段分为6个
1.超级块 SuperBlock(SB)
2.组描述符表 GroupDscriptorTable(GDT)
3.块位图 BlockBitmap
4.索引节点位图 inodeBitmap
5.索引节点表 inodeTable
6.数据块 Data blocks

$ SuperBlock(价值上很重要):保存了整个分区文件系统的所有属性信息,有
1.文件系统的类型
2.整个分区的情况:如一共分了多少组,每一个的使用率是多少,可用空间,文件系统其他信息等...
//EXT是延伸文件系统（英语：Extended file system，缩写为 ext或 ext1），也译为扩展文件系统，一种文件系统，于1992年4月发表，是为linux核心所做的第一个文件系统。
    采用Unix文件系统（UFS）的元数据结构，以克服MINIX文件系统性能不佳的问题。它是在linux上，第一个利用虚拟文件系统实现出的文件系统，在linux核心0.96c版中首次加入支持，最大可支持2GB的文件系统
$ 每一个组都可能存在一个和其他SuperBlock完全相同SuperBlock,且会统一更新 -- SB区域损坏后整个分区不可被使用,因此需要做好备份 -- 多副本保证分区安全策略
//为什么其他块不做多副本? 因为数据价值大!如果是boot_block损坏只是单纯开不了机,而数据还在,可以恢复.而如果SB坏了,那整个分区就无法恢复了.其他字段影响范围有限,可以承担

超级块（Super Block）：存放文件系统本身的结构信息。记录的信息主要有：bolck 和 inode的总量，
未使用的block和inode的数量，一个block和inode的大小，最近一次挂载的时间，最近一次写入数据的
时间，最近一次检验磁盘的时间等其他文件系统的相关信息。Super Block的信息被破坏，可以说整个
文件系统结构就被破坏了

$ GDT:类似SB,保存了自己所在组的详细的统计属性信息,还有各字段的分布情况,区域位置... 

$ inodeTable:
一般而言,一个文件,内部所有属性的集合,称之为inode/节点,大小一般是128字节 --- 一个文件对应一个inode.
每个区都都有很多文件,所以每个group都需要有专门保存所有文件的inode的区域  --- inode表inodeTable  ----------------- 
inode表可以看作一个数组,每个元素都是128字节
每一个inode都有自己的编号 --- 区分
文件的属性是基本相同的,因此固定大小

$$ inode也会消耗硬盘空间，所以硬盘格式化的时候，操作系统自动将硬盘分成两个区域。
一个是数据区，存放文件数据；另一个是inode区（inode table），存放inode所包含的信息。
每个inode节点的大小，一般是128字节或256字节。inode节点的总数，在格式化时就给定，一般是每1KB或每2KB就设置一个inode。
假定在一块1GB的硬盘中，每个inode节点的大小为128字节，每1KB就设置一个inode，那么inode table的大小就会达到128MB，占整块硬盘的12.8%。
查看每个硬盘分区的inode总数和已经使用的数量，可以使用df命令。

$$ 每个inode都有一个号码，操作系统用inode号码来识别不同的文件。 -- inode_number
这里值得重复一遍，Unix/Linux系统内部不使用文件名，而使用inode号码来识别文件。对于系统来说，文件名只是inode号码便于识别的别称或者绰号。
表面上，用户通过文件名，打开文件。实际上，系统内部这个过程分成三步：
    首先，系统找到这个文件名对应的inode号码；其次，通过inode号码，获取inode信息；最后，根据inode信息，找到文件数据所在的block，读出数据。

$$ Unix/Linux系统中，目录（directory）也是一种文件。打开目录，实际上就是打开目录文件。
目录文件的结构非常简单，就是一系列目录项（dirent）的列表。每个目录项，由两部分组成：所包含文件的文件名，以及该文件名对应的inode号码。

$ Data Block
文件的内容是变化的,因此使用数据块来进行文件内容保存,一个文件的内容需要有[1,n]个数据块来保存 --- 即便只有1个字符也要占用1个块
因为有多个文件,因此有了存放文件内容的区域Data Block -- 单位大小4KB,OS中与外设交互的子系统是文件系统

//linux查找1个文件,是根据inode编号来进行文件查找的,包括读取内容
//struct inode{ int blocks[NUM]; //... }; // blocks中存放了inode对应的所有数据块的编号 -- inode和data_block的映射关系

//每个group中基本都是数据块,只有极小部分是inode等其他信息 -- 因此OS启动时会直接把inode等全部加载进内存,而数据块只在需要时在加载进内存

$ inodeBitmap:每个bit表示一个inode是否空闲可用,下标为inode编号,值为1表示在工作,为2表示不在工作

$ blockBitmap:每个bit表示一个DateBlock是否空闲可用

# ls -i  // 命令选项-i能查看inode

$ inode VS 文件名
linux系统只认inode号,文件的inode属性中不存在文件名! 文件名是给用户使用的
$ 目录是文件,目录也有inode.目录也有内容,所以目录也有数据块
$ 任何一个文件,一定在目录内部,所以目录的内容是什么呢? 目录的数据块里保存了 该目录下文件名和文件inode编号对应的映射关系.在目录内,文件名和inode互为key值

$ 加载一个文件:
1.现在当前目录下找到该文件的inode编号(通过文件名映射关系).
2.一个目录也是一个文件,也一定隶属于一个分区,结合inode编号,在该分区的inodeTable找到该inode编号对应的inode结构体
3.通过该inode结构体对应的datablock的映射关系,找到该文件的数据块,然后加载到内存

$ 查找一个文件:读取该目录的内容
$ 删除一个文件:查找inode再根据inode...把block bitmap和inode bitmap对应的比特位 置为0即可,不需要清空 -- 只需要修改位图
$ 增加一个文件:从低到高扫描目录所在组的inodebitmap,找到为0的比特位(后置为1)就是新的inode,再把属性填到inodeTable,然后在目录文件的内容中追加入新的文件名和inode映射关系即可.

//linux维护有删除文件的日志,会维持一段时间 -- 数据恢复
$ 回收站就是一个目录,从回收站删除才是修改位图

$ inode在一个分区内有效,不能跨分区,因为通常一个分区是一套文件系统.
$ inode能确定分组,在一个分区内,不同的组享有不同范围的inode,整个区的inode编号是唯一的,区内不同组享有不同区间的inode编号
    每个组的inode_bitmap的编号是从0开始的,真正的inode编号是 组起始位置的inode编号+位图中的编号

//格式化:OS向分区写入文件系统的管理属性信息 //linux命令 # mkfs.ext(2/3/4)

$ 多级索引 -- linux采用的索引方式
inode表 --- 数据块
前k1个inode采用直接映射方式对应数据块
k2个inode为二级索引,间接寻址方式,间址,第一次直接指向的不是存放目标文件数据的数据块,而是存放其他数据块的编号,通过这些编号,可以1对多找到多个数据块 -- 扩展了容量 -- 两层/三层的多叉树
k3个inode为三级索引,需要间址三次...
...

$ 存在inode消耗完,还剩datablock的情况 -- 创建大量空文件而不写数据 //”no space left on device”
$ 存在inode剩余,datablock消耗完的情况 -- 创建一个文件,写入大量数据
// 两种情况都不能解决

$$ 文件系统的属性虽然是在磁盘中,但发生修改时,根据冯诺依曼体系,它们只能在内存中被修改,操作完成后再统一刷新回磁盘中


联系与总结: 文件描述符fd -- inode表 -n- inode属性 -1-  DataBlok -- 多级索引

4.软硬链接

建立软链接:# ln -s 路径 软链接名 //不加软链接名则软连接名默认是最后一个/的文件/目录名
lrwxrwxrwx  softLinkFile -> file  // l开头是链接文件

软连接是一个独立的链接文件,有自己的inode 编号,有自己的inode属性和内容
软链接文件内容放的是自己所指向的文件的路径
//删除软连接的目标文件后软连接会闪红
作用:快捷方式
$ 软连接路径是绝对路径则是全局 /是相对路径则不能移动到其他目录
# readlink 软链接 //显示软链接的路径

建立硬链接:# ln 旧名 新名 
硬链接和目标文件共用同一个inode编号,硬链接和目标文件使用同一个inode,没有独立的inode
硬链接内建立了 新文件名和老inode的映射关系
//建立硬链接后,直到硬链接数为0才能彻底删除该文件

$ 作用:
1.节省硬盘空间。同样的文件，只需要维护硬连接关系，不需要进行多重的拷贝，这样可以节省硬盘空间。
2.重命名文件。重命名文件并不需要打开该文件，只需改动某个目录项的内容即可。
3.删除文件。删除文件只需将相应的目录项删除，该文件的链接数减1，如果删除目录项后该文件的链接数为零，这时系统才把真正的文件从磁盘上删除。
4.文件更新。如果涉及文件更新，只需要先在WinSxS目录里面下载好一个新版本，然后修改Windows\System32下面同名文件的硬连接关系，从旧版本的硬连接指向新版本的硬连接，这样就能够快速的完成文件的更新工作，而不需要进行文件的复制，速度也会快不少。
5.卸载补丁。遇到需要补丁卸载的情况，只需要把硬连接指向改为旧版本就可以了，没有文件替换的问题。而且建立了硬连接关系的文件之间的修改是同步的，因此只要有一方被修改了，另一方也会得到修改。


//增加硬链接后,硬链接数+1 --- 硬链接数是一种引用计数 -- 引用技术==有多少人指向我
-rw-rw-r-- 2 chj chj  0 Oct  9 15:15 my-hard
lrwxrwxrwx 1 chj chj 12 Oct  9 22:36 my-soft -> new_file.txt
-rw-rw-r-- 2 chj chj  0 Oct  9 15:15 new_file.txt

$ 软连接支持对目录创建，硬链接不支持  作者：竞予科技 https://www.bilibili.com/read/cv20365690/ 出处：bilibili

每个目录内都有有.和..文件,  .是当前目录的硬链接,  ..是上级目录的硬链接 -- .和..只能由OS维护,用户不能修改(root也不行),保证安全 
-- . 和 .. 是OS特殊维护的可成环的路径结构,此结构OS可以识别,如果是用户则可能会成环,造成换路路径问题,破坏路径唯一性
    所以:硬链接不支持对目录创建  -- 硬链接数-2就是当前目录内至少具有的文件夹


$ 删除文件的另一种方式
# unlink //



----------------------------------------------------------

ACM时间
由于访问是最为频繁的操作,如果频繁的修改访问时间,则会占用很多的资源,所以只访问的话access时间一般会有一段时间才会更改/刷新
change时间和modify时间则 只要有修改则一定会刷新



---------------------------------------------------------
1.C/C++的库

// C/C++的生态,一般是开源(直接给代码),要么就是给库(编译好的二进制文件)
不同语言区别一般是解决问题的方式和生态,如python/java一般是给包,或其他能够直接使用的东西

//评价一款语言的好坏主要看其生态和应用场景:
应用场景中如C/C++主要是高并发高可用高扩展,python/java一般是快速搭建,快速使用


C语言的静态库: /usr/lib64/libc.a
C语言的动态库: /usr/lib64/libc-2.17.so

C++的动态库:   /usr/lib64/libstdc++.so.6s

//库的真实名称为 去掉前缀lib 去掉后缀.so/.a(如果有版本号也要去掉)
//一般的云服务器默认只会存在动态库,不存在静态库,静态库需要单独安装

c/c++头文件    /usr/include/
c++头文件      /usr/include/c++/

//头文件提供声明
//库提供实现

//编译器语法提示,自动补全功能需要包含头文件 -- 自动将用户输入的内容在头文件中搜索 --- 依赖头文件
//语法检查,报错是编译器在编辑器后台自动编译,但不链接的自动化模式

2.库有什么用 

提高开发效率

//学习阶段,造轮子是最好的学习方式
//开发阶段 -- 用轮子

3.库的设计角度 -- 打包给别人用


4.如何使用库


静态库:
{

制作库:
# ar rc lib库名[.so或.a]  要打包的文件1 要打包的文件2 ...       //ar是打包命令archive r是选项replace:替换已有的或插入新的;  c是不存在则创建;
//ar，Linux系统的一个备份压缩命令，用于创建、修改备存文件（archive），或从备存文件中提取成员文件。ar命令最常见的用法是将目标文件打包为静态链接库。
https://baike.baidu.com/item/ar/7426017 //ar百度百科

//静态库的.o和一般的.o是一样的.只有动态库的.o是特殊的

//使用库除了要有库之外还要有头文件
//我们安装别人的库一般就是下载库和对应的头文件,安装到系统的默认路径下

初步演示:
当前目录中已有文件:add.h   libmath.a  main.c  sub.h
# gcc -o a.out main.c -lmath -L. -I. 
//-l(lib-name)后接要使用的库的库名(真实库名); -I(include):后接头文件路径; -L(lib-dir):后接库所在的路径  //选项后可以不带空格 // .是当前目录
//不指明路径则在默认路径下寻找

//由于gcc不加 -static选项 ,实际上只有静态库是静态链接的情况. 其他依赖的第一第二方库都是动态链接的. --- ldd和file可以验证
//加 -static后,所有库都是静态链接

实际使用: ---- 库的安装
1. 把下载下来的库的inlucde内的头文件拷贝到系统的/usr/include/中
2. 把下载下来的库的lib内的库文件拷贝到系统的/usr/lib64/中
//命令需要提权 sudo
3.然后gcc main.c -l库名 //编译成可执行程序 -- 之后就不依赖该静态库了 //此时就不需要-L 和 -I了 //如果不安装则需要
$ 安装和卸载的本质就是 拷贝到系统特定的路径下! ----- 安装/卸载就是拷贝


//使用第三方库(除了第一方和第二方,剩下的都是第三方):即便是全部安装到系统中,也必须要指明使用哪个库. 如gcc/g++要用-l指明具体的库名
第一方:编程语言提供的库...
第二方:操作系统系统接口...

实际使用 --- 
无论是库还是源代码,源代码会提供内置的编译方式,如makefile,cmake等. --- 最终都会提供一个make install(安装)的命令(脚本) ---- 实际就是拷贝,安装到系统
,由于要安装到系统,所以大部分指令都需要sudo或超级用户


    1.静态库非常占资源,可执行程序体积变大占用内存;下载周期变长,占用网络资源 ; 
}


5.动态库的配置
{

# ldd  动态链接的可执行程序 //查看可执行程序依赖的动态库

生成与位置无关码的.o文件:
# gcc -fpic -c 文件 // position ignore code //形成一个 与位置无关码 的.o文件 -- 和静态链接的.o文件有差别
//打包成动态库
# gcc -shared -o libmath.so *.o; ///shared 共享 
//编译器自带动态库打包功能说明:使用动态库是主流

如果使用静态库的编译方式://报错: ./a.out: error while loading shared libraries: libmath.so: cannot open shared object file: No such file or directory
问题在于:编译器编译过程正常识别,但执行过程需要经过OS,而OS默认只会在系统的默认路径下查找库
//为什么静态库能找到? 因为静态库已经把库拷贝到可执行文件中了,编译完成后可以不依赖库执行

解决方法1:环境变量 LD_LIBRARY_PATH//指定 load_库_路径             //LIBRARY_PATH是库路径
https://blog.csdn.net/weixin_42617472/article/details/125829895
# export LD_LIBRARY_PATH=$LD_LIBRARY_PATH://home/chj/.../lib           //临时导入环境变量
//此时查看ldd就能发现可执行程序找到了动态库
注意:仅在本次登录有效,登出后环境变量就重置了

解决方法2:在lib64中创建软连接
# ln -s /home/chj/.../lib/libmath.so /lib64/libmath.so
卸载:删除软连接即可

解决方法3:配置文件
在路径:/etc/ld.so.conf.d/  下新建配置文件 ---   //加载动态库配置文件
1.配置文件名可以自定义
2.配置文件内只存放目标文件路径
3.在可执行程序所在目录底下使用sudo ldconfig命令使配置文件生效
//ldconfig是一个动态链接库管理命令,命令的用途,主要是在默认搜寻目录(/lib和/usr/lib)以及动态库配置文件/etc/ld.so.conf内所列的目录下,搜索出可共享的动态链接库(格式如前介绍,lib*.so*),
    进而创建出动态装入程序(ld.so)所需的连接和缓存文件.缓存文件默认为 /etc/ld.so.cache,此文件保存已排好序的动态链接库名字列表. 

//etc 是 "etcetera" 的缩写，表示"其他"或"等等"的意思。这个目录的名称源自拉丁语，最初用于存储各种系统配置文件以及其他不属于特定目录的文件。在Linux系统中，/etc 目录包含了各种配置文件，而名称 "etcetera" 暗示了这是一个包含各种杂项配置文件的地方。
/etc 文件夹在Linux系统中具有重要的作用，它通常包含系统级别的配置文件和设置。以下是 /etc 文件夹的一些常见用途：
1.系统配置文件： /etc 文件夹包含了许多系统级别的配置文件，用于配置操作系统和安装的软件。这些文件包括网络配置、用户帐户信息、系统服务启动脚本、硬件设备配置、安全策略等。例如，/etc/network 包含网络配置文件，/etc/passwd 包含用户帐户信息。
2.软件配置文件： 许多安装的软件包也会在 /etc 中创建配置文件，以供系统管理员进行配置。这些文件可以用于自定义软件的行为，包括数据库、Web服务器、应用程序和服务。
3.启动脚本： /etc 文件夹通常包含用于配置系统启动和关机过程的脚本文件，如 /etc/init.d 或 /etc/systemd 目录。这些脚本用于启动和停止系统服务，以及执行其他初始化任务。
4.日志和日志配置： /etc 文件夹中的一些子目录包含了日志文件以及日志记录工具的配置文件。这些文件对于系统监控和故障排除非常重要。
5.安全策略和权限设置： /etc 文件夹中包含了一些与系统和应用程序的安全策略有关的文件。例如，/etc/security 目录包含了安全策略的配置文件，/etc/sudoers 文件包含了sudo权限设置。
6.默认配置文件： /etc 文件夹通常包含了系统和应用程序的默认配置文件，当安装新软件或服务时，这些文件会作为模板使用。
总之，/etc 文件夹在Linux系统中起着关键的作用，它存储了许多配置信息，允许管理员对系统的行为进行调整和自定义。这使得系统在不同环境中可以进行灵活的配置。

//解决方法4:拷贝到系统默认路径..

}

优点是编译后不依赖相关的库文件

6.动态库的加载
可执行程序执行后加载到内存成为进程,在执行过程中遇到需要的库函数的地址时,检测内存中该库是否被加载,没有加载则把库加载进内存,然后通过页表映射到进程PCB中
    不同进程可以共用一份动态库,只需要通过各自的页表映射到各自的PCB中即可 -- 最终映射到共享区中
$ 加载库不一定是全部加载进内存,库可能会很大,可以需要哪部分再加载


$ 磁盘上的可执行程序内有自己的逻辑地址,加载到内存中有物理地址,PCB中有虚拟地址
静态链接的可执行程序的地址按0到FFF... 进行编址 --- 绝对编址 , 然后再通过页表映射

//地址就两类绝对编址和相对编址

每个进程的共享空间中空闲位置是不确定的
动态库中的所有地址,都是相对于整个库的起始地址的偏移量,默认从0开始.动态库只有加载进内存时,起始地址才能被确定 -- 因为动态库是需要时再加载,不需要时不能占有空间,要给其他对象使用
而静态库已经在确定在可执行程序中的位置了,固定不变

//先搞明白静态库的地址,就能明白动态库了

静态库（Static Library）：
静态库是一组编译好的目标文件的集合，它们在链接时被直接嵌入到可执行文件中。这意味着在编译期间，编译器将静态库的代码和数据部分合并到可执行文件中，
    形成一个单一的可执行文件。因此，静态库中的代码和数据在编译时就被决定了其在可执行文件中的位置，使用绝对地址。

动态库（Dynamic Library）：
动态库是一个独立的文件，它在运行时被加载到内存中，而不是在编译时被合并到可执行文件中。这使得多个可执行文件可以共享相同的动态库，
    节省了磁盘空间并允许在系统上动态升级库。因为动态库在加载时才确定其位置，所以它们不能使用绝对地址。



$$$ 实验
1.静动态库同时存在时,默认采用动态库
2.如果只有静态库,则静态链接第三方库,动态链接第一第二方库

sudo yum install -y ncurses-devel
// ncurses库
https://blog.csdn.net/zty857016148/article/details/132124383




////////////////////////////////////////////////////////////////////////////////////////////////////////////////
VSCODE

rpm包主要用于redhat及分支如redhat，centos，Fedora等
deb包主要用于debian及分支如debian，ubuntu等。


~/.vscode-server/extensions/     目录下是vscode的插件位置
vscode与linux异常 --> 删除.vscode-server,下次使用vscode链接linux会自动重建


C++中包含C头文件:
{
在C++中，标准C库的头文件通常存在两个版本，一种是不带.h扩展的，另一种是带.h扩展的。例如，有两种版本的头文件分别是 <stdio.h> 和 <cstdio>。

不带.h扩展的头文件（例如 <cstdio>）：
这些头文件是C++标准库的一部分，并包含了C标准库的函数和变量。它们将C标准库的函数和变量放在std命名空间中，因此在使用时需要前缀std::。例如，<cstdio> 中的 printf 在C++中应该使用 std::printf。

带.h扩展的头文件（例如 <stdio.h>）：
这些头文件是C标准库的一部分，它们不在std命名空间中。在C++中，您可以包含这些头文件，但它们不会将函数和变量放在std命名空间中，因此可以直接使用，不需要前缀std::。

在新的C++代码中，通常建议使用不带.h扩展的头文件，将C库的函数和变量置于std命名空间中，以避免全局命名冲突并更好地与C++的标准库协同工作。
然而，对于现有的C代码，或者在需要与C库进行交互时，您可能需要包含带.h扩展的头文件。在新的C++项目中，推荐使用C++标准库的相应头文件，如 <iostream> 代替 <stdio.h> 和 <cstdio>，以获得更好的类型安全性和C++特性。

}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////
进程间通信 IPC Inter-Process Communication  //实际上是构建进程间通信的解决方案

$$ 进程间通信分类:
1.管道
    匿名管道pipe //Anonymous pipes
    命名管道
2.System V IPC        // V仅表示名称 或者version意思
    System V 消息队列
    System V 共享内存
 ※ System V 信号量
3.POSIX IPC
    消息队列
    共享内存
    信号量
    互斥量
    条件变量
    读写锁


前言:
$ 进程是具有独立性的,进程间通信不能破环进程的独立性
$ 要让两个不同的进程进行通信,前提是:先让两个进程看到同一份资源-----OS直接或间接提供
$ 一定是一个进程创建一个进程获取

$$ 
任何进程通信手段都需要经过一下两步
a.想办法,让不同的进程看到同一份资源 -- 看到同一份资源的方式不同,资源不同->通信方式的差异
b.让一方写入,一方读取,完成通信过程.其他通信目的与后续工作,要结合具体场景

$ 管理IPC:
1.谁创建,谁负责 //服务端负责提供资源和回收资源


1.管道
{
$ 什么是管道
管道是Unix中最古老的进程间通信的形式。 -- 所有IPC的爷爷
我们把从一个进程连接到另一个进程的一个数据流称为一个“管道

# who | wc -l  //最基本的进程间通信

验证管道|两边的进程是否是独立进程:
[chj@expiration1102 ~ 18:45:42]$ sleep 10000 | sleep 20000 |sleep 30000 & //&的作用是让进程在后台进行
[chj@expiration1102 ~ 18:51:12]$ ps ajx |head -1 && ps axj |grep -E '16473|sleep' | grep -v grep  //-E 正则表达式
 PPID   PID  PGID   SID TTY      TPGID STAT   UID   TIME COMMAND
16472 16473 16473 16473 pts/1    16844 Ss    1002   0:00 -bash
16473 16522 16522 16473 pts/1    16844 S     1002   0:00 sleep 10000 //不一样的三个进程在同时进行
16473 16523 16522 16473 pts/1    16844 S     1002   0:00 sleep 20000
16473 16524 16522 16473 pts/1    16844 S     1002   0:00 sleep 30000 //
15508 16817 15508 15508 ?           -1 S     1002   0:00 sleep 180
16473 16844 16844 16473 pts/1    16844 R+    1002   0:00 ps axj


$ linux中一切皆文件 -- 管道也一样是文件

//管道的大小是有上限的,不同的平台不一样, linux的上限是65535 ,2^16

管道是一个内存级文件(由操作系统提供的,不需要刷新到磁盘中的文件) --- 匿名文件 //该文件主要是提供给两进程通信用的,临时就够了,不需要写到磁盘

左进程将标准输出重定向到管道,右进程将标准输入重定向到管道

管道实现原理: -- 匿名管道方式 
1.进程以r和w方式分别打开同一个文件(如文件描述符3和4) 
2.然后fork 
-- fork创建子进程只会复制进程相关数据结构对象,而不会复制内存这边的文件结构,即复制后两个进程依旧指向同一份资源 --- 满足了两个进程看到同一份资源的前提
此时一个进程往该文件中写入,另一个进程从该文件中读入 -- 即可实现进程间通信 -- 但此时这种方式只支持单向通信
//原理:复制进程/子进程继承了父进程打开的文件描述符
3.确定数据流向,关闭不需要的fd:
-- 子进程关闭r的文件如3,父进程关闭w的文件如4,此时可以反向通信


// 为什么管道只支持单向通信? 因为文件一次只能读或写,所以才被命名成管道
// 如何同时双向通信? 定义两个管道即可
// 为什么这种方式叫匿名管道? 因为这个文件是匿名文件,用户不知道这个文件的名字和位置


#include <unistd.h>
功能:创建一匿名管道
原型
int pipe(int fd[2]); 
参数
输出型参数fd：文件描述符数组,其中fd[0]表示读端, fd[1]表示写端  -- 返回管道的读端和写端的文件描述符
返回值:成功返回0，失败返回错误代码
    On  success,  zero  is  returned.  On error, -1 is returned, and errno is set appropriately.

int ppidfd[2];
ppidfd[0] //读端 -- 0:嘴巴:读东西
ppidfd[1] //写端 -- 1:笔  :写东西

$ 管道单向通信原理:
{
1.创建管道
    |------写端------|  
 进程                管道
    |------读端------|  

2.进程复制
    |------写端------|  |---写端---------|
 进程                管道                 子进程(进程复制)
    |------读端------|  |---读端---------| 

3.关闭不需要文件描述符
    |------写端------|  
 进程                管道                 子进程(进程复制)  //单向通信
                        |---读端---------| 

}

管道的特点:
1.单向通信  --- //半双工(Half Duplex)数据传输指数据可以在一个信号载体的两个方向上传输，但是不能同时传输
//全双工:通信允许数据在两个方向上同时传输
2.管道的本质是文件,因为fd的声明周期随进程,管道的声明周期也随进程
3.使用管道的进程具有继承关系,如父子进程. 爷孙进程,继承父亲的兄弟进程也可以 -- 通常用来给 具有'血缘'关系的进程 进行进程间通信
4.管道中写入次数和读入次数不是严格匹配的 -- 管道中数据是字节流形式 -- 都是一个一个的字符
(读写次数的多少没有强相关 --- 字节流表现)
5.管道大小有上限

//管道读写是互斥,独立的 ..写的数据不会影响读的数据,读的数据不会影响写的数据

$$ 管道读写演示实验

a.写一次,读一次
现象:每次读到的数据都是下一次写入的数据,不会读到已经读取过的数据
// 读过的数据相当于被删除了(其实是覆盖)

b.快写入,慢读取:
现象:管道写满后就不能再继续写,-->管道有上限

c.慢写入,快读取:
现象:当管道没有数据时,读进程会一直等待(阻塞)写进程写入,直到写进程写入数据

d.写端关闭,读端一直读 :
现象:一直读

e 读端关闭,写端一直写:  //
现象: OS主动杀死写端进程 --> OS不会维护无意义,浪费资源的资源 --- 13号信号sigpipe

$ 关闭进程池的必要操作
1.要让使用管道的子进程退出,只需要让父进程关闭所有的write_fd就可以.
        严格来说应该是关闭一个子进程的全部写端,才能把这个子进程关闭
2.父进程回收子进程的僵尸状态


$$ 进程池: 
{
//预先开辟好的管道程序称为进程池

一.直接构建法
1.建第一个管道,然后进程复制
    |------写端------|  |---写端---------|
 进程              0号管道                0号子进程(进程复制)
    |------读端------|  |---读端---------| 

2.关闭父进程读端,关闭0号子进程写端
    |------写端------|  
 进程              0号管道                0号子进程(进程复制)
                        |---读端---------| 

3.创建第二个管道
    |------写端------|  
 进程              0号管道                0号子进程(进程复制)
 |  |                   |---读端---------| 
 |  |
 |  |------写端------|
 |                 1号管道                
 |---|-----读端------|

 4.进程复制,复制出第二个子进程,1号
     |------写端------|   |------写端-------------|
  进程              0号管道                       |
  |  |                                            |
  |  |                                            |
  |  |------写端------|   |------写端------|      |
  |                 1号管道                1号子进程
  |---|-----读端------|   |------读端------|


 5.实际情况:
     |------写端------|  
 进程        |        管道                0号子进程/复制进程
 | |         |           |---读端---------|
 | |         |                      
 | |         |                      
 | |         |--------------------------------|
                                              |
 | |                                          |
 | |-|------写端------|  |---写端---------|   |
 |                   管道                  1号子进程/复制进程
 |---|------读端------|  |---读端---------| 


现象:从第二进程开始,每复制一个进程都会复制之前存在的所有管道的写端

$ 注意事项:关闭进程池的其中一个进程时,必须先把所有的写端全部关闭
解决方法1: 反向关闭子进程,最后一个进程一定只有1个(来自父进程)写端,关闭后次低位的进程的非父进程的写端也全部关闭了,只剩父进程的...

解决方法2:构建一个单纯一对一的标准进程池


}




file结构体中 file文件是个union类型,分为普通文件和管道文件 -- 因此操作系统能够区分开


# man 7 pipe //查看管道的详细信息 
PIPE_BUF是一个宏,宏一般大小是4096 = 2^12
当要写入的数据量不大于PIPE_BUF时，linux将保证写入的原子性。
当要写入的数据量大于PIPE_BUF时，linux将不再保证写入的原子性。
------>> 进程在对管道进行读写时,会有冲突的可能.如果是原子操作,则可以保护冲突,让读写互斥.  否则,将不保证读写正确
//原子性现象:要写100个数据,如果没有写完,则一定读不了,要读只能等写完100个.  --- 原子性:多执行流交替执行访问共享资源时,安全访问的一种保护手段

//管道提供的是流式服务 -- 体现:字节流
//管道的声明周期:随进程 
//一般而言,内核会对管道操作进行同步与互斥

如果一端关闭写,则OS会杀死另一端(发送13号SIGPIPE命令),因为OS不会允许资源浪费(阻塞) --- 实现一个进程控制另一个进程


.hpp文件允许类的定义和声明不分离,成员方法的声明和实现不分离..通常开源项目用.hpp来做,使用文件较少,


# 回顾:
$ 进程间通信的目的是
1.数据传输:一个进程给另一个进程发送数据
2.资源共享:多个进程之间共享同样的资源
3.通知事件:发送消息...
4.进程控制:发送信号...

}




$$$$ 命名管道 Named Pipes
 {
 前言: 管道(匿名管道)的一个限制就是只能在具有共同祖先(具有亲缘关系)的进程间通信
 
 描述:命名管道可以在不相关的进程之间交换数据,他是一个FIFO文件,是一个特殊类型的文件,是一个可以显式创建出来的文件,是一个内存级文件(不需要刷盘的文件)
 // 有inode等,但没有datablock(不需要刷盘)

 如何让不同的进程看到同一份命名管道? // 文件的唯一性:路径.  通过路径+文件名让两个不同的进程看到同一个命名管道
 //命名管道为什么叫命名管道? 就是因为该文件是有文件名的,而且必须有文件名


 命令:
 mkfifo --- make FIFOs (named pipes) //创建一个FIFO(队列)文件
 
 # mkfifo fifo //创建一个名为fifo的命名管道
 prw-rw-r-- 1 chj chj 0 Oct 22 13:29 fifo //以p开头,说明是管道文件

 演示1.: 两个终端
 1号终端输入 echo "hello world" > fifo //之后1号终端会进入阻塞状态
 2号终端输入 cat < fifo  //读取到hello world ,然后1号终端解除阻塞状态

 演示2:
 1号终端输入 while :; do echo "hello";sleep 1; done > fifo
 2号终端输入 cat < fifo

 两边都是独立的进程,没有亲缘关系

 现象: 命名管道有一端未打开,进程会阻塞在open处 -- open的特性,可以关闭,带上某命令选项即可

 $$ 必须先启动读端,读端控制进程是否正常,
 1.读端开启,会阻塞/非阻塞等待写端.
 2.读端关闭,则写端进程关闭.

 }



system V (版本的) 共享内存 //shared memory共享内存
{
 
 system V是一套标准,专门为为了通信而设计出来的一个内核模块

$ 共享内存也其他IPC一样,必须要让两个进程看到同一份资源
$ 共享内存的生命周期不随进程,随OS
$ 共享内存是所有IPC中最快的.

$ 共享内存的使用流程;
1.创建共享内存
2.关联进程和取消关联
3.释放共享内存

$ OS中有很多共享内存 ---> OS需要管理共享内存 --- 存在管理shm结构体的数据结构
//共享内存结构体struct shm{}; //存放了共享内存的所有属性
共享内存 = 共享内存结构体+为共享内存开辟的空间

 
 linux 共享内存的接口
 {
 一.shmget//创建共享内存
 声明:int shmget(key_t key, size_t size, int shmflg);
头文件:
#include <sys/ipc.h>
#include <sys/shm.h>
参数:
1.key: 类似inode,用于唯一标识块,可以任意值,一般使用ftok来设置key.
    OS会遍历共享内存的key,创建共享的内存的进程会检查,如果key不存在,则设置成新共享内存的key.获取共享内存的进程使用同样的key去配对共享内存
2.size:申请的共享内存块的大小
3.shmflg: //宏,和open的宏类似 一般使用IPC_CREAT|IPC_EXCL的组合,保存创建的是独享的共享内存
IPC_CREAT:创建共享内存.如果共享内存不存在,则创建之. 如果共享内存已存在,则获取已存在的共享内存的并返回
IPC_EXCL:Exclusive:表示如果共享内存段已经存在，则创建失败并返回，确保该内存段是独占的，不与其他进程共享。如果共享内存段已经存在，并且使用IPC_EXCL标志创建新的共享内存段，则会返回一个错误。
            这有助于防止多个进程创建相同的共享内存段，从而确保共享内存的独占性。
            --- 不能单独使用,一般配合PC_CREAT
返回值:
1.错误返回-1
2.成功返回有效的共享内存标识符,由于和文件描述符冲突(网络都是使用文件描述符),所以不是很常用,

二.ftok //将路径名和项目标识符转换为System V版本的key
$ 确保提供一个已存在的文件路径，因为ftok会根据文件的inode号和给定的整数生成唯一的key。
//ftok是一套算法,没有涉及太多系统接口
声明:key_t ftok(const char *pathname, int proj_id);
参数:
1.pathname:文件路径
2.proj_id:项目id
返回值:
1.错误返回-1,并设计errno...
2.正确返回key值

三.shmctl //SystemV版本的shm控制
shmctl 是Linux/Unix系统中的一个系统调用，用于对共享内存段进行控制操作。它通常用于管理共享内存，包括创建、删除、获取信息和控制共享内存的属性等操作。
声明int shmctl(int shmid, int cmd, struct shmid_ds *buf);
参数:
1.shmid：是共享内存段的标识符，通常是由 shmget 返回的标识符。
2.cmd：是要执行的操作，可以是以下值之一：
    IPC_STAT：获取共享内存段的信息，将其存储在 struct shmid_ds 结构体中，该结构体通过 buf 参数传递。
    IPC_SET：设置共享内存段的属性，将 struct shmid_ds 结构体中的信息应用到共享内存段。
    IPC_RMID：从系统中删除共享内存段。
    其他特定于系统的命令，具体取决于系统和使用情况。
3.buf：一个指向 struct shmid_ds 结构体的指针，用于存储或设置共享内存段的信息。通常，buf 参数在执行 IPC_STAT 和 IPC_SET 操作时被使用。
返回值:
    当执行 IPC_STAT 命令时，shmctl 返回 0 表示成功，并将共享内存段的信息存储在提供的 struct shmid_ds 结构体中。
    The caller must have read permission on the shared  memory segment. //要有读权限
    struct shmid_ds { //data structure
               struct ipc_perm shm_perm;    /* Ownership and permissions */
               size_t          shm_segsz;   /* Size of segment (bytes) */
               time_t          shm_atime;   /* Last attach time */
               time_t          shm_dtime;   /* Last detach time */
               time_t          shm_ctime;   /* Last change time */
               pid_t           shm_cpid;    /* PID of creator */
               pid_t           shm_lpid;    /* PID of last shmat(2)/shmdt(2) */
               shmatt_t        shm_nattch;  /* No. of current attaches */
               ...
           };
    当执行 IPC_SET 命令时，shmctl 返回 0 表示成功，表示成功更新了共享内存段的属性。
    struct ipc_perm {
               key_t          __key;    /* Key supplied to shmget(2) */
               uid_t          uid;      /* Effective UID of owner */
               gid_t          gid;      /* Effective GID of owner */
               uid_t          cuid;     /* Effective UID of creator */
               gid_t          cgid;     /* Effective GID of creator */
               unsigned short mode;     /* Permissions + SHM_DEST and SHM_LOCKED flags */
               unsigned short __seq;    /* Sequence number */
           };
    当执行 IPC_RMID 命令时，shmctl 返回 0 表示成功，表示成功删除了共享内存段。
    如果出现错误，shmctl 返回 -1，并设置 errno 变量来指示发生的错误。

四.shmat //System V 版本 shm 操作

声明:void *shmat(int shmid, const void *shmaddr, int shmflg);
参数:
shmid:要关联的shmid
shmaddr:选择挂接的内存地址,用户不知道,所以设为null,让系统选择即可.
shmflg:SHM_RDONLY(只读),0(读写)
返回值:返回虚拟地址(数组),供用户使用

 
}
 
 
 
}

 三对命令:
 ipcs  //ipc
 {
 ipcs 是 "Inter-Process Communication (IPC) Status" 的缩写

 ipcs 是一个Linux命令，用于查看进程间通信（Inter-Process Communication，IPC）的相关信息。它通常用于查看系统中的消息队列、信号量和共享内存等 IPC 对象的状态。以下是一些常用的 ipcs 命令选项和相关单词的解释：

Message Queues（消息队列）:
ipcs -q：查看消息队列的信息。//queue
msqid：消息队列的标识符。
key：消息队列的键值。
mode：访问权限和标志。
cbytes：消息队列的当前字节数。
qnum：消息队列中的消息数量。

Semaphores（信号量）:
ipcs -s：查看信号量的信息。 //singal
semid：信号量的标识符。
key：信号量的键值。
mode：访问权限和标志。
nsems：信号量集中的信号量数量。
otime：上次操作时间。
ctime：创建时间。
semnum：信号量的编号。

Shared Memory Segments（共享内存段）:
ipcs -m：查看共享内存段的信息。//memory
shmid：共享内存段的标识符。
key：共享内存段的键值。
mode：访问权限和标志。
owner：拥有者的用户ID。
cpid：创建该共享内存段的进程ID。
lpid：上次连接到该共享内存段的进程ID。
IPC Control Commands（IPC 控制命令）:

ipcrm：用于删除 IPC 对象（消息队列、信号量、共享内存）。
-q, -s, -m：用于指定要删除的对象类型。
-Q, -S, -M：用于指定对象的标识符
# ipcrm -m/s/q shmid/msqid/semid   //删除消息队列.信号量,共享内存

$ ipc操作方法类似文件,fd==id ,key==inode. 在用户层也和文件一样使用,使用fd/id.  key和inode给操作系统使用

--------------------------------------------------------------------------------
centos下ipcs

------ Message Queues --------
key        msqid      owner      perms      used-bytes   messages    

------ Shared Memory Segments --------
key        shmid      owner      perms      bytes      nattch     status      

------ Semaphore Arrays --------
key        semid      owner      perms      nsems 

key(Hex)   id(Dec)

Message Queues (消息队列)：
key：消息队列的键值，用于标识消息队列。
msqid：消息队列的标识符，系统为每个消息队列分配一个唯一的标识符。
owner：消息队列的拥有者，即创建该消息队列的用户。
perms：消息队列的访问权限和权限位。
used-bytes：消息队列当前使用的字节数。
messages：消息队列中的消息数量。

Shared Memory Segments (共享内存段)：
key：共享内存段的键值，用于标识共享内存段。
shmid：共享内存段的标识符，系统为每个共享内存段分配一个唯一的标识符。
owner：共享内存段的拥有者，即创建该共享内存段的用户。
perms：共享内存段的访问权限和权限位。 //permission
bytes：共享内存段的字节数。
nattch：连接到共享内存段的进程数量。 //attached:所附的,附加的 -- 关联数
status：共享内存段的状态信息。

Semaphore Arrays (信号量数组)：
key：信号量数组的键值，用于标识信号量数组。
semid：信号量数组的标识符，系统为每个信号量数组分配一个唯一的标识符。
owner：信号量数组的拥有者，即创建该信号量数组的用户。
perms：信号量数组的访问权限和权限位。
nsems：信号量数组中的信号量数量。
 }
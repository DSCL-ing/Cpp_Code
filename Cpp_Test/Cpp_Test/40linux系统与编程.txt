#pragma once

xshell快捷键:
$ shift+Page Down/Up  //[终端]向上或向下翻页

linux版本号

主版本号.次版本号.修正次数 2.6.30    -- 次版本号为偶数:稳定版   奇数:测试版


$ 操作系统是一款进行软硬件管理的软件

$ 操作系统存在的意义:操作系统对软硬件进行合理管理(手段/方法),以达到为上层用户提供良好的,稳定的,安全的运行环境的目的

$ 开机就是加载操作系统,俗称开机

# mkdir 目录名  //创建目录(linux)/文件夹(win)

# pwd  //显式当前目录的绝对路径

# touch	文件名.后缀          //创建普通文件

//#命令 -[命令选项]  --后序学习"命令行参数和环境变量"
//command 
//command not found :找不到命令

#echo "字符串" > 文件 //清空文件再写入,'w'


$ 文件 = 内容+属性
文件操作分为1.内容操作 2.属性操作

# ls -l(l:list) //以list的形式显式更多的属性

$ 以.开头的文件/目录是隐藏文件/目录

# ls -ul  //以uid形式显式属性

# .  //当前路径
# .. //上级路径

# C:\Users\26390\Desktop //  windows下的路径,  (反斜杠) \ : 路径分割符
# /root/test             //  linux下的路径,      (斜杠) / : 路径分隔符

# ls -ld /   //只显示路径,不显示内容
$ / 为linux下的根,linux下为目录为蓝色
$ windows下文件夹内可以有新的文件夹,linux下目录内可以有新的目录 -- 所以linux的根 / 和路径分隔符 / 不冲突
$ linux整体是一个多叉树的样子/结构

$ windows通过路径来定位文件/文件夹,linux也是如此.  
为什么呢? > 任何一个目录都可以有多个子目录,但一个子目录只有一个父目录 -->因此一条路径能唯一标识一目录/文件 
$ 路径分为1.绝对路径 2.相对路径(相对是相对于当前路径,如果当前路径改变了,则相对路径也会发生改变 ->失效)

$ 绝对路径使用场景:准确但麻烦,一般是在某些配置环境中,进行对某种文件进行配置时采用!
$ 相对路径使用场景:用起来简单,是后序指令操作时,常用的路径定位方案!

# cd ~  //进入/home目录
$ 超级用户/管理员root的~独立位于/root
$ 普通用户的~都位于/home底下 -- ~称为普通用户的家目录
$ window也有家目录,位于C:\Users ,

# cd -   //回到上一次访问的目录

热键:高频被使用的按键
# 快速双击tab键  -->命令的自动补齐:1.显式出匹配的所有命名 2.显示出匹配目录下的所有文件
# 不想进入目录又想查看其他目录有哪些文件 --> 无脑 tab../../../../

# tree [空] / [.] / [..] / [其他目录]   //以树的形式把指定目录打印出来,不加命令选项默认是当前目录
$ -bash: tree: command not found 解决方法:root下# yum install -y tree  //如果是Ubuntu,则是# apt-get install -y tree

$ 按键:ctrl+C  //停止当前活动/打印/刷屏 /终止程序的运行/刷屏

# touch 文件 或 ../文件 //在当前目录创建一个普通文本文件 或在指定目录创建一个普通文本文件

# nano 文件  //使用nano编辑器u是什么意思打开文件

$ nano :nano是Unix/Linux下的一个文本编辑器
nano编辑器的快捷键使用
Ctrl+G 帮助
Ctrl+X 退出
Ctrl+O 保存
Ctrl+R 复制指定文件内容
Ctrl+W 查找
Ctrl+\ 替换
Ctrl+K 剪切
Ctrl+U 粘贴
Ctrl+J 调整段落
Ctrl+T 检查拼写
Ctrl+C 光标位置信息
Ctrl+Shift+_ 跳转到指定行
Alt+U 撤销
Alt+E 反撤销
Alt+A 从光标位置开始标记/选择
Alt+6 复制
Ctrl+3 & Shift+3 显示行号
//nano不能用数字小键盘,只能用数字横键盘

//cancel :取消

# cat 文件  // 打印/显式文件内容

# gcc .c文件 //编译.c文件,得到a.out可执行文件 //可执行文件是绿色
# ./a.out    //执行可执行文件,执行a.out文件  -- 可执行文件在linux下必须带./  ,后面学

$ 云服务器可以重启,但不要轻易关机

# stat 文件  //获取文件的所有属性
$ 任何文件都有三种时间:A.C.M.时间:1.Access(访问) 2.Modify(内容) 3.Change(属性)
$ ll显式的时间是M时间

# mkdir -p d1/d2/d3/...   //创建一串路径/目录; 递归创建多个目录

# rmdir 目录     //删除目录,只能删除非空目录 -- 也没有支持递归删除的命令选项,所以目前没什么用
//rmdir:failed to remove :删除失败
$ 为什么要有 -- 如果有一个文件和目录同名,想删目录可以用rmdir 或 rm -r 目录, 想删文件用rm(默认删的就是文件) --这样就区分开来

# rm  指定目录/指定文件   //删除文件或目录  -- 什么都能删,只要权限够
# rm -r 指定目录          //递归删除目录内的所有文件/目录
# rm -rf 指定目录         //强制递归删除目录内的所有文件/目录 -- 不提示/不通知/不需要确认 直接删完

$ 普通用户只能在 /home/自己/... 内创建文件 ,root在哪里都可以创建

//3

//判断绝对路径 1.绝对路径是以/开始的 2.绝对路径放在任何目录下都与其他路径无关


$ 输入框为空时按一下table可以显式当前linux系统有多少条指令 -- 阿里云轻量应用级有1265条左右

//删除
# rm -r 目录  //通过rm删除目录,递归删除目录  -- 因为目录本身就是递归定义的

# sudo touch 文件 // 以root身份创建文件

# rm  文件  //只能删除普通文件 -- 默认只能删除普通文件

# yum install -y man-pages //安装man手册
# man [号] xx  //搜索[几号]man手册并进入,没有号码则默认搜索全部
# man man //打开man手册首页

//man 2 一般是系统调用
//man 3 一般是C库

# sudo 命令  //命令提权

//拷贝
# cp 普通文件 目录 // 拷贝普通文件到目录中
# cp -r 目录  目录 // 拷贝目录到目录中,必须带-r,递归拷贝 

$ 命令选项可以放中间也可以放在最后 // 最好保持放中间,有些系统不支持,如mac

//剪切
# mv 目录/文件 目录  //移动目录/文件,不需要带递归-r命令选项   ,后面一项一定是目录
# mv 目录/文件 ..    //移动文件/目录到上级目录
# mv 目录/文件 .    //移动文件/目录到当前目录

//文件重命名
# mv 旧文件名  新文件名  //重命名 --                        后面一项一定时文件名

//文件剪切+重命名
# mv 旧文件名  路径/new_filename(带目录的新文件名)    //如果第二项是是目录且带着一个没有重复的文件名,则是移动+重命名

//目录重命名
# mv 目录   新目录名(不能和所在路径有重复)  //当前目录下重命名

//目录剪切+重命名
# mv 目录  带路径的新目录名(不能和所在路径有重复)   //


//linux下一起皆文件,键盘,显示器...可以读,可以写都是文件


# cat 文件      //打印文件内容到控制台

# echo    文本内容       // 输出到控制台  - 文本内容目前最好带上"" 

# echo    文本内容  >  文件   // 输出 文本内容 重定向 到文件 , '>'为输出重定向符号 -- 如果文件不存在,输出重定向>会创建一个新文件并写入
$ '>'输出重定向是一种覆盖式写入 ,清空文件再写入
$ '>>' 追加重定向:追加重定向是追加式写入,在原文件内容的末尾追加写入,给原文件新增内容


# wc 文件 //wc命令的功能为统计指定文件中的字节数、单词数、行数, 并将统计结果显示输出
-c, --bytes打印字节数
-m, --chars  打印字符数 
-l, --lines  打印行数                                   //学
-L, --max-line-length  打印最长行的长度
-w, --words 打印单词数

$ '<' 输入重定向

$ cat默认是重键盘读取数据 -- 只输入cat就会进入键盘读取状态,打一个回显一个,直到ctrl+C
# cat < 文件  //读入重定向到文件,默认是键盘 -- 和# 【cat 文件】  不一样 , 【cat 文件】是命令获取文件

//cat用法：cat [选项] [文件]...
将[文件]或标准输入组合输出到标准输出。
  -A, --show-all           等价于 -vET
  -b, --number-nonblank    对非空输出行编号
  -e                       等价于 -vE
  -E, --show-ends          在每行结束处显示 $
  -n, --number             对输出的所有行编号                //学
  -s, --squeeze-blank      不输出多行空行                    //把连续的空行合并成一行
  -t                       与 -vT 等价
  -T, --show-tabs          将跳格字符显示为 ^I
  -u                       (被忽略)
  -v, --show-nonprinting   使用 ^ 和 M- 引用，除了 LFD 和 TAB 之外
      --help     显示此帮助信息并退出
      --version  输出版本信息并退出
如果[文件]缺省，或者[文件]为 - ，则读取标准输入。

# more 文件 //按屏幕大小显式文件内容 -- 按回车翻页,并且只能向下翻页,按q推出


{
# less 文件 //按屏幕大小显式文件内容 -- 按上下键翻页,可以自由翻页,按q推出
//搜索 输入/搜索内容+回车 , 转到下一个搜索结果按n(next)
less 与more命令类似，但可以通过翻页键查看上下页的内容
-b<缓冲区大小> 设置缓冲区的大小
-e 当文件显示结束后，自动离开
-f 强迫打开特殊文件，例如外围设备代号、目录和二进制文件
-g 只标志最后搜索的关键词
-i 忽略搜索时的大小写
-m 显示类似more命令的百分比
-N 显示每行的行号
-o<文件名> 将less 输出的内容在指定文件中保存起来
-Q 不使用警告音
-s 显示连续空行为一行
-S 行过长时间将超出部分舍弃
-x<数字> 将“tab”键显示为规定的数字空格

命令内部操作按键功能如下：
b 向前翻一页
d 向后翻半页
h 显示帮助界面
Q 退出less 命令
u 向前滚动半页
y 向前滚动一行
空格键 滚动一页
回车键 滚动一行 

1) 向前搜索
    / ： 使用一个模式进行搜索，并定位到下一个匹配的文本
    n ： 向前查找下一个匹配的文本
    N ： 向后查找前一个匹配的文本

2) 向后搜索
    ? ： 使用模式进行搜索，并定位到前一个匹配的文本
    n ： 向后查找下一个匹配的文本
    N ： 向前查找前一个匹配的文本

2 全屏导航
    ctrl + F ：向前移动一屏
    ctrl + B ：向后移动一屏
    ctrl + D ：向前移动半屏
    ctrl + U ：向后移动半屏

3 单行导航
    j ： 向前移动一行
    k ： 向后移动一行

4 其它导航
    G ： 移动到最后一行
    g ： 移动到第一行
    q / ZZ ： 退出 less 命令

5 编辑文件
    v ： 进入编辑模式，使用配置的编辑器编辑当前文件

6 标记导航
    当使用 less 查看大文件时，可以在任何一个位置作标记，可以通过命令导航到标有特定标记的文本位置。
    ma ： 使用 a 标记文本的当前位置
    'a ： 导航到标记 a 处

7 浏览多个文件
    方式一，传递多个参数给 less，就能浏览多个文件。
    less file1 file2

    方式二，正在浏览一个文件时，使用 :e 打开另一个文件。
    less file1
    :e file2

    当打开多个文件时，使用如下命令在多个文件之间切换
    :n - 浏览下一个文件
    :p - 浏览前一个文件

}


# head 文件 //默认会把文件的前10行打印出来,不够10行有多少打多少
# head -n5 文件 //设置成只打印前5行
# head -5 文件 //一样,省略,设置成只打印前5行

# tail 文件 //
# tail -3 文件
# tail -n3 文件

# wc -l 文件 //统计文件有多少行


# cat 文件 | wc -l  //cat的数据流入管道,wc统计管道数据的行数

$ '|' //管道 ,管道最核心的意义在于:可以级联多条命令,让命令和命令组合,来完成批量化文本处理任务,做数据的不断加工
//从左到右一次执行,结果由最后一条命令输出




//时间

# date //linux时间
# date +%Y-%m-%d_%H:%M:%S //格式化输出时间
# date +%s //输出时间戳  -- 格林尼治时间  --因时区问题,显式为8:00
# date +%Y-%m-%d_%H:%M:%S -d @时间戳  //将时间戳转为格式化输出

//
日历  calendar  [ˈkælɪndər]
# cal //显式当前月份日历
# cal 2023(年份) //显式该年的所有月份
# cal -3  // 显式本月和前后月  //*只有命令选项只有-3


# sort 文件  //按行的ascii比较,默认是升序 -- 排序后打印
# sort -r 文件 //降序 r为reverse
# sort 文件 | uniq //排序后去重 -- 单纯去重没有用
//sort - uniq都不会修改源文件



//搜索三件套
# find 路径 -name 文件  //在路径底下搜索文件 -- 第一次搜索很慢,第二次会快,因为linux会把常用搜索缓存起来  

# which 指令  //搜索指令所在目录 

# whereis 文档/程序/压缩包...  //搜索各种

$ linux基本所有指令都在 /usr/bin下
$ linux指令是可执行程序(绿色),就是平时写的C语言代码编译好的可执行程序 --指令,程序,工具没本质区别

# alias 别名='命令+命令选项组合'  //给命令+选项起别名
$ 为什么我们ls时有些文件会带颜色: 因为ls是'ls --color=auto的'别名

//文本 行过滤工具 
# grep '关键字' 文件 //过滤出文件中具有关键字的行 -- grep为文本行过滤工具
# grep -n '关键字' 文件  //带上行号

# >文件  //清空文件内容 --输出重定向,覆盖式,覆盖空进去,所以清空

# grep -v '关键字' 文件  //过滤掉文件中具有关键字的行 -- 不显示有关键字的行
# grep -i '关键字' 文件  //忽略大小写过滤
// grep -ivn '关键字' 文件     //组合命令
//cat 文件|grep  '关键字' 文件 //管道级联组合
注意:grep尽量带''或"",特别是有空格或其他符号

# top //任务管理器linux   


//zip打包 并压缩
# zip 打包的包名.zip  要打包的文件/目录     // 把文件打包 -- 只打包当前(1个/最外层)目录或文件
# zip -r 打包的包名.zip  要打包的文件/目录  // 递归打包文件/目录

//zip解包
# unzip 要解包的文件(xxx.zip)

# unzip 压缩文件 -d 路径/目录  //解压缩到指定目录 d:dir

# zip 文件.rar 文件 // 没问题 后缀名可以为7z,rar,zip,解压也可以,用unzip --- 猜测是压缩算法是zip,后缀格式兼容或无所谓

//zip安装
# yum install -y unzip zip //安装 zip和unzip,可以把zip和unzip分开写 -- 安装多个包时用空格分开

//4

# ls [命令选项] 目录/路径 //以列表形式显式该目录

# rm * -rf       //把当前目录的所有文件删掉 -- 不带路径默认为当前目录 --  '*' ,linux通配符,代表所有文件
# rm *.后缀 -rf  //把带有相同后缀的文件全部删除
$ 通配符:可以匹配上任意个数的任意字符



# tar -czf  档名(名.tgz) 文件 //c为create:创建一个新的归档文件,即打包; z为使用gzip压缩,即压缩; f:使用档名,即紧接档名(新名),不能再接命令选项 //一般建议把f放最后,档名一般为tgz后缀
# tar -xzf  压缩文件  //x:解压指令(只需把czf的c换成x),准备解包; z:曾经压缩过,现在需要解压;f:文件名
$ tgz:  t:tar  gz:gzip//压缩:gzip压缩算法 //.tar.gz 的缩写 .tgz

# tar -ztvf 压缩文件  //查看压缩包内但不解压 //z为解压(解压一些头部信息)或者检查是否gzip , t--list为查看指令  v--verbose为列出更详细信息  f为归档文件名

//有的平台上命令选项可以不带'-'

# tar -xzf 压缩文件 -C 目录/路径  //解压到指令路径/目录  //-C和zip的-d含义一样 -- 默认都是解压到当前路径

$ linux支持多行输入 ,只要在结尾输入反斜杠\回车即到下一行 -- 不需要空格等,空格也算命令中

//热键:ctrl+C :终止在影响命令行输入的程序,回到命令行输出

# bc //linux中的计算器
# echo "1+2*3/2" | bc //管道组合运算 -- 结果为4

# uname  -a //查看所有信息 // Linux iZ7xv3f3wlfxwevnefn5drZ 3.10.0-957.21.3.el7.x86_64 #1 SMP Tue Jun 18 16:35:19 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux
//linux版本 3.10.0;  发行版:el:centos 7;  架构:x64;  

# uname -r //查看软硬件体系结构  //软件体系结构3.10.0-957.21.3.        硬件体系结构:  el7.x86_64

# cat /etc/redhat-release  //查看linux的商业化发行版 -- centos是redhat公司的一款免费系统

# exit //退出linux

$ ctrl+d //退出//通常代表着：『键盘输入结束(End Of File, EOF 或 End OfInput)』的意思；另外，他也可以用来取代exit

$ 在输入框按上或按下可以翻动历史命令

$ ctrl+r  //搜索历史命令

# history //显式最近1000条命令
# history > 文件 //把命令保存到文件中

# reboot //重启linux 
# shutdown [命令选项] //关机  -- 云服务器不关机,关机要去后台重启

// 命令输入的地方叫做:  命令行 /    CLI/命令行界面

$ Shell的最简单定义：命令行解释器（command Interpreter）主要包含： -- shell的感性理解
   .将使用者的命令翻译给核心（kernel）处理。同时，将核心的处理结果翻译给使用者
   .保护操作系统 -- 防止用户执行非法指令
   .执行命令会创建子进程进行执行
//我们平常的命令主要是通过shell来和linux内核交互,shell帮我们解释命令给kernel -- shell命令
//shell是一个程序/命令 :/usr/bin/bash ,即bash.  我们链接上服务器时会自动关联上shell程序 -- bash也是一个可执行程序,C语言写的
//shell是linux的外壳程序,是软件层,命令行

// shell是适配程序,将内核适配后提供给用户合适的接口 -- 
$ shell是所有外壳程序的统称,linux的内核程序是bash ,统称shell


//权限
$ 权限的概念:权限 = 人 + 属性
# 

$ 权限是约束普通用户的,超级用户不受约束 ,想看就看,想改就改

$ linux的文件属性
 - --- --- ---  
 - rwx rwx rwx


$ linux下文件类型不用后缀区分文件类型,而是用文件属性中的第一列的一个字符区分文件类型
// 文件类型:   
// '-'是普通文件 ,包括文本文件,可执行文件,归档文件(压缩包)等   
// 'd'是目录
  ---------------------
// 'b':块设备,block,如磁盘
// 'c':字符设备,如键盘,显示器
// 'p':管道文件,
// 's':网络socket文件
// 'l':链接文件,link


$ linux虽然不以后缀区分文件类型,但是可以给人看,
// a.我们可以使用后缀名
// b.我们把后缀当作文件名的一部分
$ linux不以后缀区分文件类型是linux操作系统的事,我们的程序可以使用后缀来识别文件
$ linux程序与后缀无关,改成什么名都能执行.但是linux程序不一定能识别后缀不符合的文件,因为linux程序也是人写的
//即:操作系统以文件类型区分,用户程序可以以后缀区分文件.互不影响



//超级用户
# su 任何用户 //切换到任何用户,无需密码

//普通用户 
# su  // 切换到超级管理员.需要输入密码 //在同一个bash下进行身份切换
# su - //以root身份重新登录,
# su 同级用户 //切换到同级用户,需要输入密码
//su:switch user

$ ctrl+d是登出用户,用户可以su其他用户,套娃. 登出时按登入顺序依次退出 -- 栈结构

# sudo 命令 // 普通用户单条指令提权
//会有错误aaaa is not in the sudoers file.  This incident will be reported.//以后解决



//角色划分

1.文件拥有者

2.文件所属组

3.文件的other(其他人) :如果不是拥有者或所属组,自动识别成other -- root也会被识别成other,但是不能影响root的霸权

文件信息示例:
:    -          rw-         rw-         r--         1        chj           chj           0       Sep 6 20:47     test.txt
:文件类型   拥有者权限  所属组权限    other权限          文件拥有者     文件所属组    文件大小      日期          文件名

文件权限:   -- 文件自身具有权限属性
r -- 可读 -- 补充：可查看目录内文件
w -- 可写 -- 补充：目录内可新增、删除文件
x -- 可执行
- -- 该位置没有权限

$ 文件权限如果存在则显式对应位置的相应字符(rwx),没有则为'-'

$ 由于权限 = 人+属性,,要修改文件的权限,要么更改人,要么更改属性 -- 默认是文件的拥有者和root可以更改


//更改权限

//增加
# chmod u+r 文件 //Change Mode ,ch:change mod:mode //u代表拥有者user,+代表添加权限,r代表读权限;即给拥有者添加读权限
# chmod g+w 文件 //Change Mode ,ch:change mod:mode //g代表所属组group,+代表添加权限,w代表写权限;即给所属组添加写权限
# chmod o+x 文件 //Change Mode ,ch:change mod:mode //o代表其他人other,+代表添加权限,x代表写权限;即给其他人添加可执行权限

//移除
# chmod u+wx 文件 //u代表拥有者user,+代表添加权限,wx代表写和可执行权限;即给拥有者添加写和可执行权限
# chmod g+rx 文件 //g代表所属组group,+代表添加权限,rx代表读和可执行权限;即给所属组添加读和可执行权限
# chmod o+rw 文件 //o代表其他人other,+代表添加权限,rw代表读和写权限;即给其他人添加读和写权限

//权限顺序不影响,如 wrx,xrw,rxw...

//组合
# chmod o-rwx 文件 // 去掉o的rwx权限 '-'代表移除权限
# chmod u+x,g-w,o+w,u-x 文件 //组合增删权限,以逗号分隔

//所有+组合
# chmod a+x,a-w 文件  //给所有用户增加/删除权限 //a(all)代表所有用户

//默认,所有
# chmod +r 文件 //给所有用户ugo加上读权限 //



//二进制/八进制表示
$ 权限的每一个选项位,如果有对应权限则为1,如果没有则为0. 由此如果一文件拥有者权限为rw-,则二进制表示为110
$ 有三个用户组,每个用户组对应3个二进制位,这3个二进制位可以合并成一个八进制,即每3个二进制位为1个八进制,总共有9个二进制,则共有3个八进制位.
//设某文件权限为 110 110 100,则八进制为 664

//八进制更改权限
# chmod 000 文件 //移除所有权限
# chmod 664 文件 //等价与110 110 100.//等价于chmod u+rw,g+rw,o+r 文件
# chmod 777 文件 //添加所有权限


$ sudo 命令 //命令提权,是以root身份执行,并不单纯是用户具有root权限 -- 需要在linux中把该用户添加到信任列表才能sudo



//更改所有者“chown是change owner的缩写//所有者
//更改所有组  chgrp是change group的缩写

$ 只有高级用户能强制给给低级用户文件,即root和能sudo用户

$ sudo输入密码后,短时间内再次使用sudo不需要密码 -- 方便人操作 --一般是15分钟以内

# sudo chown 别的用户 文件         //把文件所有者改为别的用户
# sudo chgrp 别的组  文件          //把文件的所有组改为别的组
# sudo chown 别的用户:别的组 文件  //同时修改用户和组




//file:查看是什么类型文件
# file txt文件 //test.txt: ASCII text
# file 目录//test.txt: ASCII text
# file C可执行文件//a.out: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.32, BuildID[sha1]=8261fb1b71b64a95f1a5f4be1559f4da3b0e339e, not stripped
# file .c文件//test.c: C source, ASCII text
# file tgz归档文件 //test.tgz: gzip compressed data, from Unix, last modified: Thu Sep  7 09:52:44 2023
$ 命令选项
-c 详细显示指令执行过程，便于排错或分析程序执行的情形。
-z 尝试去解读压缩文件的内容。



//目录权限
//r:查看,
//w:创建,移动...更改文件
//x:进入目录
//没有权限:permission denied


//centos默认权限
$ 文本文件的默认权限是664 rw-rw-r-- //可查看,可修改,可执行
$ 目录文件的默认权限是775 rwxrwxr-x //可查看,可增/删文件,可进入目录

$ 不同操作系统默认权限可能不一样

$ linux 权限分为
1.起始权限  -- 系统设定的,文本文件起始权限是666(没有可执行x),目录是777(都有) 
2.最终权限(系统角度)/默认权限(用户角度)

$ 权限掩码/umask:在起始权限中,去掉umask中出现的权限,不能影响其他权限的码 -- 用于系统更好的控制文件权限
// 掩码就是一串二进制数字,可以将源码与掩码经过按位运算或逻辑运算得出新的操作数

$ linux掩码有4位(八进制),最左边一位目前用不到,现在只使用后三位 -- 默认为0002
# umask 0002 // 修改掩码为0002 -- 掩码可以修改

最终权限 = 起始权限 & (~umask)


$ 异或 和 取反与 不等价 -- 容易出现相等的巧合
比如 3 ^ 4 = 7
二进制是 00000011 ^ 00000100 = 00000111
3 &~ 4 = 3
二进制是00000011 &(~ 00000100 )=00000011 &11111011=00000011=3


//粘滞位
//背景:linux中有共享目录,被所有普通用户共享,用来保存普通用户产生的临时数据
//linux下家目录只对自己开放，其他人无法访问（rwx --- ---/700） -- 由于不同用户之间需要交换数据,因此有了共享目录
$ 共享目录通常由root提供,任何人访问的身份都是other

$ 粘滞位的功能，限制目录内的文件只有文件拥有者和root可以删除 -- w目录有增/删文件功能,t是限制一部分

//一般情况,别人进不去我的家目录,别人删不掉,所以我的文件很安全.但是在共享目录下,如何防止被别人删除文件就很必要了

//粘滞位 -- 为了让大家共享文件,且不让其他人随便删除别人的文件 -- 提出了粘滞位

$ 粘滞位只能给目录添加 -- 一般对共享目录添加.  
$ 且只加到other的x位上 -- 可执行权限x对目录来说没用
# sudo chmod +t 目录 // 给目录添加粘滞位,a+t,+t都一样

$ 增加粘滞位的目录内的文件只有文件拥有者和root可以删除/目录的所有者也可以删除

$ 目录的w权限还有删除文件的功能

$ 粘滞位一般都在rwx的基础上添加


ls/cd/pwd/whoami/touch/mkdir/rm/rmdir/bc/cat/less/more/nano/date/wc/grep/head/tail/zip/unzip/tar/clear/cal/man/echo/tree/find/which/whereis/file/
cp/mv/chmod/chown/chgrp/sort/uniq/gcc/su/sudo/top/stat/uname/alias/umask/adduser/passwd/userdel/history

"重定向>,>> " ,  "管道|" ,    "  ~ , - " ,    "家目录"  , "文件类型" , "目录权限" ,"umask" ,"粘滞位" ,"权限" 

//



//yum -- 应用商店  -- 仓库

软件包名称: 主版本号.次版本号.源程序发行号-软件包的发行号.主机平台.cpu架构. 
"x86_64" 后缀表示64位系统的安装包, "i686" 后缀表示32位系统安装包. 选择包时要和系统匹配.
"el7" 表示操作系统发行版的版本. "el7" 表示的是 centos7/redhat7. "el6" 表示 centos6/redhat6.
最后一列, base 表示的是 "软件源" 的名称, 类似于 "小米应用商店", "华为应用商店" 这样的概念.

# yum list //列出yum所有程序 -- 软件名-版本号-@提供者

# yum search 关键字 //匹配有关键字的程序  -- 不好用

# yum list | grep 关键字 //好用

$ 版本中带el就是centos ,el7就代表centos7
//x86:架构 x86_64:x86架构64位系统

$ ctrl+Z :终止程序 -- 有些程序ctrl+C终止不了

//安装 
# yum install 程序名(严格匹配) //安装程序 ,需要确认安装
# yum install -y 程序  //直接安装到位,不需要确认

//卸载
# yum remove 程序名 //卸载程序,需要确认卸载
# yum remove -y 程序名 //直接卸载

$ 程序sl:一个火车动画

# 软件仓库内内置了各个软件的下载地址/配置文件 
//yum的配置文件 -- yum源

$ yum源位置  /etc/yum.repos.d/下

$ centos的基础yum源: CentOS-Base.repo
$ 还有 epel.repo

$ //前面带"$"符号的单词表示这个单词是宏,会被替换掉

//更新yum源
1.备份原来的yum源 CentOS-Base.repo
2.wget 新的yum源 
3.mv 重命名成为 CentOS-Base.repo
4.yum clean all //清空缓存 
5.yum makecache //生成新的缓存

//可能在扩展yum源中的软件安装
1.# sudo yum install -y epel-release //根据base_yum源去找到匹配的yum源
2.# sudo yum install -y  

//复习->


//软件包和软件包管理器 -- 类似于App与应用商店
//软件包是已经由源代码编译好的可执行程序,包管理器能方便得获取到软件包







//5

//vim是vi的升级版本,vi有的vim都有,现在都使用vim

//集成开发环境/IDE :VS2019  //特点是功能齐全,把所有功能都集中在一起,一个软件能所有工作

//vim就是一个单纯的编辑器
//vim

$ vim是一款多模式的编辑器 -- 有各种模式 -- 常用就3-5种
1.命令模式(vim默认打开就是)
2.插入模式
3.低行模式
4.替换模式
5.视图模式
...

//vim命令
{

$ 任何模式按esc都能回到命令模式,命令模式能进入任何模式


$ 命令模式下按shift+:进入低行模式
// 低行模式中,w为write写入/保存,q为退出,组合命令wq为保存并推出 --- 如果文件被修改,则必须要w命令
// 低行模式,1.set nu为显示行号,nu为number  2.set nonu 为关闭行号
// 低行模式中 /关键字 为搜索 ,搜索模式中n向下匹配,shift向上匹配
// 低行模式中,!为强制,w!为强制保存 wq!为强制保存并退出
:x	保存并退出，同 :wq
:x!	强制保存并退出，同 :wq!
:
// 低行模式中,!空格+linux命令 为执行linux命令


// 低行模式中,vs什么都不加会打开多一份相同的文件,内容同步 -- 光标在哪里,则操作的就是谁
// 低行模式中,vs+文件名会打开多个文件多屏操作,如果文件不存在也能打开,不修改退出则不会生成新的文件,保存则会生成新的文件
//:vs为并列方式打开多个文件
//:sp为上下行方式分开多个文件
//ctrl+w+q  或:close  为关闭当前窗口.. 

ctrl+w+w循环切换
ctrl+w+方向,一次切换,不能循环


Linux vim 文本替换 %s/原文/替换文本/g
{
语法:%s///g
ESC:%s/origanl/new/g  --grammar:语法?

%s 表示替换文本。
origan 表示原文
new 表示新的内容
/g 表示全文替换，如果仅替换第一个则不需要/g

需要注意如果要替换的内容中包含特殊含义的自负，需要使用转义符转义

————————————————
版权声明：本文为CSDN博主「Drifting Kern」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_43740223/article/details/119925821
}

$ 命令模式下按i进入插入模式:光标不动,往光标前面插入
$ I	从目前光标所在行的第一个非空白字符处开始插入
$ 命令模式下按a进入插入模式:光标往后退一格,往光标前面插入
$ A	从目前光标所在行的最后一个字符处开始插入。
$ 命令模式下按o进入插入模式:往下插入一行并光标进入行首
$ 命令模式下按shift+o进入插入模式:往上插入一行并光标进入行首
$ 命令模式下按s进入插入模式:删出当前光标所在字符后光标不动,进入插入模式,往光标前面插入
$ 命令模式下shift+r 进入替换模式 ,输入会替换掉原有字符
$ 命令模式下按shift+s / cc清空当前行进入插入模式
$ 命令模式下按ZZ/shift+zz快速保存并退出
$ 命令模式下按Ctrl+Z 生成swap临时文件并退出
$ 命令模式下按.可重复上一次操作
$ 命令模式下按shift+q可以进入低行模式(更近的键盘操作,Qq退出)

$ 操作复制器:
qa            #打开操作记录器，将后续动作放在记录器a中;（左下角会显示一个【记录中@a】提示符号）
q             #关闭记录器;           --->备注：此时仍处于normal模式
执行操作
n@a // 执行n次操作,不带则为1次

Vim生成递增递减的数字
ctrl+a        #数字自加一次;         --->备注：如果想生成间隔n个数跳跃递增，则先按数字，再按下ctrl+a;
ctrl+x    递减

$ 命令模式指令:
// yy 复制 , nyy复制光标以下n行 
//yw	复制光标所在字符右边的单词
// p 粘贴 ,np粘贴n行,粘贴到下一行,粘贴当前光标所在的下一行,并且光标移动到一行     \ // 100p 粘贴100行 -- 
// P 往上/左粘贴
// u 撤销undo 
// ctrl+r 对撤销进行撤销/撤销命令u所作的操作
// dd行剪切,ndd往下剪切n行  // 如果只dd不粘贴,则是删除
// x 删除光标当前所在位置 ,nx 删除光标连续的n个单词
// shift+nx 往前删除

//dG 删除当前及以下所有行
//d$/D	删除从光标所在字符到行尾的数据
//d0	删除从光标所在字符到行首的数据

// 光标移动
h: 左, h在最左侧
ctrl+h:可以退行的左
j: 下, jump
k: 上, king
l: 右, l在最右侧


vim 可视化选择
v	字符选择，会将光标经过的地方反白选择 -- 再按一次取消
V	行选择，会将光标经过的行反白选择
ctrl+ v 块选择 -- 绿色也会删掉
d	将反白的地方删除掉。(d)elete
D	将反白的地方经过的行都删除掉。(D)elete
y	将反白的地方复制。(y)ank
p	将刚刚复制的区块，在光标所在处贴上。(p)ut
u	将选中部分的字符全部改为小写
U	将选中部分的字符全部改为大写
>	将选中部分右移（缩进）一个 tab 键规定的长度（CentOS 6.x 中，一个tab键默认相当于 8 个空白字符的长度）
<	将选中部分左移一个 tab 键规定的长度（CentOS 6.x 中，一个tab键默认相当于 8 个空白字符的长度）

//linux批量化处理命令 -- 块模式
# ctrl+v+选择行+I,输入符号,esc // 批量化添加,即块添加,一般用于注释
# ctrl+v+选择块+d  //块删除

// n+移动 :移动n行或n位

//vim在退出前,可以撤销和undo.保存也可以
//vim在退出后,之前的修改不能再撤销

f<char> //f+字符==移动到该字符,shift是往前移动 -- 尽当前行

//shift+g移动到文本尾行
//gg 移动到文本首行
//n+shift+g 移动到第n行
//shift+$ 定位到行尾
//shift+^ / 0  定位到行首

//w以单词/字符为单位向右移动
//nw 移动n个单位
//b以单词/字符为单位向左移动(back)
//nb 移动n个单位
//e 移动到单词尾,空格前
//E 移动到单词尾的符号处,空格前

%	光标移动到匹配的字符(括号什么的一对符号)处。(),[],{},<>。%: goto match

+	光标移动到下一列的非空白字符  -- 慢慢移动
-	光标移动到上一列的非空白字符
[[ / ]] / (( /)) // 快快移动

//shift+~ 大小写切换
//r 替换光标所在字符, nr 连续换n个 // 按r后输入需要替换的字符
//shift+r 进入替换模式 ,输入会替换掉原有字符

1、翻整页命令
Ctrl + f 键 （f 的英文全拼为：forward）
Ctrl + b 键 （b 的英文全拼为：backward)

2、翻半页命令
Ctrl + d 键 （d 的英文全拼为：down）
Ctrl + u 键 （u 的英文全拼为：up）


//卡死可能的解决方案--ctrl+q
}

vim插入模式
{

$ #为注释



}

# yum install -y vim //安装vim

//vim打开文件
# vim 文件 //用vim打开文件

# vim // 直接打开vim -- 测试是否安装vim -- 目前基本上所有云服务器默认都装了vim

$ vim的配置文件每个用户有一个, linux配置文件所有用户共享

$ vim的配置文件名字为.vimrc
// vim配置文件用双引号的其中一个"来注释
// vim的配置一行命令就是一个配置

$ vim的插件目录名字为.vim


$ 自动化配置命令
curl -sLf https://gitee.com/HGtz2222/VimForCpp/raw/master/install.sh -o ./install.sh && bash ./install.sh


$ 不适用table制表,使用空格最好,不同平台table占位不一样











//7

//linux编译器
GCC编译C语言
G++编译C++

gcc命令选项
-E 只激活预处理,这个不生成文件,你需要把它重定向到一个输出文件里面
-S  编译到汇编语言不进行汇编和链接
-c  编译到目标代码
-o 文件输出到 文件
-static 此选项对生成的文件采用静态链接
-g 生成调试信息。GNU 调试器可利用该信息。
-shared 此选项将尽量使用动态库，所以生成文件比较小，但是需要系统由动态库.
-O0
-O1
-O2
-O3 编译器的优化选项的4个级别，-O0表示没有优化,-O1为缺省值，-O3优化级别最高
-w  不生成任何警告信息。
-Wall 生成所有警告信息。


C语言/GCC

$ gcc默认是C89
# gcc ... -std=c99  //修改GCC执行C99标准
//gcc/g++默认生成的可执行程序是release版本
# gcc ... -g        //修改为debug版本


$$ 程序的翻译
1.预处理(头文件展开(合并到成我们的代码),条件编译,宏替换,去注释)
//预处理后还是C语言
$ -E 执行到预处理结束就停下 
组合 # gcc -E 源文件 -o 文件.i  //将预处理后的文件重命名到新文件,一般为.i文件

2.编译 -- 将C语言编译成汇编语言
# gcc -S .c文件 //从头开始,知到编译结束后停下  -- 默认自动生成.s文件 
# gcc -S .i文件 //从预处理后的文件开始         -- 默认自动生成.s文件 
# gcc -S .i/.c文件 -o 新文件  //自定义.s文件
$ .s文件是汇编文件

3.汇编 -- 将汇编语言翻译成可重定位二进制文件 -- 该二进制文件不可被执行bin/obj..
// 只翻译我们实现的代码 -- 即我们调用的代码不做处理
# gcc -c .c/.i/.s文件     //生成.o文件 -- 二进制文件  -- 对等windows的.obj文件
# gcc -c 文件 -o 重命名  // 自定义.o文件
$ 一般情况,有几个源文件,就有几个.obj文件

4.链接 -- 将程序和对应的库链接起来
//将我们自己形成的.obj文件和对应的库文件某种合并,形成可执行程序
# gcc .o/.c/... 文件 //链接
# gcc .o文件  //链接 -- gcc会自动识别 ,不需要命令选项了

$ 记忆: 命令选项为ESc键 ,生成的文件为.iso

//gcc
# gcc -o 命名 源文件 // 编译源文件并命名 , 只要命名在-o后面即可
# gcc 源文件 -o 命名 //

//宏可以没有值

//条件编译  -- 就是一个宏版本的if-else
#ifdef 宏    --如果该宏被定义,则执行 -- #define (宏)关键字..
   //...
#else        --否则执行这条 
   //...
#endif

//ifndef 是如果宏没有定义 ,即ifdef的否定

# ldd 可执行文件 //查看看可执行文件链接的库








$ linux的C语言头文件库位于 /usr/include


$ 库分两种 -- 库也是文件  -- linux下特有的
1.静态库: libXXXXXXXX.a

2.动态库: libXXXXXXXX.so

$ linux识别库:去掉前缀lib,去掉后缀,得到的就是库的名字,例如库/lib64/libc.so.6 -> libc-2.17.so的名字为c-2.17 <--> C语言的C标准库

$ windows下静态库为.lib文件 ,动态库为.dll文件 -- 两系统库体系不一样,原理一样

$ 代码运行必须要有语言的头文件和库文件

$ 证明linux的大部分命令是c语言写的 -->
# ldd ../命令 //看链接的库是否有c语言的c标准库 -- 前提是动态链接
//not a dynamic executable -- 非动态链接提示

// 链接是由编译器完成的,编译器负责寻找库,并链接上

$ 动态库 == 共享库
//只有只读属性 ,一般一个系统里只有1份

$ 动态链接:把库所在的地址拷贝到程序里
$ 静态链接:把程序需要的库直接拷贝到程序中

$ 动态库:专门让编译器,对用户程序进行动态链接的
$ 静态库:专门让编译器,对用户的程序进行静态链接的

$ 静态库的优点:健壮性强. 缺点:程序体积,内存/磁盘开销大,拷贝速度慢
$ 动态库的优点:程序体积小,节省空间,速度快  缺点:不够安全

$ 静态库VS动态库:linux默认使用的是动态链接

$ file命令和ldd命令搭配使用
# file 可执行文件  //查看可执行文件信息  -- 

//ynamically linked 动态链接
//statically linked 静态链接


$ /usr/bin/ld: cannot find -lc错误
//原因:在新版本的linux 系统下安装 glibc-devel、glibc和gcc-c++时，都不会安装libc.a. 只安装libc.so. 所以当 使用-static时，libc.a不能使用。只能报找不到libc了。
//解决:yum install glibc-static
//C++:yum install glibc-static libstdc++-static -y

$ LSB:linux中lsb是指linux标准基础，是“Linux Standards Base”的缩写，LSB是Linux标准化领域中事实上的标准，制定了应用程序与运行环境之间的二进制接口，保证了LINUX发行版同LINUX应用程序之间的良好结合。

$ ELF是linux下的可执行程序 ,对应windows的exe









// linux项目自动化构建工具make和makefile
//make是个命令,makefile是个文件(m不区分大小写,Makefile也可以)

$ makefile一般放在当前源码路径下

$ makefile是一个围绕依赖关系和依赖方法构建的自动化编译的工具

$ 创建makefile文件语法
依赖关系 //语法中 目标文件:依赖文件列表 -- 目标文件依赖于依赖文件 -- 依赖文件可以有多个,用空格分隔
    依赖方法 //语法块要求开头必须是制表符table
依赖关系
    依赖方法

$ 依赖关系中,目标文件对应的依赖文件列表可以是空

$ 多依赖关系/传递依赖关系使用栈结构(其他语法实现大多是栈结构),后进先出,--第一行依赖关系先入栈,后面依次入栈 -- 直到满足起始条件 
// 入栈过程会带着各自的依赖方法进栈

$ clean: //clean:是依赖关系,clean是目标文件,虽然他没有依赖文件.只要是依赖关系都可以有自己的依赖方法

符号学习:
1. $@ // 永远表示目标文件,依赖关系中冒号的左边
2. $^ // 表示依赖文件列表,依赖关系中冒号的右边



演示1:
out_name:src_file  //out 依赖于src
    gcc -o  out_name  src_file  //制表符开头
.PHONY:clean
clean:
    rm -f out_name  //

演示2: //传递依赖关系
out:out.o    
  gcc -o out out.o    
out.o:out.s    
  gcc -o out.o out.s -c    
out.s:out.i    
  gcc -o out.s out.i -S    
out.i:2.c    
  gcc -o out.i 2.c -E    
.PHONY:clean    //伪目标:总是被执行的
clean:                                                                              
    rm -f out     
    rm -f out.o    
    rm -f out.s

$ 使用make命令
# make //默认只执行第一组依赖关系,执行完第一组就终止 -- 执行其他依赖关系需要make+其他命令选项 / 第一条也可以加上命令选项(只有第一条可以省略)
# make clean //执行makefile中的clean语句块

//执行make命令时,会默认在当前目录去寻找makefile/Makefile文件,然后分析,处理... -- make和makefile的关系

//phony 假的 [ˈfoʊni]  -- 假执行 -- 没执行
$ .PHONY: //make命令关键字 -- 作用:"总是被执行的" -- 功能是每次都会重新执行,无论是否已被执行过
//linux提示::make: `out' is up to date. -- 意思是已经是最新的执行了 ,出现这条提示说明,make命令没有被执行,即:不是"总是被执行的"
$ .PHONY: 被
// 场景:干脆的,可以重复的,不需要开销太大的,或者必须能
--
//make是怎么检测源码有没有更新过? make通过检查源代码修改和可执行程序的生成时间来决定要不要执行,
// -- 因为同一版本的可执行程序永远是在源代码编写完成后才有的,即只要新的源代码的修改时间晚于对应的可执行程序,则说明程序不是最新的了
//扩展:vs2019下有时编译出问题,就清理项目再生成一次 -- 因为很多文件之前编译过了,编辑器不再重复编辑,这就有可能出问题,所以重新清理一下可能有效果

# touch 已存在的文件 // 把已存在的文件的所有时间都更新成最新时间 -- 摸一下就变了
$ touch后make就能再执行了

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
linux中ctrl+s是暂停终端输入 -- 作用就是不能输入了,堵塞 --[锁定终端] //此时输入的数据都缓存在缓冲区中 -- 感觉很危险
-- 通过ctrl+q恢复 -- 恢复屏幕输出[解锁终端]

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

$ sudo不能由普通用户直接执行,必须是信任的用户才可以
//用户 is not in the sudoers file.  This incident will be reported. //xx用户不在sudoers文件里,这个严重事件将被报告
$ sudoers路径:/etc/sudoers
//-r--r-----. 1 root root 4358 Dec 19  2022 sudoers //默认情况任何一个普通用户都没有权限修改,最多只有读权限 -- 只有root能修改

$ 增加信任用户:
.进入到/etc目录 ,打开sudoers文件,
.找到Allow root to run any commands anywhere所在行
.在下方找到root    ALL=(ALL)       ALL,然后复制一份在下一行
.把root改成用户名,即:用户    ALL=(ALL)       ALL



//8


1.认识\r\n
//c语言中字符分为a.可显字符(能够显示输出的) b.控制字符('\n','\t'等)
//认识换行-回车 :平常中新起一行是从当前行的位置进到下一行的行首,而计算机中,这一步其实是由两步操作完成的:1.进到下一行的同样位置 2.回到行首 (或者先回到行首再进下一行
//即 \n\r 或 \r\n
//而\n叫做换行(进到下一行的同样位置) \r叫做回车(回到行首)
// 一般编译器\n都会合并\n\r一起,实现新起一行的操作

2.缓冲区概念

\n在很多语言中具有刷新缓冲区的作用,即遇到\n会立刻将缓冲区的数据输出

//缓冲区有自己的刷新策略:
行缓冲:遇到换行符\n就刷新缓冲

缓冲区刷新方案有很多种:无缓冲,行缓冲,全缓冲..
//缓冲还有使用主动调用函数如fflush(stdout)刷新,进程退出时由系统自动刷新

\r的作用是将控制台的光标移动到行首
\r的神奇现象:如果在linux中打印一个长度小于命令提示符的数据,会发现没有打印的效果(打印的东西看不到) -- 其实就是光标移到了行首,然后命令提示符覆盖打印的数据
//发现 -- 在\r后的输出会把光标所在位置的原字符覆盖掉 -- 

凡是向显示器打印的内容都是字符,一个一个的字符输出-- putc()  -- 所以叫做 字符设备

$ 缓冲区处理方案与平台有关,不同不太不同处理方案


linux第一个小程序 -进度条

printf("  [\033[44m%-s\033[0m\r",bar);//c语言颜色为 \033[数字m "字符串" \033[0m   //0m:截至关闭颜色










$ 对于多.c文件的makefile处理
{
out:main.c prog.c    //依赖文件列表
  gcc -o out main.c prog.c   //多个.c文件                                                 
.PHONY:clean    
clean:    
  rm -f out    
} 
--C语言include""会先扫描当前文件夹再扫描其他文件夹 -- 目前都放在同一目录就可以,
--头文件在预处理阶段会自动地拷贝到c文件中,所以不用带.h文件,只要.c文件即可

$ unistd.h //linux中类似微软windows.h的库

$ man 3 //linux 的C语言手册












//git 

gitee和github区别:底层都是基于git的网站化git管理服务端

$ 查看git版本 -- 查看git是否安装
# git --version

sudo yum install -y git

# git clone 克隆地址 
//输入用户名:注册gitee/github的手机号或用户名或完整邮箱 -- 注册的账号
//账号密码

删除git仓库 // .git就是仓库
# rm .git -rf


# git add . //把当前目录下所有文件提交到暂存区
# git add [file1] [file2] ... //单独添加多个文件到暂存区 ,以空格分隔
# git add [dir] // 添加目录
# git add -A //这个命令会递归地将当前目录及其子目录中的所有更改和已删除的文件添加到暂存区。:解决add不了的问题



# git commit -m "修改信息" //提交到本地仓库  -- 提交暂存区到仓库区
# git commit [file1] [file2] ... -m [message]  //提交暂存区的指定文件到仓库区
# git commit -a  //提交工作区自上次commit之后的变化，直接到仓库区
# git commit -v //提交时显示所有diff信息
# git commit --amend -m "message" //使用一次新的commit，替代上一次提交(重做上一次commit),如果代码没有任何新变化，则用来改写上一次commit的提交信息  
// 不要随便重做 -- 把持不住



# git config --globaluser.name "提交用户名" //给别人看的
# git config --globaluser.email "提交邮箱"
# git config --list //查看提交用户和邮箱
# git config --global --list


# git status //显示有变更的文件
# git log //显示当前分支的版本历史, 查看提交日志 --按q退出历史记录列表
# git log --stat //显示commit历史，以及每次commit发生变更的文件
...

# git branch 列出所有本地分支
# git branch -r 列出所有远程分支
# git branch -a 列出所有本地分支和远程分支
# git branch [branch-name]  新建一个分支，但依然停留在当前分支
# git checkout -b [branch] 新建一个分支，并切换到该分支
# git checkout [branch-name]切换到指定分支，并更新工作区
 ...

 远程同步
# git fetch [remote]//下载远程仓库的所有变动
# git remote -v //显示所有远程仓库
# git remote -v //查看已添加的远程仓库
# git pull //取回远程仓库的变化，并与本地分支合并
# git push //上传本地指定分支到远程仓库

git clean 
...
-----------------------------------
Git常用命令大全：git命令基本用法
https://blog.csdn.net/hejinde/article/details/131229840


解决git每次提交和拉取代码需要输入用户名和密码问题
输入以下命令行：
# git config --global credential.helper store //之后等待下一次输入账户密码操作
# git push https: url
输入账号密码即可

# git rm 文件 //
# git rm [file1] [file2] ... //删除工作区文件，并且将这次删除放入暂存区
# git rm --cached 文件 //文件从暂存区域移除，但工作区保留：


$ git如果是push到别的平台则需要的是邮箱+密钥
$ git如果是push到自己的平台,则只需密码


$$ git的问题解决:

一.git删除文件后提交不了:
如果删除了文件,则命令git会提交失败,此时必须要使用命令git rm删除掉远端中刚刚在本地删除的文件,然后才能提交



//颜色.....

一般系统默认的提示符形式是：[username@host 工作目录]$ 

$ 默认命令提示符规则  # echo $PS1 //[\u@\h \W]\$
@  : #就是普通字符
\d ：#代表日期，格式为weekday month date，例如：“Mon Aug 1”
\H ：#完整的主机名称
\h ：#仅取主机的第一个名字 //主机名
\t ：#显示时间为24小时格式，如：HH：MM：SS
\T ：#显示时间为12小时格式
\A ：#显示时间为24小时格式：HH：MM
\u ：#当前用户的账号名称 //用户名
\v ：#BASH的版本信息
\w ：#完整的工作目录名称
\W ：#利用basename取得工作目录名称，所以只会列出最后一个目录
#：#下达的第几个命令
$ ：#提示字符，如果是root时，提示符为：# ，普通用户则为：$
-----------------------------------
https://blog.51cto.com/u_11566825/2063370


2.设置颜色
在PS1中设置字符颜色的格式为：
[\e[F;Bm]，其中“F“为字体颜色，编号为30-37，“B”为背景颜色，编号为40-47。颜色表如下：

[\e[F;Bm]需要改变颜色的部分[\e[0m]
开始颜色输入：[\e[F;Bm]
结束颜色输入：[\e[0m]
　　　　F　Bm
　　　　30 40 黑色
　　　　31 41 红色
　　　　32 42 绿色
　　　　33 43 黄色
　　　　34 44 蓝色
　　　　35 45 紫红色
　　　　36 46 青蓝色
　　　　37 47 白色
　　　　
设置特殊显示　
　　　　 0 OFF，关闭颜色
　　　　 1 高亮显示 //亮瞎狗眼
　　　　 4 显示下划线
　　　　 5 闪烁显示 //跑马灯 黑闪黑闪
　　　　 7 反白显示 //背景与字体颜色反过来
　　　　 8 颜色不可见
-----------------------------------
https://www.cnblogs.com/ggzhangxiaochao/p/13141437.html

//修改主机名
# sudo hostnamectl set-hostname 新名字(不能是中文)

$ 我的设置: # PS1="\e[36m\][\u@\h \W\t]\\$\[\e[0m]" //复制到相应文件中

$ 写入~/.bash_profile或~/.bashrc只对当前用户生效。
$ 写入/etc/profile或/etc/bashrc对全部用户生效

$ source 命令：常用于重新执行刚修改的初始化文件。如/etc/profile ， bash_profile， bashrc?通过 source命令 在不重启的情况下生效。//刷新
$ . 命令 //和等价于source命令,让配置文件立即生效
PS1="[\e[37;1m]  [  [\e[31;1m]\u [\e[36;1m]@ [\e[33;1m]\h [\e[35;40m]\W[\e[37;1m]  ]   [\e[33;1m]\$[\e[0m]




//GDB gdb

readelf -S 文件 //读elf格式的可执行程序的二进制文件

# gdb 文件  //backtrace
# quit或q   //退出gdb 

# gdb 有debug信息的可执行文件
# l //list -- 显示部分代码
# l+n //从哪一行开始显示
# l file:行号/函数名 //
# b 行号 //breakpoint -- 给哪行打断点
# d/delete 断点编号 //删除断点
# d breakpoints // 删除所有断点
# r // run//执行 -- 到断点处停下来
# info b //查看所有打的断点 -- 断点有编号Num,依次递增,不会循环 ,直到退出gdb
# disable Num //暂停断点
# disable breakpoint Num// 全称
# enable Num //启用断点 -- 使能
# enable breakpoint Num// 全称
# n/next //逐过程
# s/step //逐语句 --步骤 - 可能会进到库的代码 -- 所以要注意用n跳出去
# until 行号 //在函数内,指定位置跳转,执行完区间代码.直接运行到指定行 -
# finish // 运行完当前函数
# c/continue   //运行到下一个断点
# f/frame   //简写f, f 0 切换到栈0，即栈顶

# set var：修改变量的值 -- 用的情况比较少,在循环里i,j什么的可能好用

//命令中的文件是源文件,不是可执行程序 -- 可能有多个源文件,所以能带文件名 -- 

//调用函数要压栈 --  
# bt/backtrace //查看调用栈
  #0  addToTop (top=100) at gdb.c:6             //压栈
  #1  0x00000000004005bc in main () at gdb.c:22 //栈底

# p 变量 //查看当前变量的值
# display 变量 //长监视 -- 每次都会自动刷新 -- 会生成和断点一样的编号 (支持:内置类型,自定义类型,stl...)
# undisplay 编号 // 需要编号才能删除
# info display // 查看所有长监视的变量
# info/i locals // 查看局部变量的值   

---- 所有的info都可以简写成i , i+首字符可以提示语法

//指定(可带文件名)关键字打断点: #b (文件名:)关键字 //
//遇到不能打断点的地方,断点对进到不能打的下下....一行,直到遇到能打断点的位置

//breakpoint already hit 1 time //断点已经命中一次 
//no breakpoint or watchpoint //没有断点或观察点
//watchpoint //观察点 -- 没有被激活的

//gdb会自动记忆最近一次的命令 -- 回车重复上次命令 -- 如list后回车会将剩下的代码依次打印出来


//测试人员一般只要release的可执行程序
//gcc/g++默认生成的可执行程序是release版本\
# gcc ... -g  //修改为生成debug版本

# readelf -S 可执行文件 //
在Linux下，readelf -S命令用于显示目标文件或共享目标文件的节表信息。
它可以列出目标文件的所有节（section）的信息，包括每个节的名称、类型、大小、偏移量等。其中，节是目标文件中的一些逻辑段，用于存储程序的代码、数据和符号表等信息。
通过readelf -S命令，用户可以快速查看目标文件中包含的各个节的信息，有助于了解程序的结构和调试信息。此外，readelf -S命令还可以用于分析和调试程序，例如确定程序的内存映像、调试符号表等
————————————————
https://blog.csdn.net/m0_65379664/article/details/130382886

# readelf -S elf文件 | grep -i debug // -i忽略大小写,过滤出所有带debug的信息 -- 没有说明不是debug文件



// --- 9 --- 

//linux可以运行,编写各种主流语言(主要是后端语言 -- 需要部署环境 -- 很多其他语言有需要linux服务器的地方) 

一台台机器 -- 一台台冯诺依曼机
冯诺依曼体系 -- 是硬件结构  -- 目前大部分计算机,服务器都遵守冯诺依曼体系
计算机能力 -- 木桶原理(能装多少水,取决于最低的木板) -- CPU快,外设慢->内存:解决速度不匹配问题 
CPU只从内存读取数据,外设需要装入内存才能被CPU读取,运行; 寄存器很快,也可以存数据,但寄存器很贵 -- 计算机是通过技术手段打造出来的性价比产物

外设只会和内存打交道(数据层面)
-- 外设有些控制信号可以直接和CPU沟通
//不考虑缓存情况，冯诺依曼体系的CPU能且只能对内存进行读写，不能访问外设(输入或输出设备)

因为有内存存在,我们可以对数据做预加载(从外设取到内存),这时如果CPU需要进行数据运算的时候直接从内存中取,就不需要再访问外设了;

通过内存 -- CPU可以先将数据存在内存中,合适时可以一次写入到外设 -- 减少与外设沟通次数,减少I/O次数,提高效率


数据(传输过程)流向是由硬件结构决定的

操作系统是软件 -- 一款对软硬件资源管理的软件
    硬件局限性于 -- 控制不了数据流向(调度)

操作系统如何对硬件做管理
1.管理者和被管理者可以不直接沟通 -- 不需要直接沟通
2.管理者和被管理者没有直接沟通,那如何进行管理
管理的本质:对被管理对象的数据做管理 -- 决策
3.管理者如何拿到被管理者的数据?
先描述,再组织 --  描述:语言  -- 组织:数据结构  -------> 对管理做建模

操作系统 -- (硬件)驱动 -- 硬件(软件)
每个硬件都有对应的硬件驱动,操作系统通过硬件驱动获取到信息,操作系统其抽象(面向对象)提取,构建成一个设备结构体,然后构建结构体结点,然后以某种数据结构管理起来

操作系统为什么要对软硬件资源做管理? 计算机本质是为人服务,操作系统管理好能更好的为人提供服务
    操作系统对下通过管理好软硬件资源(手段),对上给用户提供良好(安全,稳定,高效,功能丰富等)的执行环境(目的)

操作系统也能对软件做管理 -- 和硬件类似,管理软件可以直接管理, 管理硬件需要驱动

操作系统能给我们提供非常良好的服务,并不代表操作系统会相信我们.相反,操作系统不相信任何人!!

系统调用 -- 在linux中就是操作系统提供的C函数 
-- 系统调用使用成本很高(需要懂系统),所以在此之上,又有了 GUI 或  shell和工具集   或编程语言和库函数(封装了系统调用); (应用层)其他高级应用再基于外壳之上..

(系统调用一定是接口,接口不一定是系统调用)

目前我们写的代码基本都是应用层代码


硬件无法知道CPU需要自己什么信息,无法提前将数据加载进内存中 -- 操作系统负责这方便工作,操作系统通过算法实现预加载 -- 局部性原理
加载:操作系统把数据从外设到移动内存

库函数大部分时对系统调用的封装.  -- System Call
   不是所有库函数都是系统调用的封装,有些库函数没有访问硬件,并不是系统调用 

库函数很多是系统调用的组合后提供更丰富的功能 -- 提高开发效率



/////////////进程/任务  -- task
任何启动并运行程序的行为,都是由操作系统帮助我们将程序转换成进程 -- 进程:完成特定的任务

进程控制块:PCB(win) / task_struct(linux) -- 结构体结点/内核数据结构 -- 提取了进程的所有属性


task_struct是PCB的一种
在Linux中描述进程的结构体叫做task_struct。task_struct是Linux内核的一种数据结构，它会被装载到RAM(内存)里并且包含着进程的信息。

task_ struct内容分类
{
标示符:     描述本进程的唯一标示符，用来区别其他进程。
状态:       任务状态，退出代码，退出信号等。
优先级:     相对于其他进程的优先级。
程序计数器: 程序中即将被执行的下一条指令的地址。
内存指针:   包括程序代码和进程相关数据的指针，还有和其他进程共享的内存块的指针
上下文数据: 进程执行时处理器的寄存器中的数据[休学例子，要加图CPU，寄存器]。 I／O状态信息: 包括显示的I/O请求,分配给进程的I／O设备和被进程使用的文件列表。
记账信息:   可能包括处理器时间总和，使用的时钟数总和，时间限制，记账号等。
其他信息
}

linux中所有运行在系统里的进程都以task_struct链表的形式存在内核里。

进程 = 进程控制块+内存中数据/代码
     = 内核关于进程的相关数据结构+当前进程的代码和数据

进程管理:管理PCB

操作系统对进程的管理 == 描述+组织 == 对进程控制块的数据结构进行CRUD 


无论用户需求是什么,都是操作系统对内存的部分数据作描述和组织

文件 = 内容+属性,但PCB中的属性与文件中的属性有关系但关系不大,PCB中主要是维护由操作系统创建的一些数据.有关系地方是在需要获取文件属性时需要


//linux 进程命令

用户级工具ps
# ps axj | grep myprocess //查看进程 -- 只查看myprocess进程
# ps axj | head -1 && ps axj | grep myprocess //先管道得到ps axj的第一行(各属性名称), 查看myprocess进程  //管道|优先级比&&高
# ps axj|head -1 && ps axj|grep myprocess |grep -v grep //过滤掉带grep这行 , ps axj|grep后会多一个无关项,过滤掉好看一点

$ 测试执行程序是不是进程 - 执行同一个程序两次 -- 查看是否是同一个可执行程序的两个不同的进程
[chj@expiration1102 1.2进程学习 16:52:10]$ ps axj|head -1 && ps axj|grep myprocess |grep -v grep
 PPID   PID  PGID   SID TTY      TPGID STAT   UID   TIME COMMAND
19970 20647 20647 19970 pts/3    20647 S+    1002   0:00 ./myprocess
20716 20738 20738 20716 pts/4    20738 S+    1002   0:00 ./myprocess
//PID是每个进程的编号

# ps aux | head -1
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND



# ls /proc   // 保存进程属性的目录 -- 内存级的文件系统(磁盘上不存在)

/proc内以数字命名的目录是进程信息文件,其名字就是进程的PID

进程文件内其中有两行数据 -- 目前能看懂的,可以证明是执行的程序的进程
lrwxrwxrwx 1 chj chj 0 Sep 14 21:11 cwd -> /home/chj/git_repositories/linux_code/1.2进程学习
lrwxrwxrwx 1 chj chj 0 Sep 14 21:11 exe -> /home/chj/git_repositories/linux_code/1.2进程学习/myprocess

如果中断程序运行,则该进程文件会直接删除
ls: cannot open directory .: No such process //正在访问的目录也会删除
-bash: cd: ..: No such file or directory //cd .. 也执行不了


$$$$  学习第一个系统调用
pid_t getpid(void)  // 获取进程的PID  -- 谁调的getpid就返回谁的pid
pid_t就是int
头文件为#include<unistd.h> 和#include<sys/types.h> //包含两个才不会报错
返回值为进程PID

pid_t getppid(void) //获取父进程id  
$ 在测试父进程与子进程过程中,发现每一次重新执行程序,子进程PID改变,但父进程PID不会改变. -- 父进程是谁?  -- bash
在通过ps axj|head -1 && ps axj|grep 父进程PID |grep -v grep 查看后发现,父进程是bash
1.bash命令行解释器,本质上也是一个进程
2.命令行启动的所有程序,最终都会变成进程,而该进程对应的父进程都是bash -- (对应上之前学习的bash,bash执行的命令都交给子进程去执行)


$ 杀进程命令
# kill -9 PID  // 子进程,父进程,bash都能杀
//杀掉bash后,所有命令都无法正常执行了,所以为了bash安全,bash通过创建子进程方式执行命令
--- linux中没有母进程概念

$$$$ 如何创建子进程 ?
{
系统创建进程有windows打开可执行程序,linux:./可执行程序

$ 创建子进程函数
pid_t fork()         //叉子
头文件 #include<unistd.h>
返回值:
On  success,  the  PID of the child process is returned in the parent, and 0 is returned in the child. 
On failure, -1 is returned  in  the  parent,  no  child process is created, and errno is set appropriately.
成功后，在父进程中返回子进程的PID，在子进程中返回0,父进程返回>0的数。失败时，在父进程中返回-1，不创建子进程，并适当设置errno。
效果:父子进程代码共享，数据各自开辟空间，私有一份（采用写时拷贝）

fork在返回时,父子进程都有了,分别在父子进程中ruturn,父进程中return>0,子进程中return 0,总共return两次.返回时发生写实拷贝 -- 看进程地址空间

程序:
printf("AAAAAAAAAAAAAAAAAAAAAAA; pid:%d; ppid:%d; \n",getpid(),getppid());
pid_t ret = fork();                                                                                                                   
printf("BBBBBBBBBBBBBBBBBBBBBBB; pid:%d; ppid:%d; ret:%d; &ret:%p; \n",getpid(),getppid(),ret,&ret);
结果:
AAAAAAAAAAAAAAAAAAAAAAA; pid:23641; ppid:23234; 
BBBBBBBBBBBBBBBBBBBBBBB; pid:23641; ppid:23234; ret:23642; &ret:0x7ffc3c8461fc;  //创建子进程成功,返回值是子进程PID
BBBBBBBBBBBBBBBBBBBBBBB; pid:23642; ppid:1; ret:0; &ret:0x7ffc3c8461fc; //子进程的返回值是0
发现:有两个值地址相同的不同值 -- 说明该地址不是物理地址(真实地址),而是间接地址 -- 写时拷贝的体现


$ 执行流 -- 多执行流 -- 宏观现象和单执行流很多差异,如if和else同时存在

$ fork作用
a.fork之后,执行流会变成两个执行流
b.fork之后,谁先运行由调度器决定
c.fork之后,fork之后的代码共享,通常我们通过if和elseif来进行执行流分流
d.fork之后,return需要为两个执行流执行返回代码,即产生两个返回值

$ fork原理: 
1.-- 拷贝大部分父进程的PCB,其中指向和父进程同样的内存块 . 小部分属于子进程私有,如子进程自己的PID
2.-- 代码共享 -- 代码只读,不可修改,不影响
3.-- 写时拷贝,当有一个执行流尝试修改数据时,OS会自动给当前进程触发写时拷贝
4.-- 进程具有独立性:1.销毁子进程不影响父进程;2.销毁没有父子关系的进程不会影响别的进程



}

$ PCB可以维护在不同的队列中 -- 调度

$ 代码是线性执行的 -- > 我们申请的资源是线性申请的/串行申请 -- 多进程也一样,各自申请各自的

进程状态:
$ 阻塞态: 进程因为等待 某种条件就绪 ,而导致的一种不推进的状态 ,即不被调度,宏观上如卡住了 : 阻塞一定是在等待某种资源,在OS管理的下排队等待
阻塞:进程等待某种资源就绪的过程
为什么阻塞/为什么进入阻塞态? 进程要通过等待的方式,等具体资源被其他对象用完后,再被自己使用
如挂到网卡资源等待队列,键盘等待队列 ... 等各种资源等待队列

$ 挂起态:
内存资源紧张时,会把某些阻塞进程交换到磁盘中(释放内存,腾出空间)  -- 挂起状态 ,全称阻塞挂起状态 -- 特殊的阻塞态

//运行态:在运行队列中,可以随时被调度

$ linux中新建状态就是运行态R,没有新建状态,就绪状态也是R -- 操作系统学科中有新建状态,就绪状态,但linux没有
//操作系统学科中是所有具体操作系统的集合,和具体操作系统不同.不同的具体操作系统有不同特点,不一定都有所体现
//操作系统学科又称计算机中的哲学

$$$$ linux进程状态数组task_state_array
 The task state array is a strange "bitmap" of reasons to sleep. Thus "running" is zero, 
 and you can test for combinations of others with simple bit tests.
 任务状态数组是一个奇怪的睡眠原因“位图”。因此，“运行”为零，您可以通过简单的位测试来测试其他组合。

$ 进程状态数组  -- task_struct中有int status用于表明该进程的状态
static const char * const task_state_array[] = {
"R (running)", /* 0 */
"S (sleeping)", /* 1 */ //linux特有的休眠状态
"D (disk sleep)", /* 2 */
"T (stopped)", /* 4 */
"t (tracing stop)", /* 8 */
"X (dead)", /* 16 */
"Z (zombie)", /* 32 */
};

一般来说,看一个进程是什么状态,可以看状态,也看这个进程在哪里排队.大部分进程不是运行就是阻塞态

R运行状态（running）: 并不意味着进程一定在运行中，它表明进程要么是在运行中要么在运行队列里。运行队列struct task_struct *runquque;
S睡眠状态（sleeping): 意味着进程在等待事件完成（这里的睡眠有时候也叫做可中断睡眠（interruptible sleep））。
D磁盘休眠状态（Disk sleep）有时候也叫不可中断睡眠状态（uninterruptible sleep），在这个状态的进程通常会等待IO的结束。
T停止状态（stopped）： 可以通过发送 SIGSTOP 信号给进程来停止（T）进程。这个被暂停的进程可以通过发送 SIGCONT 信号让进程继续运行。
X死亡状态（dead）：这个状态只是一个返回状态，你不会在任务列表里看到这个状态。
Z(zombie)-僵尸进程:
僵死状态（Zombies）是一个比较特殊的状态。当进程退出并且父进程（使用wait()系统调用,后面讲）没有读取到子进程退出的返回代码时就会产生僵死(尸)进程
僵死进程会以终止状态保持在进程表中，并且会一直在等待父进程读取退出状态代码。
所以，只要子进程退出，父进程还在运行，但父进程没有读取子进程状态，则子进程会进入Z状态
僵尸进程是无法被杀死的 kill-9也不行,因为谁也没法杀死一个死去的东西(进程)

僵尸进程危害
.进程的退出状态必须被维持下去，因为他要告诉关心它的进程（父进程），你交给我的任务，我办的怎么样了。可父进程如果一直不读取，那子进程就一直处于Z状态？是的！
.维护退出状态本身就是要用数据维护，也属于进程基本信息，所以保存在task_struct(PCB)中，换句话说，Z状态一直不退出，PCB一直都要维护？是的！
.那一个父进程创建了很多子进程，就是不回收，是不是就会造成内存资源的浪费？是的！因为数据结构对象本身就要占用内存，想想C中定义一个结构体变量（对象），是要在内存的某个位置进行开辟空间！
.内存泄漏?是的！
.如何避免？ -- learn

S:休眠状态 -- 阻塞状态的一种,不在CPU运行,而是在等待某种资源.但确实是在运行队列.由于CPU很快,外设很慢,所以往往在宏观上表现为S,演示:死循环printf可以发现是S
   在linux中被称为"可中断休眠",演示:scanf()在等待时就是暂停状态,也可以通过结束程序达到中断.即S状态可以被终止,也可以暂停
   例如:拷贝文件到磁盘,则进程进入S,直到拷贝完成

D:不可中断休眠,普通开发一般很难遇到,而做系统管理,运维,IO,存储的经常会遇到
//ps:linux会杀进程
为了保护某些重要的进程不被杀死,所以有了D状态,目的是为了保护某些重要的进程不被杀死.
D状态下的进程无法被杀死,即便是操作系统也不能,甚至无法正常关机,只能断电源(数据损失).只有当D状态的进程恢复时才能杀死该进程
//一般情况下,D状态很难看到(99％),D进程一般都很快执行完毕.但如果D状态有且持续,则可能D进程所在的设备已经快不行了.原因有磁盘快满了,压力过大.再多几个D可能就直接挂掉,宕机了

T:暂停状态
$$ 命令学习: kill -l // 显示kill相关的命令
//   18) SIGCONT	19) SIGSTOP
# kill  -19或-SIGSTOP   PID //暂停进程  Terminated   Stopped  //STAT:S+ --> T
# kill  -18或-SIGCONT   PID //继续进程  ,但会将进程转移到后台 //STAT:T  --> S //没有＋号了,说明进入后台运行
# kill  -9 或-SIGKILL   PID //杀死进程  Killed
//SIG : signal 信号 ,TERM terminate 终止
# killall 进程名 //杀掉相关进程的所有进程

※ # jobs -l //显示后台的任务和PID
// 运行中（Running）， 已停止（Stopped）, 已终止（Terminated）

$ 进程状态STAT带+说明是在前台运行,不带+说明是后台运行
在前台运行则可以通过前台终端命令控制,后台则一些终端命令如前台命令ctrl+C等无效,只能使用shell:kill -9 PID

T 和 S的区别:T往往是操作系统为了阻止某些不合法的任务或用户主动暂停.S是等待资源的阻塞状态
而t(tracing stop) 追踪式暂停:用户主动暂停,如gdb调试断点
$ 运行到断点暂停本质就是进程暂停
验证: gdb打断点,ps axj可以发现STAT为t

X(dead): 死亡状态 -- 瞬时状态,难以观察

$ linux中没有新建态,就绪态等.只有R,运行态,一新建就是R状态




$ main函数的返回值是进程退出码 -- 在操作系统/网络/测试用例等方面有作用


# echo $?  // 查看当前进程结束后的进程退出码 
//bash命令也是进程/程序,运行一个命令后也可以使用echo $?查看进程退出码

$ 如果一个进程推出了,立马X状态,立马退出,作为父进程或OS,有没有机会拿到退出结果呢? --拿不到
所以:linux进程退出时,一般进程不会立即彻底退出,而是要维持一个Z状态,也叫做僵尸状态,--方便后续父进程或OS读取该子进程退出的退出结果 -- 可以甄别退出的原因是什么
//进程具有独立性,子进程退出时无法把数据返回给父进程

演示: fork一个子进程,杀死子进程后提示defunct:失效的,死了的
[chj@expiration1102 2status 22:49:08]$ ps axj|head -1&&ps axj|grep out|grep -v grep
 PPID   PID  PGID   SID TTY      TPGID STAT   UID   TIME COMMAND
 2595  3736  3736  2595 pts/2     3736 S+    1002   0:00 ./out
 3736  3737  3736  2595 pts/2     3736 Z+    1002   0:00 [out] <defunct>

 //僵尸进程如果不回收,会一直占用资源.操作系统也要维护僵尸进程的PCB -->内存泄露

 ※shell命令
 # while :; do ps axj|head -1 && ps ajx|grep a.out|grep -v grep; echo '-------------------'; sleep 1;done

//正常写的程序作为父进程时,我们是看不到僵尸状态的,因为程序一结束就会被bash回收 -- 程序也是bash的子进程 -- 我们写的不对的fork子进程才能看到僵尸进程 -- 内存泄露

$ 1号进程是操作系统, init进程(1号进程)
如果子进程没结束,而父进程先结束了,则子进程的父进程会变为操作系统(1号进程)  
   -- 子进程会被OS自动领养(通过让一号进程成为新的父进程) -- 被领养的进程,叫做:孤儿进程 (Orphan Process)--- 认领和领养机制
   -- 如果不领养会发生什么? 后续子进程结束后,无人回收,-->内存泄露
   -- 所以没有父进程后则自动被OS领养,用于回收子进程




$$$$环境变量environment variables:由系统开机之后,帮我们维护的一些系统运行时的一些动态参数

环境变量一般是指在操作系统中用来指定操作系统运行环境的一些参数,
如：我们在编写C/C++代码的时候，在链接的时候，从来不知道我们的所链接的动态静态库在哪里，但是照样可以链接成功，生成可执行程序，原因就是有相关环境变量帮助编译器进行查找。
环境变量通常具有某些特殊用途，还有在系统当中通常具有全局特性

常见环境变量
PATH : 指定命令的搜索路径
HOME : 指定用户的主工作目录(即用户登陆到Linux系统中时,默认的目录)
SHELL : 当前Shell,它的值通常是/bin/bash。
USER : 当前用户

// echo PATH   //打印PATH
// echo $PATH  //读取PATH的内容 //  /usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/chj/.local/bin:/home/chj/bin
-- '$'符号可以读取文件内容,类似C语言的指针* 

$ 环境变量可以存放多个地址,以:作为分隔符,分隔出多个地址,读取顺序从左向右依次寻找

$ 为什么系统命令不用带./也能运行,而我们写的程序却需要./才能运行?
1.首先./是相对路径 --> 是一条明确的位置. 所有程序都需要有路径才能运行
2.执行程序时会先检查环境变量内路径所指的目录,在目录内找到就能执行,找不到就不能执行.显然,指令在其中,路径明确.而我们的程序不在.
所以,我们的程序必须指明路径.当然,命令也可以带路径


$ 在linux中,把可执行程序,拷贝到系统默认路径下,让我们可以直接访问的方式 == 相当于linux下的软件安装
-- rm掉则就是卸载

$ export PATH=$PATH:[newPATH]  -- 临时修改 PATH //重新登录后恢复
$ 永久修改所有用户vim /etc/profile
$ 永久修改某个用户vim ~/.bashrc


[chj@expiration1102 ~ 14:47:50]$ env  //查看环境变量
XDG_SESSION_ID=170
HOSTNAME=expiration1102  //主机名
TERM=xterm
SHELL=/bin/bash   //shell程序
HISTSIZE=1000     //历史命令存储上限
SSH_CLIENT=210.38.241.42 14847 22  //登录的主机
SSH_TTY=/dev/pts/4
USER=chj    //当前登录的用户 -- 切换成root后不变

# set  //查看更详细的环境变量

# unset 变量  //删除本地变量和环境变量
参数：
 -f 仅删除函数。 
 -v 仅删除变量。//默认


LD_LIBRARY_PATH=:/home/chj/.VimForCpp/vim/bundle/YCM.so/el7.x86_64 //动静态库learn...

//配色方案
LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=01;05;37;41:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.jpg=01;35:*.jpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.axv=01;35:*.anx=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=01;36:*.au=01;36:*.flac=01;36:*.mid=01;36:*.midi=01;36:*.mka=01;36:*.mp3=01;36:*.mpc=01;36:*.ogg=01;36:*.ra=01;36:*.wav=01;36:*.axa=01;36:*.oga=01;36:*.spx=01;36:*.xspf=01;36:

MAIL=/var/spool/mail/chj
PATH=/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/chj/.local/bin:/home/chj/bin //可执行程序的搜索路径
PWD=/home/chj  //当前用户所在路径
LANG=en_US.UTF-8  //当前编码
HISTCONTROL=ignoredups
SHLVL=1
HOME=/home/chj //当前所登录用户的家目录
LOGNAME=chj //当前的登录用户 -- 切换成root后不变
SSH_CONNECTION=210.38.241.42 14847 172.19.52.41 22
LESSOPEN=||/usr/bin/lesspipe.sh %s
XDG_RUNTIME_DIR=/run/user/1002
_=/usr/bin/env


$main函数最多可以带三个参数
int main(int argc,char* argv[],char* envp[]){return 0};
//char* envp[] //envp是环境变量表, 存放C风格字符串的指针数组  -- 编译器会自动生成并传参进去
//envp的有效元素的下一位存放NULL(表结构).env是environment的缩写
//表结构遍历表不需要额外加判断,到最后一个是null或0自动不满足条件
//char* envp[] == char** envp

$ 指针和指针变量有区别.
指针是一个地址,凡是具有指向能力的数据都可以是指针.
指针变量是一个变量,变量在内存中占有4/8字节,具有数据存储和被修改的能力.保存指针数据的变量叫做指针变量

//1.通过一下代码可以验证envp是一张环境变量表
#include<stdio.h>
int main(int argc,char* argv[],char* envp[])
{
  for(int i = 0; envp[i];++i)
  {
    printf("envp[%d]->%s\n",i,envp[i]);       
  }
  return 0;
}

//2.同样可以通过以下代码获取环境变量表
#include<stdio.h>
#include<unistd.h>
int main()
{
  extern char** environ; //unistd内的指针变量:环境变量表,需要声明才可使用                                                 
  for(int i = 0; environ[i];++i)
  {
    printf("envp[%d]->%s\n",i,environ[i]);
  }
    return 0;
}

$ char *getenv(const char *name); //根据环境变量名获取环境变量
#include <stdlib.h>


$ 环境变量本质就是一个内存级的一张表,这张表由用户在登录系统时,操作系统自动给特定的用户形成属于自己的环境变量表
-- 环境变量的内容是从系统的相关配置文件中读取来的
用户环境变量位于~目录下的
-rw-r--r--   1 chj  chj    193 Oct 31  2018 .bash_profile
-rw-r--r--   1 chj  chj    434 Sep 11 22:33 .bashrc

全局环境变量位于/etc下的
-rw-r--r--.  1 root root     2853 Oct 31  2018 bashrc



$ 环境变量中的每一个都有自己的用途,有的是进行路径查找,有的是进行身份确认,有的是进行动态库查找,有的是用来进行确认当前路径等等.每个环境变量都有自己的特定的应用场景
每个元素都是kv的 -- <name ,内容>


linux中变量... 
[chj@expiration1102 ~ 20:35:28]$ myval=100
[chj@expiration1102 ~ 20:35:35]$ echo $myval //可以创建一个变量
100

这个变量如果是环境变量,则会尾插入在环境变量表.. 其他变量则尾插在其他表(如果存在). 还可能把一个动态开辟的表插进已有的表,再或者另开一个表维护...
内存级就是内存中shell正在维护的表..,数据是由系统的相关配置文件中读取而来.后面加入的变量是直接写在内存,没有写在文件,关闭内存可能就没了
这些表是由shell维护的
例如export可以直接导入到内存级的environmentVariablesTables

$ 环境变量能被所有的子进程继承,验证,export一个变量,然后getenv(),可以证明
环境变量可以被相关的子进程继承下去 -- 环境变量具有全局属性

//main函数是父进程调用...通过一些系统调用..

$ shell的本地变量,只在shell内部有效,不可以给子进程继承,可以通过export 本地变量//导入,就能被继承了

linux shell脚本执行命令时创建子进程问题（特定的情况，例如后台运行管道分支或子shell等，脚本可能会创建子进程执行命令）
Shell脚本在执行每个命令时，不一定会创建子进程。
在大多数情况下，每条命令都在主进程中依次执行，不会创建子进程。
但是，当遇到特定的情况，例如后台运行、管道、分支或子shell等，脚本可能会创建子进程。

//linux下一些奇怪的命令.如'.' , ']' , 

$ 命令行中输入的命令就是一个字符串,以空格为分隔符分隔的就是一个一个的子串
例结构: 可执行程序 -命令选项1 -命令选项2 -命令选项3 ...
         0号子串     1号        2号        3号      ... 
        
int main(int argc,char* argv[]){return 0};
argv[0] 就是 0号子串
argv[1] 就是 1号子串
argv[2] 就是 2号子串
...
argv是表结构,也是以NULL结尾.接收的就是命令行中的各个子串构成的表 -- 叫做命令行参数 -- 一般在linux才用得到,windows很少使用命令行
argc是表元素个数,有多少个子串,argc就为多少


command line parameter
argc: argument counter 
argv: argument value 




//优先级

优先级和权限:能or不能
优先级:已经能,但是谁先谁后的问题

为什么会有优先级? 资源太少,资源不足 -- 计算机中CPU资源有限

[chj@expiration1102 linux_code 22:45:04]$ ps -l
F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
0 S  1002 10249 10248  0  80   0 - 28920 do_wai pts/1    00:00:00 bash
0 T  1002 12326 10249  0  80   0 - 38008 do_sig pts/1    00:00:00 AppRun
0 R  1002 13810 10249  0  80   0 - 38336 -      pts/1    00:00:00 ps

[chj@expiration1102 ~ 10:22:25]$ ps -al
F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
0 R  1002 14684 14607  0  80   0 - 38328 -      pts/1    00:00:00 ps


//PRI:priority 优先级:即进程的优先级,就是程序被CPU执行的先后顺序,PRI越小进程的优先级越高.进程的PRI基本都是80,
//NI:nice  nice值:代表当前进程所对应的优先级的修正数据,nice值取值范围是-20至19,[-20,19],一共40个级别.一般nice值都是0
NICE:在LINUX系统中，Nice值的范围从-20到+19（不同系统的值范围是不一样的），正值表示低优先级，负值表示高优先级，值为零则表示不会调整该进程的优先级。具有最高优先级的程序，其nice值最低，所以在LINUX系统中，值-20使得一项任务变得非常重要；与之相反，如果任务的nice为+19，则表示它是一个高尚的、无私的任务，允许所有其他任务比自己享有宝贵的CPU时间的更大使用份额，这也就是nice的名称的来意。
https://www.jianshu.com/p/3c078505fffa
//UID(User Identify):user-ID,和用户名的标识,和用户名一对一对应,操作系统用UID标识用户

PRI(new) = 80 + nice ,NI[-20,19], PRI[60,99] //每次调整都是80开始

$ 虽然可以手动调整PRI,但是调度器...对PRI调整的尺度不会太大,尽可能公平. 我们基本也不会去调整优先级 -- 基本全是默认

调整有很多方法,有nice/renice命令,有setpriority(),有top
top方法:进入top,按r(renice),输入PID,输入nice值,回车即可修改

进程具有
1.竞争性:争夺有限的CPU资源
2.独立性:资源独享,多进程运行期间互不干扰,不受其他进程影响
3.并行:真正同时进行
4.并发:多个进程在一个CPU下采用进程切换的方式,在一段时间内让多个进程得以推进的现象 -- CPU疯狂调度,一个进程执行一段时间就被剥离CPU,让下一个进程使用.CPU很快,快到感觉不出来





进程的独立性:
进程 = 内核数据结构+代码和数据  

//父子进程即使是同一份代码,加载进来的数据也会共享,而是各自维护一份.
但是,观察使用同一份代码的父子进程的信息,发现对同一个变量的变量地址是相同的,但父子进程的变量值可以相同 -- 说明我们在语言层面用的地址不是物理地址
--- > 这个地址叫做线性地址或虚拟地址

类型是在应用层实现的,本质是偏移量,通过类型+数据的首地址可以确定一个数据

进程地址空间  -- 就是操作系统画的一张大饼--虚拟内存
//虚拟地址 == 线性地址
                             
                                        操作系统
                                          管理
进程PCB  ------------------------------- 进程地址空间  ------------------------------------- 内存

进程地址空间本质就是内核数据结构struct mm_struct{}  //memory manage struct

每个进程都有自己的地址空间，这意味着每个进程都有自己的内存地址范围，不会与其他进程冲突。

进程地址空间中的地址是虚拟地址,我们代码平常访问的地址就是虚拟地址
进程地址空间内区域划分就是对各种数据/对象结构体定义后对其赋值约束 -- 数据区,栈区,进程块大小...等等
---- 对线性区域进行指定star和end即完成区域的划分
进程地址空间会根据当前系统自动确定范围,32位则默认4GB,

进程地址空间通常被划分为几个部分：
代码段：存储程序代码的内存区域。
数据段：存储程序运行时所使用的数据的内存区域。
堆：动态分配内存的区域。
栈：存储函数调用时所需的数据(如参数、返回地址和临时变量)的区域。
struct mm_struct
{
    long code_start;
    long code_end;
    long init_start;
    long init_end;
    ...
    long brk_start; //堆
    long brk_end;
    long stack_start;
    long stack_end;
}

各种区域的限定区域内的地址就是虚拟地址/线性地址

修改各种区域的大小就是修改进程地址空间内的边界值  -- 简单理解

每个进程在执行时，都会使用自己的地址空间。进程间通信时，必须通过操作系统提供的机制来实现，因为不同进程之间的地址空间是独立的。

进程地址空间32位机器为4GB，64位机器为64GB或1TB：
//每个进程的进程地址空间都是这么大,但不代表进程享有这么多空间.进程使用空间也是需要申请的.会有物理内存不够时申请内存失败

代码中我们一般对变量取地址取的是首地址(低地址),而如何判断一个变量所占的空间和地址规划,则是由类型决定(软件层,本质是偏移量)

我们在用C/C++语言所看到的地址，全部都是虚拟地址！物理地址，用户一概看不到，由OS统一管理
程序的地址空间’是不准确的，准确的应该说成 进程地址空间

一个进程:
PCB -------------  进程地址空间 -------------  页表 ------------------  物理内存


父子进程 -- 子进程会建立一份基本和父进程一样的数据 -- 未发生写实拷贝时:
父:PCB ------- 进程地址空间 ----- 父页表  --- 物理内存 --- 子页表 ----- 进程地址空间 ------ 子PCB 
                                  虚1|实1                  实1|虚1                                               

如果子进程有数据发生修改,则发生写时拷贝:(不作修改时指向和父进程一样的物理地址,写的时候再拷贝一份到新空间另作修改,不会影响原数据) -- 体现进程独立性
父:PCB ------- 进程地址空间 ----- 父页表  --- 物理内存 --- 子页表 ----- 进程地址空间 ------ 子PCB 
                                  虚1|实1                  实2|虚1                                               

如果是父进程先发生修改,那则是父进程发生写时拷贝???? 不确定

fork在返回时,父子进程都有了,分别在父子进程中ruturn,父进程中return>0,子进程中return 0,总共return两次.谁先返回就是谁先发生写实拷贝


进程地址空间和物理内存之间通过页表和MMU(memory manage unit)进行映射和转化

页表是KV结构,K存虚拟地址,V存物理地址



虚拟地址空间是操作系统内部为进程创建出来的一种具体的数据结构对象,让进程有统一的视角去看待对应的物理内存,可以让进程管理和内存管理独立开来


虚拟地址空间是发展的产物 -- 初期是直接映射的
这样会存在安全问题,如果我们写的代码不正确,则有可能会直接修改到其他数据,-->会破环系统

$ 虚拟地址空间的作用
1.防止物理地址被随意访问,保护物理内存与其他进程
如果没有虚拟地址,那么会很不安全.有了之后呢,会带一层软件层去保护,识别,判断 -- 有读写检查,越界检查(区域),权限检查...
如不允许修改字符串常量,因为字符串常量的页表权限只读.
还有代码也是只读的--- 对应页表的权限全是只读

2.解耦合 进程管理和内存管理通过页表来沟通,
a.malloc向内存申请空间时,操作系统不会立即提供
b.操作系统一般不允许有任何的浪费或不高效
c.申请内存不一定立马使用 -- 浪费 -- 在申请成功后和使用前这一段时间不使用的话,那么这块空间是处于闲置状态的...
所以:操作系统只会在地址空间中申请一i快内存(此时物理地址处为空),等到真正使用时再分配真实内存空间(提供物理内存) -- 缺页中断 机制

3.可以让进程以统一的视角,看待自己的代码和数据
我们编写的代码在编译成可执行程序的时候,会按区域规则分好各个数据段了.在执行可执行程序,加载到内存时,会按一定规则将各数据段依次加载到内存.
即源代码在被编译的时候,就是按照虚拟地址空间的方式进行对代码和数据早就已经编号好了对应的编制 -- 如linux的ELF格式(百度查阅内部结构)
https://baike.baidu.com/item/ELF/7120560?fr=ge_ala

虚拟地址空间不仅会影响操作系统,还会让编译器遵守这样的规则

写时拷贝保证了父子进程的独立性 
写时拷贝是一种按需申请资源的策略 -- 与操作系统不允许浪费资源设定相符
一般只有数据可以发生写时拷贝,多进程时代码也可能发生写时拷贝

fork在网络/服务器中常用
fork失败原因有
1.内存不足
2.系统不允许用户创建太多进程
3.异常退出,如ctrl+c


# echo $?  //取得最近一次进程的退出码,取完就没了

进程退出情况分类 
a.正常退出(1.结果正确 2.结果不正确)  -- 提供进程退出码.供用户进行进程退出健康状态的判定 -- 可用可不用
b.奔溃了(进程异常)[操作系统信号 - 奔溃的原因: 进程因为某些原因,导致进程收到了来自操作系统的信号,如kill -9 ]

//打印c语言错误码表 char* strerror(int);
 #include<stdio.h>
 #include<string.h>
 int main()
 {
   for(int i = 0; i<200 ; ++i) //不同平台码表不一样 --  一般不超过255个
   {
     printf("%d : %s\n",i,strerror(i));                         
   }
   return 0;
 }

 也可以自己定义退出码
 const char* err_string[]=
 {
    "success",
    "error",
    ...
 }

 进程退出方式
 1.return -- main函数中return才是进程退出 ---    进程执行其实是main执行流执行
 2.exit函数退出
 void exit(int status): <stdlib.h> -- exit可以在代码的任何地方结束进程 -- status是进程退出码,等价于main的return
 exit内封装了_exit(系统调用) -- void _exit(int status):<unistd.h>  --- _exit很直接,从系统内直接关闭进程,不会刷新缓冲区什么的 -- main

 exit和_exit区别:
 1.exit会先执行用户定义的清理函数,然后再冲刷缓冲,关闭流等,在向内核(kernel)申请关闭进程(_exit)
 2._exit是直接向内核申请关闭进程
 即exit的最后一步是调用_exit

 缓冲区不在操作系统内 -- 在用户层中(C/C++库)
    如果在系统内的话_exit也会刷新缓冲区


进程退出方式:信号+退出码方案 // 信号(异常)或退出码(正常退出结果对不对)



什么是进程等待?
 进程等待就是通过系统调用,获取 子进程退出码或退出信号 的方式,顺便释放内存问题 -- 获取子进程信息,然后释放子进程

进程等待的目的
1.避免内存泄露
2.获取子进程执行的结果(如果必要) -- 根据进程退出方式

如何进程等待?
系统调用wait/waitpid

 wait : wait for process to change state
声明: pid_t wait(int *status);
头文件 <sys/types.h> <sys/wait.h>
功能:父进程一直在等待子进程,子进程不退出,父进程也不会退出  -- 子进程一挂就能回收了
返回值:
wait(): on success, returns the process ID of  the  terminated  child;  on  error,  -1  is returned.
wait（）：成功时，返回被终止子进程的进程ID；出现错误时，返回-1。


waitpid:/
pid_t waitpid(pid_t pid, int *status, int options);

参数:
1.pid
如果pid>0,(是进程号) 则waitpid会一直等待该进程
如果pid == -1 , 则等待任何一个进程,等价于wait

2.status
int* status:输出型参数
32位位图结构 --
0000 0000 0000 0000 | 0000 0000 0000 0000
第16-31位不使用         
第8-15位:退出状态码:退出码:return或exit的status
第0-6位:终止信号 ,0为正常退出,即没有收到信号(只有信号为0时才看退出码,此时退出码为0的进程才是正确执行).如果退出码不为0,虽然正常执行,但是结果不对
          如果退出码不为0,则
第7位(core dump标志) ... 

3.options
WNOHANG:W(wait) NO(没有) HANG(夯住了:一般机器卡顿时,网络堵塞时我们称为夯住了) 

返回值: -- 返回等待成功的子进程,>0  .失败返回-1 --  一般只有pid出错了才会失败
waitpid():  on  success,  returns  the process ID of the child whose state has changed; if WNOHANG was specified and one or more child(ren) specified by pid exist, 
but have not  yet changed state, then 0 is returned.  On error, -1 is returned.
成功时，返回状态已更改的子进程的进程ID；如果指定了WNOHANG(非阻塞轮询)并且存在由pid指定的一个或多个子进程（ren），
但尚未改变状态，则返回0。出现错误时，返回-1。


学习使用信号1~31号信号 -- 这些信号都是宏 #define SIGHUP 1  //信号也是一个数字
[chj@expiration1102 ~ 18:34:02]$ kill -l
 1) SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL	 5) SIGTRAP
 6) SIGABRT	 7) SIGBUS	 8) SIGFPE	 9) SIGKILL	10) SIGUSR1
11) SIGSEGV	12) SIGUSR2	13) SIGPIPE	14) SIGALRM	15) SIGTERM
16) SIGSTKFLT	17) SIGCHLD	18) SIGCONT	19) SIGSTOP	20) SIGTSTP
21) SIGTTIN	22) SIGTTOU	23) SIGURG	24) SIGXCPU	25) SIGXFSZ
26) SIGVTALRM	27) SIGPROF	28) SIGWINCH	29) SIGIO	30) SIGPWR
31) SIGSYS	34) SIGRTMIN	35) SIGRTMIN+1	36) SIGRTMIN+2	37) SIGRTMIN+3
38) SIGRTMIN+4	39) SIGRTMIN+5	40) SIGRTMIN+6	41) SIGRTMIN+7	42) SIGRTMIN+8
43) SIGRTMIN+9	44) SIGRTMIN+10	45) SIGRTMIN+11	46) SIGRTMIN+12	47) SIGRTMIN+13
48) SIGRTMIN+14	49) SIGRTMIN+15	50) SIGRTMAX-14	51) SIGRTMAX-13	52) SIGRTMAX-12
53) SIGRTMAX-11	54) SIGRTMAX-10	55) SIGRTMAX-9	56) SIGRTMAX-8	57) SIGRTMAX-7
58) SIGRTMAX-6	59) SIGRTMAX-5	60) SIGRTMAX-4	61) SIGRTMAX-3	62) SIGRTMAX-2
63) SIGRTMAX-1	64) SIGRTMAX	

没有0号信号
SIGFPE 8 为除零
SIGKILL 9 为主动杀死
11) SIGSEGV 为空指针异常/野指针

wait和waitpid如何拿到进程数据?   -- 父进程是如何拿到子进程的退出信息的
1.进程PCB内部有两个属性:int exit_code和int exit_signal 
其中main函数会把进程退出码写到exit_code中,操作系统会把信号/异常信息写到exit_signal中
2.通过系统调用wait和waitpid访问内核中的task_struct(PCB)取得数据并设置到输出型参数status中 -- 系统调用有权限访问内核

父进程在wait的时候,如果子进程没有退出,父进程在干什么? --- 只能一直调用wait/waitpid等待 -- 阻塞等待 -- 直到子进程完成后再唤醒父进程
子进程PCB内有task_struct *parent; // 通过它可以找到父进程
这过程父进程状态: R->S->R

非阻塞轮询:即wait不会一直等待进程,而是多次检查 -- waitpid(pid,status,WNOHANG)



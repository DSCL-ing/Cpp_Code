/*****************************************************************//**
 * \file   Note.h
 * \brief  
 * 
 * \author 26390
 * \date   May 2023
 *********************************************************************/

/**	note
 * endl:换行
 * cout:输出
 * 
 * 效率:1.编译速度 2.运行速度
 * 编译速度一般不会影响,实际影响是运行速度
 * 重载影响的是编译速度,不影响运行速度
 * 
 */

/** 运算符
 * << 流插入运算符 
 * >> 流提取运算符
 */

/** 关键字
 * using
 * namespade 命名空间
 * cout 输出
 * cin 输入
 * endl
 * 
 */




//关键字:namespade 命名空间 -- 命名空间域,只影响使用,不影响生命周期
/**
 * 自己定义的名字和库里的名字冲突
 * 项目组，多个人之间定义的名字冲突
 * 
 * 使用:将定义的完整语句放入命名空间内(类型,变量)
 * 调用:命名空间名::变量名; 
 * 注意1:命名空间必须放在名字的前面,类型的后面.例:struct namespace_name A;
 * 注意2:在多个文件定义同名的命名空间会被合并->认定为同一个命名空间->可能会同名冲突
 * 注意3:命名空间可以多层嵌套 name1::name2::name3::name4...nameK::A;
 *		顺序:外到内:1->2->3...->A
 * 
 * 问题1:繁琐,每次使用都要在前面使用域作用限定符
 * 解决1:全局展开:using namespace A; 
 * 用途:将命名空间扩展到全局  ; 正式项目不建议展开 ,也有命名冲突风险;一般在小练习时方便使用才展开
 * 特别:有一些标准库被C++放入命名空间,有标准库std 
 * 解决2:部分展开,把常用的部分展开: using std::cout; using std::endl
 * 
 * 总结:实际开发的项目工程:1.指定命名空间访问,2.常用部分展开
 * using不是关闭命名空间,而是改变查找规则,在执行时候查找的范围
 * 
 */

//关键字:cout
/** 
 * 目前先理解成控制台输出
 */

//关键字:cin
/**
 * 目前可以先理解成控制台提取(输入)
 * 特点:可以自动识别类型(不像c语言scanf一样需要格式符)
 * 可以控制精度,但比较复杂,可以用c语言代替
 */

//::域作用限定符
/**
 * 左边::右边,二元运算符,左边是选择的域(空为全局域),右边是变量
 */

/**
 * << 流插入运算符
 * 目前先理解为流向,将字符串流向控制台cout,将字符流向前面的尾巴.cout << "a" << "1"; (输出结果为a1)
 */

/**
 * >> 流提取运算符
 * 也理解成流向,从cin流出来
 */

//缺省参数
/**
* 举例:
 * void fun(int a = 99)
 * {
 *    //函数体;    
 * } 
 * 
 * fun(1); // 形参a = 1;
 * fun();  // 形参a = 99;  --- 使用缺省参数可以在调用函数时不用传参,使用函数内部的默认参数 
 * 
 * 
 * 全缺省:所有形参都有缺省值,在调用时可以给部分参数传参或不传参 
 * 
 * 半缺省:一部分参数有缺省值,必须从右往左依次连续<==========
 * 
 * 注意:参数必须按顺序传
 * 1.使用缺省值,必须从右往左连续使用
 * 2.传参,必须从左往右依次传参,不能跳跃,如fun(,1,)和(,,1)和(,1,1) 
 * 如果有形参没缺省,则该形参必须赋值,此时可以跳过缺省的形参
 * 
 * 缺省参数的使用场景:在需要有参数,但参数未知时(不知多少也不想随便给一个值)
 * 如:栈的初始化:开辟空间使用缺省参数default=4,在外界不知道大小时可以不传参,使用默认值---
 *	  ---在外界知道大小时可以传参控制.
 * 
 * 注意:缺省不能在声明和定义中同时出现(不论值相同还是不同),会报错.---
 *      --- 如果声明和定义分离,则缺省在声明中给,因为主函数只展开头文件中的声明,定义中给会报错
 * 
 * 缺省参数必须是常量或者是全局变量,但一般都不会使用全局变量
 * 
 * C不支持缺省参数
 * 
 * 
 */

//重载
/**
 * 特性:
 * 1.参数类型可以不同
 * 2.参数个数可以不同
 * 3.参数类型顺序可以不同(int,char) (char,int)
 * 4.参数类型和数量不能相同
 * 
 * 重点:返回值不能作为重载的条件,(java的可以) ,而且不以函数名修饰规则有关 --->
 * --->在调用时只写函数名和参数,无法识别出返回值,所以与函数名修饰规则无关
 * 
 * 范围:同一作用域
 * 
 * 特别:浮点默认为double,要用float需要在后面加f,long需要加l
 * 
 * 原理简要:以ADD为例,C++在调用重载函数时,给函数名做了修饰规则(C语言是直接找函数名)
 * Add(int,int)在汇编中的修饰规则(linux下的,windows的很复杂)为:_Z3Addii ,其中_Z为前缀,3为函数名长度,--->
 * ---> Add为函数名,ii为类型int,int. 因此可以在编译时区分重载函数(char则为_Z3Addcc)		 --->
 * ---> 故形参数量和类型相同则会报错(修饰名一样,肯定错),
 * ---> 报错一般会有:     无法声明的外部符号..
 * ---> 如果是指针则类型符号为Pi,Pc,Pd等...
 * 
 */


//引用
/**
 * C++中的引用就是取别名.
 * 编译器不会给引用变量开辟内存空间,它和它引用的变量共用同一块内存空间
 * 
 * 作用:在需要形参能改变实参的情况下使用(输出型参数)
 * 
 * C++的引用是不能改变指向的,赋变量名和赋值都只是改变对象的值,不能改变指向 ;--->
 * ---> java可以,赋变量名就是改变引用的对象,赋值就是改变对象的值,可以改变指向.
 * 
 * 引用特性:
 * 1.必须在定义时初始化
 * 2.一个变量可以有多个引用
 * 3.
 * 
 * 代码:
 void Swap(int& a, int& b) //
{
	int tmp = a;
	a = b;
	b = tmp;
}

int main()
{
	int a;
	int& i = a; //i ,a指向同一个对象
	
	int* j;
	int*& rj = j;//指针引用

	int a = 1;
	int b = 2;
	Swap(a, b);	//直接改变实参
	cout << "a=" << a << endl;
	cout << "b=" << b << endl;
	return 0;
}}
 */













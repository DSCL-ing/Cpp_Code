/*****************************************************************//**
 * \file   Note.h
 * \brief  
 * 
 * \author 26390
 * \date   May 2023
 *********************************************************************/

/**	note
 * endl:换行
 * cout:输出
 * 
 * 效率:1.编译速度 2.运行速度
 * 编译速度一般不会影响,实际影响是运行速度
 * 重载影响的是编译速度,不影响运行速度
 * 
 * C++中习惯用const和enum枚举来替代宏,用inline去替代宏函数
 * 
 */

/** 运算符
 * << 流插入运算符 
 * >> 流提取运算符
 */

/** 关键字
 * using
 * namespade 命名空间
 * cout 输出
 * cin 输入
 * endl
 * 
 */




//关键字:namespade 命名空间 -- 命名空间域,只影响使用,不影响生命周期
/**
 * 自己定义的名字和库里的名字冲突
 * 项目组，多个人之间定义的名字冲突
 * 
 * 使用:将定义的完整语句放入命名空间内(类型,变量)
 * 调用:命名空间名::变量名; 
 * 注意1:命名空间必须放在名字的前面,类型的后面.例:struct namespace_name A;
 * 注意2:在多个文件定义同名的命名空间会被合并->认定为同一个命名空间->可能会同名冲突
 * 注意3:命名空间可以多层嵌套 name1::name2::name3::name4...nameK::A;
 *		顺序:外到内:1->2->3...->A
 * 
 * 问题1:繁琐,每次使用都要在前面使用域作用限定符
 * 解决1:全局展开:using namespace A; 
 * 用途:将命名空间扩展到全局  ; 正式项目不建议展开 ,也有命名冲突风险;一般在小练习时方便使用才展开
 * 特别:有一些标准库被C++放入命名空间,有标准库std 
 * 解决2:部分展开,把常用的部分展开: using std::cout; using std::endl
 * 
 * 总结:实际开发的项目工程:1.指定命名空间访问,2.常用部分展开
 * using不是关闭命名空间,而是改变查找规则,在执行时候查找的范围
 * 
 */

//关键字:cout
/** 
 * 目前先理解成控制台输出
 */

//关键字:cin
/**
 * 目前可以先理解成控制台提取(输入)
 * 特点:可以自动识别类型(不像c语言scanf一样需要格式符)
 * 可以控制精度,但比较复杂,可以用c语言代替
 */

//::域作用限定符
/**
 * 左边::右边,二元运算符,左边是选择的域(空为全局域),右边是变量
 */

/**
 * << 流插入运算符
 * 目前先理解为流向,将字符串流向控制台cout,将字符流向前面的尾巴.cout << "a" << "1"; (输出结果为a1)
 */

/**
 * >> 流提取运算符
 * 也理解成流向,从cin流出来
 */

//缺省参数
/**
* 举例:
 * void fun(int a = 99)
 * {
 *    //函数体;    
 * } 
 * 
 * fun(1); // 形参a = 1;
 * fun();  // 形参a = 99;  --- 使用缺省参数可以在调用函数时不用传参,使用函数内部的默认参数 
 * 
 * 
 * 全缺省:所有形参都有缺省值,在调用时可以给部分参数传参或不传参 
 * 
 * 半缺省:一部分参数有缺省值,必须从右往左依次连续<==========
 * 
 * 注意:参数必须按顺序传
 * 1.使用缺省值,必须从右往左连续使用
 * 2.传参,必须从左往右依次传参,不能跳跃,如fun(,1,)和(,,1)和(,1,1) 
 * 如果有形参没缺省,则该形参必须赋值,此时可以跳过缺省的形参
 * 
 * 缺省参数的使用场景:在需要有参数,但参数未知时(不知多少也不想随便给一个值)
 * 如:栈的初始化:开辟空间使用缺省参数default=4,在外界不知道大小时可以不传参,使用默认值---
 *	  ---在外界知道大小时可以传参控制.
 * 
 * 注意:缺省不能在声明和定义中同时出现(不论值相同还是不同),会报错.---
 *      --- 如果声明和定义分离,则缺省在声明中给,因为主函数只展开头文件中的声明,定义中给会报错
 * 
 * 缺省参数必须是常量或者是全局变量,但一般都不会使用全局变量
 * 
 * C不支持缺省参数
 * 
 * 
 */

//重载
/**
 * 特性:
 * 1.参数类型可以不同
 * 2.参数个数可以不同
 * 3.参数类型顺序可以不同(int,char) (char,int)
 * 4.参数类型和数量不能相同
 * 
 * 重点:返回值不能作为重载的条件,(java的可以) ,而且不以函数名修饰规则有关 --->
 * --->在调用时只写函数名和参数,无法识别出返回值,所以与函数名修饰规则无关
 * 
 * 范围:同一作用域
 * 
 * 特别:浮点默认为double,要用float需要在后面加f,long需要加l
 * 
 * 原理简要:以ADD为例,C++在调用重载函数时,给函数名做了修饰规则(C语言是直接找函数名)
 * Add(int,int)在汇编中的修饰规则(linux下的,windows的很复杂)为:_Z3Addii ,其中_Z为前缀,3为函数名长度,--->
 * ---> Add为函数名,ii为类型int,int. 因此可以在编译时区分重载函数(char则为_Z3Addcc)		 --->
 * ---> 故形参数量和类型相同则会报错(修饰名一样,肯定错),
 * ---> 报错一般会有:     无法声明的外部符号..
 * ---> 如果是指针则类型符号为Pi,Pc,Pd等...
 * 
 */


//引用
/**
 * C++中的引用就是取别名.
 * 编译器不会给引用变量开辟内存空间(语法层面),它和它引用的变量共用同一块内存空间(实际底层有空间)
 * 引用在汇编层面上和指针基本一致
 * 
 * 作用:在需要形参能改变实参的情况下使用(输出型参数)
 * 
 * C++的引用是不能改变指向的,赋变量名和赋值都只是改变对象的值,不能改变指向 ;--->
 * ---> java可以,赋变量名就是改变引用的对象,赋值就是改变对象的值,可以改变指向.
 * 
 * 引用特性:
 * 1.引用在定义时必须初始化,					指针可以不初始化
 * 2.一个变量可以有多个引用,
 * 3.引用所引用的实体不能再改变,				指针可以改变
 * 4.没有NULL引用,								有NULL指针
 * 5.sizeof,引用为引用类型的大小,				指针大小始终是地址空间所占字节数
 * 6.自增,引用为对象实体增加1,					指针自增为向后偏移一个类型大小
 * 7.没有多级引用,引用的引用还是实体的别名		有多级指针
 * 8.访问实体方式不同,引用编译器自己处理		指针需显示解引用
 * 9.引用更安全		
 * 
 * tips:引用替代不了指针,大部分是用引用,小部分指针更合适则用指针,且只用简单的足以
 * 
 * 代码:
 void Swap(int& a, int& b) //
{
	int tmp = a;
	a = b;
	b = tmp;
}

int main()
{
	int a;
	int& i = a; //i ,a指向同一个对象
	
	int* j;
	int*& rj = j;//指针引用

	int a = 1;
	int b = 2;
	Swap(a, b);	//直接改变实参
	cout << "a=" << a << endl;
	cout << "b=" << b << endl;
	return 0;
}}
 * 
 * 作用2:作返回值
 * 
 * c语言中返回值原理简要:
 *	 int fun()   { int n;  return n;} 
 *	 void main() { ret=fun; }
 *	 其中,在ret接收n时(return后),fun中的栈帧已经被回收使用权了(不是真销毁,而是没有使用权)--->
 * --->而在之前,传n是通过return语句,将n传给main(通常)中临时创建的临时变量(临时变量小内存一般是寄存器,--->
 * --->大可能是别的),在fun销毁前(return结束前)将n传给临时变量,然后再通过临时变量将值传给ret
 * 
 * 注:函数中的static也一样,虽然在函数中声明的static在函数结束后不会销毁,但返回static的值还是--->
 * --->要借助临时变量来给ret接收
 * 
 * 引入:上面方式称为'传值返回',其中返回值类型是临时变量的类型
 * 
 * C++中支持传引用返回
 * 顾名思义:就是将返回值的引用传回来
 * 使用场景:出了作用域后,要返回的对象还在(不受被调函数生命周期影响的)
 * 效果:
 * 1.减少拷贝,提高执行效率
 * 2.调用者可以修改返回对象
 * 代码1：错误返回值使用
int& Add(int a, int b)
{
	int c = a + b;
	return c;
}

int main4()
{
	//错误演示
	int& ret = Add(1, 2); //如果ret不是引用,可以接收地址,会警告,但编译器会转换
	Add(3, 4);
	cout << ret << endl;//无论如何,结果都是未定义的
	return 0;
}

 * 代码2:修改返回对象
typedef struct Array
{
	int arr[10];
	int size;
}AY;	

int& posAlter(AY& ay,int i)
{
	return ay.arr[i];
}

void main()
{
	AY ay;
	for (int i = 0; i < 10; i++)
	{
		posAlter(ay, i) = i;
		cout << ay.arr[i] << " ";
	}
}
 * 
 * 权限: 指针和引用,赋值/初始化 权限可以保持(平移)和缩小,但是不能放大
 * 放大:
 * 错误例子1:const int c = 2; int& d = c;   //典型放大权限
 * 错误例子2:const int* p1 =NULL; int* p2 = p1; //也是会报错,因为p2权限大于p1,(会放大权限)
 * 
 * 保持/平移:
 * const int c = 2; const int& d = c;
 * const int* p1 = NULL; const int* p2 = p1;
 * 
 * 缩小:
 * int c = 2; const int& d = c;
 * int*p1 = NULL; const int* p2 = p1;
 * 
 * 特别1:函数返回值是具体类型(如int)的临时变量具有常性,权限类似const不可修改.--->
 * --->如果用int&接收会报错(权限放大)
 * 编译报错: int fun(){int n,return n }   void main(){ int& ret = fun(); return 0} 
 * 编译通过: int fun(){int n,return n }   void main(){ const int& ret = fun(); return 0} //加const修饰 
 *   
 * 特别2:类型转换会产生临时变量,显式隐式都会
 * 如果给类型转换的类型起别名,必须使用const,用于保持权限不被放大
 * 原因:类型转换会产生临时变量,临时变量是具有常性的(const),而起别名的对象不是原类型,而是临时变量,--->
 * --->因此需要const修饰
 * 
 * 
 */

//内联函数:关键字inline
/**
 * 宏函数正确格式:Add为函数名;(x,y)为函数参数表达式列表;  -- 宏参数可以是表达式
 * ((x)+(y))中括号是避免替换时与其他符号产生优先级冲突,外括号有(a+b)*c,内括号有(a|b)+(a&b) --->
 * --->即替换后参数表达式的目标运算顺序被改变 -- 为了安全每个参数表达式都加上括号
 * 在定义宏函数的时候注意宏函数名和’('之间不能有空格。
 * 宏是非常暴力的替换,意味着规则很复杂.主要是为了防止副作用
 * 举例:#define Add1(x,y) ((x)+(y))
 * 
 * 宏的缺点:
 * 1.不能调试(编译的时候是直接替换掉)
 * 2.没有类型安全的检查
 * 3.有些场景非常的复杂
 * 
 * 宏的优点:
 * 1.快,非常快,不用建立栈帧,直接替换后执行
 * 2.提高复用性,可维护性;对于重复出现的常量,用宏可以方便维护
 * 
 * 引入内联函数:C++为了保留宏的优点,避开宏的缺点.引入了内联函数
 * C++推荐用const和enum去替代宏常量,inline去替代宏函数
 * 
 * 关键字:inline 内联
 * 用法: inline int Add(int x,int y){ return x+y };
 * 原理:编写时按函数一样编写,而编译时会将函数体替换函数调用,像宏一样展开,替换;不必调用栈帧
 * 性能:规则简单,效率不比宏函数差
 * 
 * 注:内联在默认debug下不会起作用,需要修改一些配置.一般在release下起作用
 * 配置步骤:
 * 1.在项目属性中,配置属性C/C++,常规,调试信息格式,选为程序数据库(/Zi)
 * 2.在项目属性中,配置属性C/C++,优化,内联函数扩展,选为只适用于_inline(/Ob1)
 * 
 * 检查是否调用内联:在反汇编中查看是否有call 
 * 
 * 
 * 特性:
 * 1.内联是一种以空间换时间的做法.
 * 缺陷:可能使目标文件变大,不是运行时占用的内存,而是编译出来的可执行程序体积大,因为是直接将函数体换进去--->
 * ---> 设函数体内代码行数n,调用函数有m行,(下面编译后不一定是m和n,只是估算)
 * ---> 若全部执行内联,则行数增加n*m,若执行普通函数,编译后只有n+m行,相差几个数量级
 * ---> 坏处:导致用户体验下降
 * 优势:少了调用开销,提高程序运行效率.
 * 
 * 2.inline对于编译器而言只是一个建议,不同编译器关于inline的实现机制不同,一般函数规模较小的,不是递归,且频繁调用-->
 * --->的函数采用inline修饰,否则编译器会忽略,避免可执行程序体积灾难性过大.因此inline不能强制要求编译器展开
 * 编译器说了算
 * 
 * 内联说明只是向编译器发出一个请求,编译器可以选择忽略这个请求.
 * 
 * 
 */













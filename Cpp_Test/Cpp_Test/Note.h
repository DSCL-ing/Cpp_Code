/*****************************************************************//**
 * \file   Note.h
 * \brief  
 * 
 * \author 26390
 * \date   May 2023
 *********************************************************************/

/**	note
 * endl:换行
 * cout:输出
 * 
 */

/** 运算符
 * << 流插入运算符 
 * >> 流提取运算符
 */

/** 关键字
 * using
 * namespade 命名空间
 * cout 输出
 * cin 输入
 * endl
 * 
 */




//关键字:namespade 命名空间 -- 命名空间域,只影响使用,不影响生命周期
/**
 * 自己定义的名字和库里的名字冲突
 * 项目组，多个人之间定义的名字冲突
 * 
 * 使用:将定义的完整语句放入命名空间内(类型,变量)
 * 调用:命名空间名::变量名; 
 * 注意1:命名空间必须放在名字的前面,类型的后面.例:struct namespace_name A;
 * 注意2:在多个文件定义同名的命名空间会被合并->认定为同一个命名空间->可能会同名冲突
 * 注意3:命名空间可以多层嵌套 name1::name2::name3::name4...nameK::A;
 *		顺序:外到内:1->2->3...->A
 * 
 * 问题1:繁琐,每次使用都要在前面使用域作用限定符
 * 解决1:全局展开:using namespace A; 
 * 用途:将命名空间扩展到全局  ; 正式项目不建议展开 ,也有命名冲突风险;一般在小练习时方便使用才展开
 * 特别:有一些标准库被C++放入命名空间,有标准库std 
 * 解决2:部分展开,把常用的部分展开: using std::cout; using std::endl
 * 
 * 总结:实际开发的项目工程:1.指定命名空间访问,2.常用部分展开
 * using不是关闭命名空间,而是改变查找规则,在执行时候查找的范围
 * 
 */

//关键字:cout
/** 
 * 目前先理解成控制台输出
 */

//关键字:cin
/**
 * 目前可以先理解成控制台提取(输入)
 * 特点:可以自动识别类型(不像c语言scanf一样需要格式符)
 * 可以控制精度,但比较复杂,可以用c语言代替
 */

//::域作用限定符
/**
 * 左边::右边,二元运算符,左边是选择的域(空为全局域),右边是变量
 */

/**
 * << 流插入运算符
 * 目前先理解为流向,将字符串流向控制台cout,将字符流向前面的尾巴.cout << "a" << "1"; (输出结果为a1)
 */

/**
 * >> 流提取运算符
 * 也理解成流向,从cin流出来
 */

//缺省参数
/**
* 举例:
 * void fun(int a = 99)
 * {
 *    //函数体;    
 * } 
 * 
 * fun(1); // 形参a = 1;
 * fun();  // 形参a = 99;  --- 使用缺省参数可以在调用函数时不用传参,使用函数内部的默认参数 
 * 
 * 
 * 全缺省:所有形参都有缺省值,在调用时可以给部分参数传参或不传参 
 * 
 * 半缺省:一部分参数有缺省值,必须从右往左依次连续<==========
 * 
 * 注意:参数必须按顺序传
 * 1.使用缺省值,必须从右往左连续使用
 * 2.传参,必须从左往右依次传参,不能跳跃,如fun(,1,)和(,,1)和(,1,1) 
 * 如果有形参没缺省,则该形参必须赋值,此时可以跳过缺省的形参
 * 
 * 缺省参数的使用场景:在需要有参数,但参数未知时(不知多少也不想随便给一个值)
 * 如:栈的初始化:开辟空间使用缺省参数default=4,在外界不知道大小时可以不传参,使用默认值---
 *	  ---在外界知道大小时可以传参控制.
 * 
 * 注意:缺省不能在声明和定义中同时出现(不论值相同还是不同),会报错.---
 *      --- 如果声明和定义分离,则缺省在声明中给,因为主函数只展开头文件中的声明,定义中给会报错
 * 
 * 缺省参数必须是常量或者是全局变量,但一般都不会使用全局变量
 * 
 * C不支持缺省参数
 * 
 */











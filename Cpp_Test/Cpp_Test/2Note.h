#pragma once

//note
/**
 * 指针操作注意:由虚函数表引出...
 * 指针操作只能多练,难以描述,多画图
 * 1.&地址对对象/数组来说是取首元素的地址
 * 2.指针操作每一步都要注意类型转换,不同类型解引用大小不一样,需要时时刻刻注意
 * 3.对象,自定义类型,数组,他们所对应的类型是一大块内存,而&对象得到的是他们这大块内存的首元素的地址
 * 4.注意:首地址是首元素的地址,元素的地址和元素不一样,每一块空间都有他的地址,首元素是一块空间,.....
 * 
 * 
 * 
 */


//继承
/**
 * 继承受权限影响
 * 有public protected private 三种继承
 * 
 * 基本语法:
 * class student : public Person
 * {
 * 
 * 详细:跳转20inheritance -- C++NO.23 -- 3_27
 * 
 */

//继承和组合
/**
 * 组合即为在类成员是其他自定义类型:如适配器中栈,队列,反向迭代器.
 * 
 * 继承的耦合度高 , 组合的耦合度低
 * 
 * 耦合度:联系强度,软件工程领域:高内聚,低耦合; 类与类之间高耦合->解耦 ; 继承解耦->组合
 * 
 * 继承被称为白盒复用(white_box reuse)
 * 组合被称为黑箱复用(black_box reuse)
 * 
 * 继承是is-a关系:我就是你
 * 组合是has-a关系:我里面有一个你
 * 
 * 一般来说组合更好
 * 不过继承也有用武之地:面向对象三大特性,继承,封装,多态. 有继承才有多态
 * 
 */

//抽象类
/**
 * 1.纯虚函数:在虚函数后面写上=0,则这个函数为纯虚函数  例:virtual void fun() = 0;
 *   纯虚函数只需要声明,不能写函数体.
 *   纯虚函数被继承后的派生类如果不重写,则还是抽象类 -- 直到重写为止
 * 
 * 2.抽象类的定义:包含纯虚函数的类叫做抽象类,也叫接口类.
 * $ 抽象类不能实例化出对象.派生类继承后也不能直接实例化出对象,必须重写纯虚函数后才能实例化对象.
 * $ 纯虚函数规范了派生类必须重写(强制必须重写),  典型接口继承!!!
 * 
 * .
 */

//动态绑定和静态绑定
/**
 * 1.静态绑定又称为前期绑定(早绑定),在程序编译期间就确定了程序的行为,也称为静态多态. 如:函数重载(cout<<类型自动识别等等)\code
 * 
 * 2.动态绑定也称为后期绑定(晚绑定),是在程序运行期间(运行时),根据具体拿到的类型确定程序的具体行为(调用具体的函数),也称为动态多态.
 * 
 * 
 * .
 */

/**
 * 
Compare: 比较器的类型，map中的元素是按照key来比较的，缺省情况下按照小于来比
较，一般情况下(内置类型元素)该参数不需要传递，如果无法比较时(自定义类型)，需要用户
自己显式传递比较规则(一般情况下按照函数指针或者仿函数来传递)
 * 
 */






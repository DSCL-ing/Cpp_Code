#pragma once

//C++11
/**
 * 
 * C++目前最期待的是网络库
 * 
 * C++官方网站
 * https://en.cppreference.com/w/cpp/11
 * 
 * DEV编译器是一个套着壳的GCC
 * DEV不支持范围for --> 没有支持C++11
 * 没有公司会用DEV,但学校可能会用DEV,---原因是DEV成本比较低 -- 适合入门
 * 
 * .
 */

//｛｝初始化 -- 花括号初始化 -- 列表初始化 -- 一起都可以用花括号去初始化
/**
 * 在C++98中，标准允许使用花括号{}对数组或者结构体元素进行统一的列表初始值设定
 * 
 * C++11扩大了用大括号括起的列表(初始化列表)的使用范围，使其可用于所有的内置类型和用户自定义的类型，使用初始化列表时，可添加等号(=)，也可不添加。
 * .创建对象时也可以使用列表初始化方式调用构造函数初始化
 */

#include<vector>
#include"1Date.h"
#include <map>
void test1()
{
	struct Point //结构体可以定义在函数体内部
	{
		int _x;
		int _y;
	};
	int x1 = 1;
	int x2 = { 2 };
	int x3{ 3 }; //省略赋值符号
	//int x4(4);//这个写法是模板引进的,调了int的构造 -- 与列表初始化无关

	int array1[] = { 1,2,3,4,5 };
	int array2[]{ 1,2,3,4,5 };//省略赋值符号
	int array3[5] = { 0 }; //只初始化1个还是全部初始化了?
	int array4[5]{ 0 };//省略赋值符号
	Point p{ 1,2 };


	// C++11中列表初始化也可以适用于new表达式中
	int* pa = new int[4]{ 0 };

	//日期类也可以支持花括号,不带赋值是拷贝构造
	//但日期类带赋值是构造+拷贝...优化而成
	//如果不想自定义类型显式调用拷贝构造可以加explicit(意思:明确),即使自定义不能通过赋值符号初始化 -- 把构造干掉,也拷贝不了了
	
	//自定义类型初始化时可以把圆括号换成花括号
	//花括号和圆括号的区别是,花括号可以用 = 号,或者省略等号(省略时和圆括号一样). 而圆括号只能跟/贴着对象或类型


	//C++11 std::initializer_list<T> -- 接收常量数组 --该数组在常量区 -- 不允许修改
	/**
	 * 中文名 :初始化器表
	 * 
	 * 是C++标准程序库中的一个头文件，定义了C++标准中一个非常轻量级的表示初始化器列表的类模板initializer_list及有关函数。
	 * 为了编写能够处理不同数量实参（但是类型相同），C++11新标准提供了initializer_list的方法。
	 * 与vector不同的是，initializer_list对象中的元素永远是常量值，我们无法改变initializer_list对象中元素的值。在进行函数调用的时候需要使用花括号将所有的参数括起来。
	 * 
	 * 支持:vector,list,map
	 * 
	 * std::initializer_list一般是作为构造函数的参数，C++11对STL中的不少容器就增加std::initializer_list作为参数的构造函数，
	 * 这样初始化容器对象就更方便了。也可以作为operator=的参数，这样就可以用大括号赋值。
	 * 
	 */
	auto il = { 1,2,3,4,5,6 };
	std::initializer_list<int>::iterator it = il.begin();
	//++(*it); -- 报错,不允许


	Date d1(1, 1, 1);
	Date d2(2, 2, 2);

	//initializer_list<Date>
	std::vector<Date> v1 = { d1,d2 };
	std::vector<Date> v2 = {Date(1,1,1),Date(2,2,2)};
	std::vector<Date> v3 = { {1,1,1},{2,2,2} };
	 //typename std::vector<int>::iterator it = v2.begin(); // ------ 不知道为什么迭代器不对

	//map 可以使用初始化器表
	map<std::string, std::string> dict = { {"1","1"},{"2","2"} };

	//pair支持花括号 -- 和圆括号一样
	pair<int, int> kv = { 2,2};

}


//auto
/**
 * 略...
 * 
 * .
 */


//decltype 也是推导类型 和auto类似
/**
 * 有一些和auto不一样.
 * 
 * auto不能放进<> , decltype可以 ,但....
 * 
 * 查一下不可替代区别在哪:
 * 
 * .
 */

//nullptr

//范围for循环
/**
 * .
 */

//智能指针
/**
 * 
 * .
 */

//C++11新增容器相关
/**
 * 一,新增容器
 * 1.Array --- 区别不大 -- vector可以替代
 * 2.forward_list -- 还行 -- 如果只需要单链表头插,则效率会比list好一点 -- 比list节省空间
 * 3.unordered_set -- 牛
 * 4.unordered_map -- 牛
 * 
 * 二.新增容器特性
 * 1.部分容器新增构造函数支持initlizer_list
 * 2.新增迭代器cbegin和cend()
 * 3.新增 移动构造和移动赋值  -- 标志 Type&& val
 * 4.新增 右值引用
 *	3.4.价值非常大,提高了拷贝效率;
 * 
 * 
 * 
 */

//右值引用
/**
 *  左值引用和右值引用
 * 传统的C++语法中就有引用的语法，而C++11中新增了的右值引用语法特性，所以从现在开始我们
 *  之前学习的引用就叫做左值引用。无论左值引用还是右值引用，都是给对象取别名。
 * 
 * 左值特点:
 * 1.能取地址就是左值
 * 2.左值可以在赋值的左边或右边
 * 
 * 左值引用:
 * 即给左值取别名
 * 
 * // 以下的p、b、c、*p都是左值
int* p = new int(0);
int b = 1;
const int c = 2;
// 以下几个是对上面左值的左值引用
int*& rp = p;
int& rb = b;
const int& rc = c; //引用const变量必须加const限制权限
int& pvalue = *p;
 * 
 * 
 * 右值特点:
 * 1.是一个数据表达式
 * 2.字面常量,表达式返回值,函数返回值(返回的那个临时变量,不能是引用)
 * 3.右值可以出现在赋值符号的右边，但是不能出现出现在赋值符号的左边，右值不能取地址
 * 
 * 右值引用:右值引用就是对右值的引用，给右值取别名。
 * 
 * // 以下几个都是常见的右值
 10; //字面常量
 x + y; //表达式
 min(x, y); //返回值(临时变量)
 * 
 * // 以下几个都是对右值的右值引用
int&& rr1 = 10;
double&& rr2 = x + y;
double&& rr3 = fmin(x, y);
 * 
 * 
 * // 这里编译会报错：error C2106: “=”: 左操作数必须为左值
10 = 1; 
x + y = 1;
fmin(x, y) = 1;
 * 
 * //左值引用+const后也可以引用右值 -- 右值有常性
const int& ref = x+y;
 * 
 * $ 左值引用既可以给左值起别名
 * 
 * $ const 左值引用既可以给左值起别名,也可以给右值起别名 
 * 但是const 左值引用 区分不了引用的是左值还是右值 -->右值引用
 * 
 * $ 右值引用可以给右值起别名
 * 
 * $ 右值引用可以给move以后的左值起别名  
 * move--资源转移
 * 
 * 右值又分为
 * 1.纯右值 -- 一般是内置类型
 * 2.将亡值 -- 一般是自定义类型  -- 右值引用可以让资源转移,减少拷贝花销 --> 移动拷贝/移动构造 
 * 
 * 
 * 左值引用作用:直接减少拷贝:1.左值引用传参 2.传引用返回 -- 但函数内局部对象不能传引用返回	-> 右值引用
 * 
 * 编译器在处理返回值时,在可以优化的情况下,会在返回值销毁前,走移动构造,作资源转移,然后再析构,然后销毁栈帧(包括返回值)
 * 也可以手动return+move -- 即编译器会自动加move
 * 
 * 
 * C++11对容器构造和插入函数都增加右值引用版本
 * 
 * 匿名对象是右值,用匿名对象初始化时,匿名对象会被识别成右值 -- 又如字符串"xxxx"这些没有使用变量而直接拿到括号内初始化,也如匿名对象
 * 但如果是C++98,则只会调深拷贝
 * 
 * 总结:
 * 左值引用和右值引用都是减少拷贝,提高效率.但角度不同,
 * 左值引用是直接减少拷贝,
 * 右值引用是间接减少拷贝,识别出是左值还是右值,如果是右值就直接移动资源,不再拷贝,提高效率
 * 
 * 
 * 
 */







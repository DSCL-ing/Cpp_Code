#pragma once

//C++11
/**
 * 
 * C++目前最期待的是网络库
 * 
 * C++官方网站
 * https://en.cppreference.com/w/cpp/11
 * 
 * DEV编译器是一个套着壳的GCC
 * DEV不支持范围for --> 没有支持C++11
 * 没有公司会用DEV,但学校可能会用DEV,---原因是DEV成本比较低 -- 适合入门
 * 
 * .
 */

//｛｝初始化 -- 花括号初始化 -- 列表初始化 -- 一起都可以用花括号去初始化
/**
 * 在C++98中，标准允许使用花括号{}对数组或者结构体元素进行统一的列表初始值设定
 * 
 * C++11扩大了用大括号括起的列表(初始化列表)的使用范围，使其可用于所有的内置类型和用户自定义的类型，使用初始化列表时，可添加等号(=)，也可不添加。
 * .创建对象时也可以使用列表初始化方式调用构造函数初始化
 */

 //test1
#include<vector> 
#include"1Date.h"
#include <map>
//test2
#include"10myString.h"
#include"12myList.h"
void test1()
{
	struct Point //结构体可以定义在函数体内部
	{
		int _x;
		int _y;
	};
	int x1 = 1;
	int x2 = { 2 };
	int x3{ 3 }; //省略赋值符号
	//int x4(4);//这个写法是模板引进的,调了int的构造 -- 与列表初始化无关

	int array1[] = { 1,2,3,4,5 };
	int array2[]{ 1,2,3,4,5 };//省略赋值符号
	int array3[5] = { 0 }; //只初始化1个还是全部初始化了?
	int array4[5]{ 0 };//省略赋值符号
	Point p{ 1,2 };


	// C++11中列表初始化也可以适用于new表达式中
	int* pa = new int[4]{ 0 };

	//日期类也可以支持花括号,不带赋值是拷贝构造
	//但日期类带赋值是构造+拷贝...优化而成
	//如果不想自定义类型显式调用拷贝构造可以加explicit(意思:明确),即使自定义不能通过赋值符号初始化 -- 把构造干掉,也拷贝不了了
	
	//自定义类型初始化时可以把圆括号换成花括号
	//花括号和圆括号的区别是,花括号可以用 = 号,或者省略等号(省略时和圆括号一样). 而圆括号只能跟/贴着对象或类型


	//C++11 std::initializer_list<T> -- 接收常量数组 --该数组在常量区 -- 不允许修改
	/**
	 * 中文名 :初始化器表
	 * 
	 * 是C++标准程序库中的一个头文件，定义了C++标准中一个非常轻量级的表示初始化器列表的类模板initializer_list及有关函数。
	 * 为了编写能够处理不同数量实参（但是类型相同），C++11新标准提供了initializer_list的方法。
	 * 与vector不同的是，initializer_list对象中的元素永远是常量值，我们无法改变initializer_list对象中元素的值。在进行函数调用的时候需要使用花括号将所有的参数括起来。
	 * 
	 * 支持:vector,list,map
	 * 
	 * std::initializer_list一般是作为构造函数的参数，C++11对STL中的不少容器就增加std::initializer_list作为参数的构造函数，
	 * 这样初始化容器对象就更方便了。也可以作为operator=的参数，这样就可以用大括号赋值。
	 * 
	 */
	auto il = { 1,2,3,4,5,6 };
	std::initializer_list<int>::iterator it = il.begin();
	//++(*it); -- 报错,不允许


	Date d1(1, 1, 1);
	Date d2(2, 2, 2);

	//initializer_list<Date>
	std::vector<Date> v1 = { d1,d2 };
	std::vector<Date> v2 = {Date(1,1,1),Date(2,2,2)};
	std::vector<Date> v3 = { {1,1,1},{2,2,2} };
	 //typename std::vector<int>::iterator it = v2.begin(); // ------ 不知道为什么迭代器不对

	//map 可以使用初始化器表
	map<std::string, std::string> dict = { {"1","1"},{"2","2"} };

	//pair支持花括号 -- 和圆括号一样
	pair<int, int> kv = { 2,2};

}


//auto
/**
 * 略...
 * 
 * .
 */


//decltype 也是推导类型 和auto类似
/**
 * 有一些和auto不一样.
 * 
 * auto不能放进<> , decltype可以 ,但....
 * 
 * 查一下不可替代区别在哪:
 * 
 * .
 */

//nullptr

//范围for循环
/**
 * .
 */

//智能指针
/**
 * 
 * .
 */

//C++11新增容器相关
/**
 * 一,新增容器
 * 1.Array --- 区别不大 -- vector可以替代
 * 2.forward_list -- 还行 -- 如果只需要单链表头插,则效率会比list好一点 -- 比list节省空间
 * 3.unordered_set -- 牛
 * 4.unordered_map -- 牛
 * 
 * 二.新增容器特性
 * 1.部分容器新增构造函数支持initlizer_list
 * 2.新增迭代器cbegin和cend()
 * 3.新增 移动构造和移动赋值  -- 标志 Type&& val
 * 4.新增 右值引用
 *	3.4.价值非常大,提高了拷贝效率;
 * 
 * 
 * 
 */

/**左值引用的短板：
 * 但是当函数返回对象是一个局部变量，出了函数作用域就不存在了，就不能使用左值引用返回，
 * 只能传值返回。例如：bit::string to_string(int value)函数中可以看到，这里只能使用传值返回，
 * 传值返回会导致至少1次拷贝构造(如果是一些旧一点的编译器可能是两次拷贝构造)。.
 */




//右值引用
/**
 *  左值引用和右值引用
 * 传统的C++语法中就有引用的语法，而C++11中新增了的右值引用语法特性，所以从现在开始我们
 *  之前学习的引用就叫做左值引用。无论左值引用还是右值引用，都是给对象取别名。
 * 
 * 左值特点:
 * 1.能取地址就是左值
 * 2.左值可以在赋值的左边或右边
 * 
 * 左值引用:
 * 即给左值取别名
 * 
 * // 以下的p、b、c、*p都是左值
int* p = new int(0);
int b = 1;
const int c = 2;
// 以下几个是对上面左值的左值引用
int*& rp = p;
int& rb = b;
const int& rc = c; //引用const变量必须加const限制权限
int& pvalue = *p;
 * 
 * 
 * 右值特点:
 * 1.是一个数据表达式
 * 2.字面常量,表达式返回值,函数返回值(返回的那个临时变量,不能是引用)
 * 3.右值可以出现在赋值符号的右边，但是不能出现出现在赋值符号的左边，右值不能取地址
 * 
 * 右值引用:右值引用就是对右值的引用，给右值取别名。
 * 
 * // 以下几个都是常见的右值
 10; //字面常量
 x + y; //表达式
 min(x, y); //返回值(临时变量)
 * 
 * // 以下几个都是对右值的右值引用
int&& rr1 = 10;
double&& rr2 = x + y;
double&& rr3 = fmin(x, y);
 * 
 * 
 * // 这里编译会报错：error C2106: “=”: 左操作数必须为左值
10 = 1; 
x + y = 1;
fmin(x, y) = 1;
 * 
 * //左值引用+const后也可以引用右值 -- 右值有常性
const int& ref = x+y;
 * 
 * $ 左值引用既可以给左值起别名
 * 
 * $ const 左值引用既可以给左值起别名,也可以给右值起别名 -- 和右值引用基本没有区别,目前没有遇到 
 * 但是const 左值引用 有时会区分不了引用的是左值还是右值 --> 一般都是直接用右值引用
 * 
 * $ 右值引用可以给右值起别名
 * 注:右值引用一般不带const ,带const会发生什么暂时位置,等待测试
 * : const && 引用的是 const右值对象  -- 结果是资源转移后依然不可修改  -- 很少使用
 * 
 * $ 右值引用可以给move以后的左值起别名  
 * move--资源转移
 * 
 * 注: 需要注意的是右值是不能取地址的，但是给右值取别名后，会导致右值被存储到特定位置，且可
 * 以取到该位置的地址，也就是说例如：不能取字面量10的地址，但是rr1引用后，可以对rr1取地
 * 址，也可以修改rr1。如果不想rr1被修改，可以用const int&& rr1 去引用，是不是感觉很神奇，
 * 这个了解一下实际中右值引用的使用场景并不在于此，这个特性也不重要
int main()
{
 double x = 1.1, y = 2.2;
 int&& rr1 = 10;
 const double&& rr2 = x + y;
 rr1 = 20;   //资源转移后变左值了,可以修改
 rr2 = 5.5;  // 报错
 return 0;
 }

 * 
 * 
 * 
 * 右值又分为
 * 1.纯右值 -- 一般是内置类型
 * 2.将亡值 -- 一般是自定义类型  -- 右值引用可以让资源转移,减少拷贝花销 --> 移动拷贝/移动构造 
 * 
 * 
 * 左值引用作用:直接减少拷贝:1.左值引用传参 2.传引用返回 -- 但函数内局部对象不能传引用返回	-> 右值引用
 * 
 * 编译器在处理返回值时,在可以优化的情况下,会在返回值销毁前,走移动构造,作资源转移,然后再析构,然后销毁栈帧(包括返回值)
 * 也可以手动return+move -- 即编译器会自动加move
 * 
 * 
 * C++11对容器构造和插入函数都增加右值引用版本
 * 
 * 匿名对象是右值,用匿名对象初始化时,匿名对象会被识别成右值 -- 又如字符串"xxxx"这些没有使用变量而直接拿到括号内初始化,也如匿名对象
 * 但如果是C++98,则只会调深拷贝
 * 
 * 总结:
 * 左值引用和右值引用都是减少拷贝,提高效率.但角度不同,
 * 左值引用是直接减少拷贝,
 * 右值引用是间接减少拷贝,识别出是左值还是右值,如果是右值就直接移动资源,不再拷贝,提高效率 
 * 
 * 
 */



//move
/**
 * 按照语法，右值引用只能引用右值，但右值引用一定不能引用左值吗？因为：有些场景下，可能
 * 真的需要用右值去引用左值实现移动语义。当需要用右值引用引用一个左值时，可以通过move
 * 函数将左值转化为右值。C++11中，std::move()函数位于 头文件中，该函数名字具有迷惑性，
 * 它并不搬移任何东西，唯一的功能就是将一个左值强制转化为右值引用，然后实现移动语义。
 * 
 * move是std中的一个函数
 * 
 * $ 某些情况或不符合条件,可能不会资源转移,而是恢复成拷贝  -- 待学
 * 
 */


//完美转发/万能引用/引用折叠 std::forward<T> -- 既可以引用左值,也可以引用右值
/**
 * perfect:完美的
 * forward:单向,向前 
 * 
 * $ 模板中的&&不代表右值引用，而是万能引用，其既能接收左值又能接收右值。
 *   模板的万能引用只是提供了能够接收同时接收左值引用和右值引用的能力
 *   但是引用类型的唯一作用就是限制了接收的类型，后续使用中都退化成了左值，
 *   我们希望能够在传递过程中保持它的左值或者右值的属性, 就需要用我们下面学习的完美转发
 * 
 * 模板中&& 会自动推导,如果是左值 -- 会折叠&&的其中一个& ->变成只有1个& -- 即折叠引用.如果是右值,就不折叠
 *  -- 所以传左值就是左值引用,传右值就是右值引用 -- 万能引用
 * 
 * 右值引用在作资源转移变成左值后,会丢失常性 -- 即变成左值
 * 右值引用引用后属性是左值,这样才能实现资源转移 --- 因为资源转移后,能修改才有意义 ,所以会丢失常性
 * 
 * std::forward 完美转发在传参的过程中保留对象原生类型属性 -- 只保留一层,哪里需要加哪里,全部需要则都加上
 * string& s1 = string("hello"); //报错 -- 临时变量具有常性 引用不支持引用常量
 * string s1 = string("hello"); //正确 -- 编译器优化,资源转移到s1上,原临时变量丢失常性,可以正常修改
 * 
 * forward是std的一个模板类
 * 
 * 使用方法:保持右值引用得到的对象还是右值/保持常性  -- 
 * 		void push_back(T&& x) //右值 -- 资源转移到这层栈帧
		{
			insert(end(), forward<T>(x)); --如果不使用forward,则下一层就是左值,
		}
 * 
 */


 /*
 void Fun(int &x){ cout << "左值引用" << endl; }
 void Fun(const int &x){ cout << "const 左值引用" << endl; }
 void Fun(int &&x){ cout << "右值引用" << endl; }
 void Fun(const int &&x){ cout << "const 右值引用" << endl; }

 // std::forward<T>(t)在传参的过程中保持了t的原生类型属性。

   template<typename T>
   void PerfectForward(T&& t) {
   	   Fun(std::forward<T>(t));
   }

 int main()
 {
  PerfectForward(10);           // 右值
  int a;
  PerfectForward(a);            // 左值
  PerfectForward(std::move(a)); // 右值
  const int b = 8;
  PerfectForward(b);      // const 左值
  PerfectForward(std::move(b)); // const 右值
  return 0;
 }
 */

void test2()
{
	test::list<test::string> lt;    //建一个string链表       -- empty_init() -- 空结点也是将匿名对象移动构造
	test::string s1("hello world"); //建一个string对象-- 带参构造
	lt.push_back(s1);               //                       -- 深拷贝 - 测试;
	lt.push_back(test::string("hello world")); //匿名对象    -- 移动构造
	lt.push_back("hello world"); //                          -- 移动构造

	
	//move测试 -- move需要支持一些内置函数才行,库的可以move,我写的不能move无效,虽然走的是移动构造,但s没有释放掉
	test::list<std::string> lt1;
	std::string s2("hello");
	lt1.push_back(move(s2)); 
	lt1.push_back(move(s2));
}


/**
 * 
 * 移动构造对深拷贝的类才有意义 -- 其他的开销太小了,意义不大
 * 
 * 移动语义就是移动构造和移动赋值
 * .
 */

/** 移动赋值 operator=
 * 
 * 
 * 
 */

void test3()
{
	test::string s;

	s = test::to_string(1234);


}




# 智能指针

## 场景引入 - 为什么需要智能指针？

C++有些场景下,处理异常安全问题时特别繁琐

```
void example{
	int *p1 = new int;  //可能会抛异常1
	int *p2 = new int;  //可能会抛异常2
	Func();             //可能会抛异常3
	
	delete p1;
	delete p2;
}

int main(){
	try{
		example();
	}
	catch(std::exception& e){
		std::cout<<e.what()<<std::endl;
	}
}
```

如果需要将上面例子使用异常处理,则可能会面临如下情况

1. 只有p1抛异常:

   p1抛异常程序没有安全问题,因为new没有申请成功,之后程序就跳转了

2. p1不抛异常,但p2抛异常:

   ![image-20240610213932550](智能指针.assets/image-20240610213932550.png)

   如果直接复制粘贴到try中,p2就出作用域了.因此需要改代码:

   ![image-20240610214612327](智能指针.assets/image-20240610214612327.png)

   这样就可以了,但是这么做会有点别扭和麻烦.

3. 如果p1和p2都不抛异常,Func抛异常

   ```
   void example() {
       int* p1 = new int;   
       int* p2 = nullptr;
       
       try {
           p2 = new int;
       }
       catch (...) {
           delete p1;
           throw;
       }
   
       try {
           Func();
       }
       catch(...){
           delete p1;
           delete p2;
           throw;
       }
       delete p1;
       delete p2;
   }
   ```

   使用try-catch处理后,代码越来越膨胀.如果再多几个可能会抛异常的函数.那代码是相当长了.

先说结论:如果使用C++的智能指针,处理这些问题会变得很简单.

## 内存泄漏 

### 什么是内存泄漏

> 内存泄漏指因为疏忽或错误造成程序未能释放已经不再使用的内存的情况.内存泄漏并不是指内存在物理上的消失,而是应用程序分配某段内存后,因为设计错误,失去了对该段内存的控制,因而造成了内存的浪费.

### 内存泄漏的危害

> 长期运行的程序出现内存泄漏,影响很大,如操作系统、后台服务等等,出现内存泄漏会导致响应越来越慢,最终卡死.(不怕一下子泄露完,就怕一点一点泄露,难以发现)

### 内存泄漏分类

> C/C++程序中一般我们关心两种方面的内存泄漏
>
> - 堆内存泄漏(Heap leak) 
>   堆内存指的是程序执行中依据须要分配通过malloc / calloc / realloc / new等从堆中分配的一块内存，用完后必须通过调用相应的free或者delete删掉。假设程序的设计错误导致这部分内存没有被释放，那么以后这部分空间将无法再被使用，就会产生Heap Leak。
> - 系统资源泄漏 
>   指程序使用系统分配的资源，比方套接字、文件描述符、管道等没有使用对应的函数释放掉，导致系统资源的浪费，严重可导致系统效能减少，系统执行不稳定。

### 如何避免内存泄漏 

> 1. 工程前期良好的设计规范，养成良好的编码规范，申请的内存空间记着匹配的去释放。ps:这个理想状态。但是如果碰上异常时，就算注意释放了，还是可能会出问题。需要智能指针来管理才有保证。
> 2. 采用RAII思想或者智能指针来管理资源。
>
> 3. 有些公司内部规范使用内部实现的私有内存管理库。这套库自带内存泄漏检测的功能选项。 
> 4. 出问题了使用内存泄漏工具检测。ps:不过很多工具都不够靠谱，或者收费昂贵。
>
> 总结一下: 
> 内存泄漏非常常见，解决方案分为两种：1、事前预防型。如智能指针等。2、事后查错型。如泄漏检测工具。

## 智能指针的使用及原理

### RAII 

> RAII（Resource Acquisition Is Initialization）是一种利用对象生命周期来控制程序资源（如内存、文件句柄、网络连接、互斥量等等）的简单技术。
> 在对象构造时获取资源，接着控制对资源的访问使之在对象的生命周期内始终保持有效，最后在对象析构的时候释放资源。借此，我们实际上把管理一份资源的责任托管给了一个对象。这种做法有两大好处: 
>
> - 不需要显式地释放资源。 
> - 采用这种方式，对象所需的资源在其生命期内始终保持有效。
> - 智能指针是RAII思想的一种产物,还有守护锁lock_gard等...



#### 简易例程

```
template<class T>
class SmartPtr {
public:
    SmartPtr(T*ptr):_ptr(ptr) 
    {}
    ~SmartPtr() {
        delete _ptr;
        std::cout<<"delete ptr"<<"\n";
    }
private:
    T*_ptr;
};

int div()
{
    int a, b;
    std::cin >> a >> b;
    if (b == 0)
        throw std::invalid_argument("除0错误");
    return a / b;
}

void example() {
    SmartPtr<int> sp1(new int);
    SmartPtr<int> sp2(new int);
    try {
        div();
    }
    catch (...) {
        throw;
    }
}
```

执行结果:

![image-20240610223732315](智能指针.assets/image-20240610223732315.png)

根据执行结果可以发现,在div()抛出异常后,SmartPtr的两个对象都delete.

原因就是sp1和sp2都是类型为SmartPtr的局部对象,出了作用域会调用它的析构函数.

之后不需要再写一堆try-catch,代码更加简洁



### 智能指针的原理 

- RAII
- 像指针一样使用
- 拷贝问题

> 上述的SmartPtr还不能将其称为智能指针，因为它还不具有指针的行为。指针可以解引用，也可 
> 以通过->去访问所指空间中的内容，因此：AutoPtr模板类中还得需要将* 、->重载下，才可让其 
> 像指针一样去使用。

例程:

```
template<class T>
class SmartPtr {
public:
    SmartPtr(T*ptr):_ptr(ptr) 
    {}
    ~SmartPtr() {
        delete _ptr;
        std::cout<<"delete ptr"<<"\n";
    }
    T& operator*() {
        return *_ptr;
    }
    T* operator->() {
        return _ptr;
    }
private:
    T*_ptr;
};
```

<br>

#### 智能指针的拷贝问题

智能指针最难的在于拷贝问题.

下面例子中,尝试使用拷贝构造初始化sp2:

![image-20240616110527125](智能指针.assets/image-20240616110527125.png)

运行后出现了程序奔溃.

我们知道,默认生成的拷贝构造是浅拷贝.我们目前的SmartPtr并没有写拷贝构造,并且sp1是管理着一个动态申请的对象的.拷贝构造之后,sp1和sp2同时指向了同一个对象.最终会导致释放时释放两次.

那给SmartPtr加上深拷贝可以吗? 不可以,因为我们要的就是浅拷贝.因为智能指针是要模拟普通指针的行为.普通指针赋值也是浅拷贝,赋值后它们都指向同一个资源,由用户进行delete.因此不能是深拷贝.

> 迭代器也是模拟指针行为,也是浅拷贝,为什么迭代器不担心拷贝问题?
>
> 因为迭代器只是用于访问资源,修改资源,并不需要管理资源释放,资源释放由容器进行处理.
>
> 而智能指针需要管理资源释放,不能单纯的浅拷贝

如何解决.最终解决方案是使用引用计数.再此之前还有一段智能指针发展过程.



## 智能指针的发展历史

C++98时,C++有了第一款智能指针,它叫做`auto_ptr`,自动指针.

它的出现也遇到了如我们上文中存在的拷贝问题.auto_ptr使用了**管理权转移**的方案进行解决.

### `std::auto_ptr`

头文件 <memory>

#### 模拟实现auto_ptr例程:

```
namespace test {
    template<class T>
    class auto_ptr {
    public:
        auto_ptr(T* ptr) :_ptr(ptr)
        {}

        auto_ptr(auto_ptr& ap) {
            _ptr = ap._ptr;
            ap._ptr = nullptr;
        }

        ~auto_ptr() {
            delete _ptr;
            std::cout << "delete ptr" << "\n";
        }
        T& operator*() {
            return *_ptr;
        }
        T* operator->() {
            return _ptr;
        }
    private:
        T* _ptr;
    };
}
```

使用这种方案下,如果熟悉特性,使用效果还好.

##### 这种方案存在的问题:

![image-20240616141642877](智能指针.assets/image-20240616141642877.png)

管理权转移后,ap1就成了**垂悬指针**,导致后续代码不好维护,容易出错.很多公司明确规定不能使用auto_ptr.

> 垂悬指针:指向曾经存在的对象，但该对象已经不再存在了，此类指针称为悬垂指针。结果未定义，往往导致[程序错误](https://baike.baidu.com/item/程序错误/4605473?fromModule=lemma_inlink)，而且难以检测。



### Boost库中的智能指针

>Boost库
>
>为C++语言标准库提供扩展C++程序库的总称
>
>Boost库是为C++语言标准库提供扩展的一些C++程序库的总称，由Boost社区组织开发、维护。Boost库可以与C++标准库完美共同工作，并且为其提供扩展功能。
>
>Boost库是为C++语言标准库提供扩展的一些C++程序库的总称。
>
>Boost库由Boost社区组织开发、维护。其目的是为C++程序员提供免费、同行审查的、可移植的程序库。Boost库可以与C++标准库共同工作，并且为其提供扩展功能。Boost库使用Boost License来授权使用，根据该协议，商业或非商业的使用都是允许并鼓励的。
>
>Boost社区建立的初衷之一就是为C++的标准化工作提供可供参考的实现，Boost社区的发起人Dawes本人就是C++标准委员会的成员之一。在Boost库的开发中，Boost社区也在这个方向上取得了丰硕的成果。在送审的C++标准库TR1中，有十个Boost库成为标准库的候选方案。在更新的TR2中，有更多的Boost库被加入到其中。从某种意义上来讲，Boost库成为具有实践意义的准标准库。
>
>大部分boost库功能的使用只需包括相应头文件即可，少数（如正则表达式库，文件系统库等）需要链接库。里面有许多具有工业强度的库，如graph库。
>
>很多Boost中的库功能堪称对语言功能的扩展，其构造用尽精巧的手法，不要贸然的花费时间研读。Boost另外一面，比如Graph这样的库则是具有工业强度，结构良好，非常值得研读的精品代码，并且也可以放心的在产品代码中多多利用。

boost中有两套智能指针比较知名

- scoped_ptr
- shard_ptr/weak_ptr

它们分别是C++11标准库中的unique_ptr与shared_ptr/weak_ptr的前身.

#### unique_ptr

原理:防拷贝

在很多情况下,不允许对象拷贝,使用unique_ptr就能很好解决这类问题.比如i/ostring防拷贝,线程类缓冲区问题,mutex唯一性等,拷贝后冲突,拷贝代价大等这问题通过禁止拷贝能很好的解决.

#### 模拟实现unique_ptr例程

原理:封掉拷贝构造和赋值重载

```
namespace test {
    template<class T>
    class unique_ptr {
    public:
        unique_ptr(T* ptr) :_ptr(ptr)
        {}
        ~unique_ptr() {
            delete _ptr;
            std::cout << "delete ptr" << "\n";
        }
        T& operator*() {
            return *_ptr;
        }
        T* operator->() {
            return _ptr;
        }

        //C++11封拷贝 
        unique_ptr(const unique_ptr<T>& up) = delete;
        unique_ptr<T>& operator = (const unique_ptr<T>&up) = delete;
    private:
        //C++98封拷贝
        //unique_ptr(const unique_ptr<T>& up); //C++98
        //unique_ptr<T>& operator=(const unique_ptr<T>&up);

        T* _ptr;
    };
}
```

![image-20240616152254421](智能指针.assets/image-20240616152254421.png)
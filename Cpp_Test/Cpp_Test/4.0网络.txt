
阿帕网 arpanet
  阿帕网为美国国防部高级研究计划署开发的世界上第一个运营的封包交换网络，它是全球互联网的始祖。


局域网 LAN(Local Area Network ):通过路由器和交换机把计算机连接在一起
广域网 WAN(Wide Area Network )
//广域网和局域网没有明显的界限,是一个相对的概念,一般把只经过交换机,而不经过路由器的网络称为局域网.经过路由器的叫广域网


局域网的一般原理: 主机向局域网内发数据,其他的所有主机都能收到.其他主机通过不同的抓包方式,获取需要的数据包,从而达到通信
//以太网是局域网的一种实现方式

$$  网络效应 network effect（也称网络外部性 network externality 或需求方规模经济 demand-side economies of scale)，
是一个经济学和商业方面的术语，用于描述对于一个产品（或服务），每增多一名用户，都会对该产品的其他用户产生新的价值。
当网络效应出现时，产品（或服务）的价值，会随着使用该产品（或服务）的人数的增加而增加。
/*
一个经典的例子是电话，越多的人使用电话，对每个电话使用者的价值就越大。
     一部电话的使用者，本来无意为其他用户创造价值，但当大家都购买电话时，这个行为就产生了正外部性。
像微信、微博、Twitter、Facebook 这样的线上社交网络，也是一样，随着更多用户的加入，每个用户获得的价值都在增加。
当网络的价值越来越大，越来越多的人加入时，网络效应还会带来从众效应，从而形成正反馈循环。
     网络效应这一表述不仅适用于正向的网络外部性，如电话的案例；消极的网络外部性也可能发生，即用户越多，产品的价值就越低，
这种情况通常被称为“拥堵”，例如交通拥堵或网络拥堵。
*/

网络技术盈利方式较少,大多数都是一套标准,谁做的好就用谁的






$$ 协议
"协议"是一种约定,遵守协议能够大大减少沟通成本

$$ 网络协议初识
//目前最主流的协议是TCP/IP协议



 
$$ 网络协议的层状结构

来源:传输举例变长,产生各种问题
1.长距离传输,数据异常的问题(丢失)
2.如何定位一台主机
3.怎么进行数据转发,和路径选择(路由,中间主机...)
4.01010...01等硬件级别的协议 

上面的问题,是有先后上下起因关系的 ,如传输数据前必须先定位主机位置.如何传输,用什么方式...
    ---> 因此我们可以在设计的时候将不同的功能模块设计成不同的模块,并根据先后上下关系,最终设计成层状结构


// 继承体系也是一种软件分层
//任何计算机问题都可以在中间加一层软件层来解决 ---> 软件分层在软件中很常见

软件分层之后,每一层都只关注自己同层的功能,只使用下层的接口,任何一层出现问题,都不会直接影响另一层,减少后期开发者的维护成本
    软件出现问题后,工程师一般会先定位问题在哪一层,然后再解决问题.
    ---> 高内聚,低耦合



$ OSI七层模型
OSI（Open System Interconnection，开放系统互连）七层网络模型称为开放式系统互联参考模型，是一个逻辑上的定义和规范;
OSI把网络从逻辑上分为了7层. 每一层都有相关、相对应的物理设备，比如路由器，交换机;
OSI 七层模型是一种框架性的设计方法，其最主要的功能使就是帮助不同类型的主机实现数据传输; 
    .它的最大优点是将服务、接口和协议这三个概念明确地区分开来，概念清楚，理论也比较完整. 
通过七个层次化的结构模型使不同的系统不同的网络之间实现可靠的通讯;
但是, 它既复杂又不实用; 所以我们按照TCP/IP四层模型来讲解.


//实际实现时,把5-会话层,6-表示层,7-应用层 合并成1层:5-应用层
TCP/IP五层模型包括了物理层(硬件),四层模式不包括物理层(通常)

$$ TCP/IP五层(或四层)模型
TCP/IP是一组协议的代名词，它还包括许多协议，组成了TCP/IP协议簇. 
TCP/IP通讯协议采用了5层的层级结构，每一层都呼叫它的下一层所提供的网络来完成自己的需求.
    .物理层: 负责光/电信号的传递方式. 比如现在以太网通用的网线(双绞 线)、早期以太网采用的的同轴电缆
(现在主要用于有线电视)、光纤, 现在的wifi无线网使用电磁波等都属于物理层的概念。物理层的能力决
定了最大传输速率、传输距离、抗干扰性等. 集线器(Hub)工作在物理层.
    .数据链路层: 负责设备之间的数据帧的传送和识别. 例如网卡设备的驱动、帧同步(就是说从网线上检测
到什么信号算作新帧的开始)、冲突检测(如果检测到冲突就自动重发)、数据差错校验等工作. 有以太
网、令牌环网, 无线LAN等标准. 交换机(Switch)工作在数据链路层.
    .网络层: 负责地址管理和路由选择. 例如在IP协议中, 通过IP地址来标识一台主机, 并通过路由表的方式规
划出两台主机之间的数据传输的线路(路由). 路由器(Router)工作在网路层.
    .传输层: 负责两台主机之间的数据传输. 如传输控制协议 (TCP), 能够确保数据可靠的从源主机发送到目标主机.
    .应用层: 负责应用程序间沟通，如简单电子邮件传输（SMTP）、文件传输协议（FTP）、网络远程访问
协议（Telnet）等. 我们的网络编程主要就是针对应用层

物理层我们考虑的比较少. 因此很多时候也可以称为 TCP/IP四层模型.
一般而言
对于一台主机, 它的操作系统内核实现了从传输层到物理层的内容;
对于一台路由器, 它实现了从网络层到物理层;
对于一台交换机, 它实现了从数据链路层到物理层;
对于集线器, 它只实现了物理层;
但是并不绝对. 很多交换机也实现了网络层的转发; 很多路由器也实现了部分传输层的内容(比如端口转发);



// 这些网络分层结构就是协议栈 -- 网络协议栈

   
用户层                    ...                     | 应用层
   |-----------------------------------------------------------------
sys_call      文件系统调用  键盘  显示器  ...     | 网络系统调用
   |----------------------------------------------------------------
   |                                              | 传输层    (TCP协议)
  OS       进程管理 文件系统  内存管理 驱动管理...| 网络层    (IP协议)
   |-----------------------------------------------------------------
 驱动   键盘驱动  显示器驱动  声卡  ...           |  网卡驱动 (数据链路层)
   |-----------------------------------------------------------------
 硬件   键盘       显示器     声卡  ...           |    网卡   (物理层)


网络也是属于OS一部分,OS和网络不分家

网络协议栈最核心的部分是属于操作系统的部分 传输层(TCP协议)和网络层(IP协议) . 所以一般以TCP/IP协议栈命名

linux中一切皆文件,网络在linux中也不例外.在linux系统中隶属于文件系统模块

OS有很多款,但网络只能有1种(网络指TCP/IP层,且必须是一样的).

数据链路层是有多种标准的,最常见的是以太网.
    为什么有多种标准? 局域网环境不同,硬件实现 等不同而不同


物理层是基础
数据链路层是丰富
网络层重点是提供了能力,但有能力传输,但不一定可靠
传输层重点是"可靠"传输
应用层是使用数据,根据不同场景有不同的实现(应用程序).

一般而言,上层的一定有下层的所有功能,下层的一般不会有上层的功能.
如路由器一般工作在网络层,但有些路由器具备应用层的功能







1.同一个局域网(子网)
    同一个局域网的两台机器,可以直接通信.如cs局域网联机.如一条网线连接两台电脑可以识别...
实质:两个主机通信的实质是,两个主机的OS在通过网络协议栈进行通信

网络协议栈的每一层,都要有自己的协议.
协议的表现形式:报头/协议报头

报文:报头+有效载荷

//在物流体系中:物流的主体是快递单+商品. 快递单是报头,商品是数据

用户向另一台主机发送数据的过程:
把数据从应用层,层层往下传,每一层都会把上一层发来的数据加工/封装(加上自己的报头),依次传到物理层,发送给另一台主机的硬件(物理层),然后层层往上传

接收数据的过程:
数据从物理层接收到后,将数据层层往上传,每一层都会把自己所在层的报头去掉,把有效载荷传给上一层

逻辑上,同层协议,都认为自己在和对方的同层协议在通信

同一层都能够互相认识对方的报头,所以
a.能将报头和有效载荷进行分离
b.将有效载荷交付给上一层的哪个具体协议 --- 数据包分用功能
//这是每层协议都要有的公共功能




有效载荷:对每一层所接收到的上一层数据叫做"有效载荷",有效载荷是上一层交付给自己的数据
每一层的协议 = 自己的报头(header)+有效载荷



发送:自顶向下 --- 封装
接收:自底向上 --- 解包+分用




局域网的一般原理: 主机向局域网内发数据,其他的所有主机都能收到.其他主机通过不同的抓包方式,获取需要的数据包,从而达到通信

过滤模式:把不是发给自己的数据包丢弃掉     -- 常规
混杂模式:把局域网内抓到的所有包都收集起来 -- 抓包软件的抓包原理,把网卡的工作模式设为混杂


局域网的数据碰撞问题:数据量大了,冲突的概率变大,导致系统处理不过来...


局域网中,任何时刻,只允许一个人在向局域网发送消息?

任何人要通信,需要有唯一的一个标识符
对机器也是如此,每台机器都配有网卡,网卡在出产时,就在网卡内部写入了sn号(出产序列号,机器码、认证码、注册申请码等)
每块网卡出厂时，都预先分配了一个全球唯一的 MAC地址 ，并烧进硬件。 不管后来网卡身处何处，接入哪个网络，MAC 地址均不变。 
当然，某些操作系统也允许修改网卡的 MAC 地址。


MAC网络协议中的链路层地址，又称物理地址，有兴趣查查网络七层协议，ID一般指的是这个设备的编号或者名字，
而SN是这个设备的序列号， 一般是设备厂商用来唯一标识这个设备用的，就跟身份证号一样

局域网通过mac地址来识别










网卡管理
Linux 上有不少工具命令可以查看系统当前接入的网卡以及每张网卡的详细信息。

首先是 ifconfig 命令，他默认显示已启用的网卡，详情中可以看到每张网卡的物理地址：
//if:interfaces

fasion@u2004 [ ~ ]  ➜ ifconfig
enp0s3: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 10.0.2.15  netmask 255.255.255.0  broadcast 10.0.2.255 
           //inet就是ip网络,就是ip地址,这里是内网的ip地址,公网的看不到 //Internet
        inet6 fe80::a00:27ff:fe49:50dd  prefixlen 64  scopeid 0x20<link>
        ether 08:00:27:49:50:dd  txqueuelen 1000  (Ethernet)   
           //ether 以太,表示基于以太网表示的mac地址, 48位,每个字节用冒号:分隔,以十六进制表示
        

        RX packets 3702  bytes 4881568 (4.8 MB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 538  bytes 42999 (42.9 KB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

enp0s8: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 192.168.56.2  netmask 255.255.255.0  broadcast 192.168.56.255
        inet6 fe80::a00:27ff:fe56:831c  prefixlen 64  scopeid 0x20<link>
        ether 08:00:27:56:83:1c  txqueuelen 1000  (Ethernet)
        RX packets 4183  bytes 1809871 (1.8 MB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 2674  bytes 350013 (350.0 KB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536
        inet 127.0.0.1  netmask 255.0.0.0
        inet6 ::1  prefixlen 128  scopeid 0x10<host>
        loop  txqueuelen 1000  (Local Loopback)
        RX packets 679  bytes 1510416 (1.5 MB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 679  bytes 1510416 (1.5 MB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
例子中，系统总共有 3 块已启用网卡，名字分别是 enp0s3 、 enp0s8 以及 lo 。其中 lo 是环回网卡，用于本机通讯。ether 08:00:27:49:50:dd 表明，网卡 enp0s3 的物理地址是 08:00:27:49:50:dd 。

请注意，ifconfig 是一个比较老旧的命令，正在慢慢淡出历史舞台。
ip 命令也可以查看系统网卡信息，默认显示所有网卡：

fasion@u2004 [ ~ ]  ➜ ip link
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
2: enp0s3: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP mode DEFAULT group default qlen 1000
    link/ether 08:00:27:49:50:dd brd ff:ff:ff:ff:ff:ff
3: enp0s8: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP mode DEFAULT group default qlen 1000
    link/ether 08:00:27:56:83:1c brd ff:ff:ff:ff:ff:ff
ip 命令输出信息比较紧凑， link/ether 08:00:27:49:50:dd 这行展示网卡的物理地址。

ip 命令是一个比较新的命令，功能非常强大。它除了可以用于管理网络设备，还可以用于管理路由表，策略路由以及各种隧道。因此，推荐重点学习掌握 ip 命令的用法。







2.跨一个路由器的两个子网

$ 认识路由器:
   工作层:
    3.网络层 --- 首先工作在网络层,所以要有网络层的功能,然后下层的所有功能也都要有
    2.数据链路层
    1.物理层
路由器也是一台主机(通常称为节点),路由器一定要有路由的功能,即跨网络转发,所以路由器至少要级联两个子网,所以至少要有两个网络接口(两个以上接口)
//路由器就是把不同局域网连接起来的工具

// 令牌环:有token的主机才能发送数据包,也能保证任何时刻只能允许一台主机发送数据包.和以太网是两种不同的通信标准,不同的数据链路层的实现方案.

表示一台主机,用IP地址,能表示主机在公网环境的唯一性

目前是IPV4 ---> 4字节的整数,每个字节表示一个整数,范围是0-255
取值范围:[0.0.0.0 , 255,255,255,255] , 如192.168.x.y ,这种一般是字符串风格(点分十进制)表现的,用于给人看
int srcIP = XXX;
struct ip *p = (struct ip*)&srcip;
p->part1; //ip的第一部分
p->part2; //ip的第二部分
...

数据链路层有路由表,IP协议会判断主机是否在当前局域网内,如果不在才会发送给路由器 (默认路由)

IPB:最终目的,传输途中会根据IPB进行路径选择
目的mac:传输途中下一站的地址,根据选择的路径来决定下一跳主机


现象:IP层及以上,所有网络的传输都是没有差异. IP层一下的,物理层等,有不同的传输方式
说明:IP地址屏蔽了底层子网机制的差异!


$ 数据包封装和分用
不同的协议层对数据包有不同的称谓,
在应用层叫做请求-响应
在传输层叫做数据段/段(segment),
在网络层叫做数据报 (datagram),
在链路层叫做帧(frame).

应用层数据通过协议栈发到网络上时,每层协议都要加上一个数据首部(header),称为封装(Encapsulation). 
首部信息中包含了一些类似于首部有多长, 载荷(payload)有多长, 上层协议是什么等信息.
数据封装成帧后发到传输介质上,到达目的主机后每层协议再剥掉相应的首部, 根据首部中的 "上层协议
字段" 将数据交给对应的上层协议处理


题目描述：
实现函数将 unsigned int 整型数值转为点分十进制记法表示：
点分十进制（Dotted Decimal Notation）全称为点分（点式）十进制表示法，
是IPv4的IP地址标识方法。
IPv4中用四个字节表示一个IP地址，每个字节按照十进制表示为0~255。
点分十进制就是用4个从0~255的数字，来表示一个IP地址。
char * my_DotDec(unsigned int ip,char *buffer);
参数说明：
value：欲转换的数数值。
buffer：目标字符串的地址。
示例： ip = 2148205343; buffer = “128.11.3.31”;

分析：
灵活地利用联合体内存共享的特点
题目中要求将数字转换成字符串，我们就要想到使用sprintf函数，
union IPNode
{
 unsigned int addr;
 struct
 {
  unsigned char part1;
  unsigned char part2;
  unsigned char part3;
  unsigned char part4;
 };
};
char* my_DotDec(unsigned int ip,char *buffer)
{
 IPNode x;
 x.addr = ip;      
 sprintf(buffer,"%d.%d.%d.%d",x.s4,x.s3,x.s2,x.s1); 
 return buffer;         
}
注意事项:
windows系统下栈是在低地址，堆在高地址，栈和堆从中间向两头扩展，LINUX系统上是从两头向中间扩展，
pc端是小端–低地址存放低数据而x又是从堆上开辟的(因为结构体的定义是在函数的外面，
如果结构体定义在函数内部就是从栈上开辟)，堆是由低地址向高地址开辟内存，
所以s4在高地址，存放的是大数据。sprintf函数的第一个参数是字符串的输入指向char指针型，
第二个参数是控制输入的字符的形式(%d,%f,%0x,%x)，用“ ”括起来，第三个参数是输入的数据。





$$ 网络中的地址管理
$ 认识IP地址
IP协议有两个版本, IPv4和IPv6. 我们整个的课程, 凡是提到IP协议, 没有特殊说明的, 默认都是指IPv4
IP地址是在IP协议中, 用来标识网络中不同主机的地址;
对于IPv4来说, IP地址是一个4字节, 32位的整数;
我们通常也使用 "点分十进制" 的字符串表示IP地址, 例如 192.168.0.1 ; 用点分割的每一个数字表示一个
字节, 范围是 0 - 255;

$ 认识MAC地址
MAC地址用来识别数据链路层中相连的节点;
长度为48位, 及6个字节. 一般用16进制数字加上冒号的形式来表示(例如: 08:00:27:03:fb:19)
在网卡出厂时就确定了, 不能修改. mac地址通常是唯一的(虚拟机中的mac地址不是真实的mac地址, 可
能会冲突; 也有些网卡支持用户配置mac地址).

$ 理解源IP地址和目的IP地址
唐僧例子1 在IP数据包头部中, 有两个IP地址, 分别叫做源IP地址(用于回复), 和目的IP地址.
思考: 我们光有IP地址就可以完成通信了嘛? 想象一下发qq消息的例子, 有了IP地址能够把消息发送到对方的机器上,
但是还需要有一个其他的标识来区分出, 这个数据要给哪个程序进行解析.


网络通信的数据包都有两套地址
1.源IP和目的IP   //起点和终点
2.源mac和目的mac //上一站和下一站

$ 目的IP:为报文定制最终目标,路上根据该地址进行路径选择.
$ 目的mac:根据路径选择的结果,来选择下一跳的主机.



网络通信其实是进程间通信.属于进程间通信的范畴
1.先将数据通过OS发送到目标主机,手段:TCP/IP协议完成.IP可以表示在互联网上唯一一台主机.
2.主机收到的数据,要推送给自己上层的指定进程.  ---> 如何标识自己主机上网络进程?

$ 标识主机上网络进程: 端口号
认识端口号:
1.端口号(port)是传输层协议的内容
  a.端口号是一个2字节的整数
  b.端口号用来标识一个进程
  c.IP地址+端口号能够标识网络上某一台主机的某个进程
  d.一个端口号只能被一个进程占用


$ 理解源端口号和目的端口号
唐僧例子2
送快递例子
传输层协议(TCP和UDP)的数据段中有两个端口号, 分别叫做源端口号和目的端口号. 就是在描述 "数据是谁发的, 要
发给谁";


"源IP,源端口 --- 目标IP,目标端口" 方案称为:套接字通信/socket通信

$ 网络通信的本质:
是 通过IP+PORT构建进程唯一性.来进行的基于网络的进程间通信.

为什么不用PID?
1.不是所有的进程都要进行网络通信.使用PID会导致难以区分哪些进程进行网络  通信,哪些进程不是
2.PID属于进程管理模块,如果网络通信使用PID,则网络模块也要有进程管理模块.会增加进程管理和网络管理的耦合度.(重点)


$ 一个进程可以关联多个端口号, 但一个端口号只能关联1个进程
//一个进程可以关联多个端口号是什么意思?

$ TCP/IP的数据报文里有一个四元组字段:
   src_ip  src_port  dst_ip  dst_port [ payload ]

$ 一个端口号只能关联1个进程,一个进程可以关联多个端口号的实现方式:hash表/hash数组



socket”为什么翻译为“套接字”
/*
  概念:套接字基本是两个端点的程序之间信息通道
  首先套接字原词为“socket”，直译就是插座的意思，最先采用这个词的人，觉得网络连接，就像插口和插座一样，一方插，一方被插（知乎用户的回答）。
除此之外，linux等系统中“套接字”对应“socket word”，所以“字”也就是对应“word”，
这个“word”可能指储存socket的数据标识，因为端口号是两字节，就是一个WORD。

  赞同的解释是：套接指的是套接管，就是将两根水管套接起来的管子，
然后“字”是此连接的数据标识，即一个WORD，所以套接字就是一个标识连接的数据体。
*/



认识TCP协议
TCP(Transmission Control Protocol 传输控制协议) //面向链接的协议
  .传输层协议
  .有连接
  .可靠传输 // 数据丢失能自动补发
  .面向字节流 //不关心读到的数据如何解释,只关心接收到多少数据,然后传多少数据给上层应用,由上层应用解释数据


UDP(User Datagram Protocol 用户数据报协议)
传输层协议
无连接     //通信前不建立通信
不可靠传输  //真丢失
面向数据报



网络字节序 
规定:大端
用途:统一网络传输过程中的传输序列

网络字节序
我们已经知道,内存中的多字节数据相对于内存地址有大端和小端之分, 
   磁盘文件中的多字节数据相对于文件中的偏移地址也有大端小端之分, 
   网络数据流同样有大端小端之分. 那么如何定义网络数据流的地址呢?
1.发送主机通常将发送缓冲区中的数据按内存地址从低到高的顺序发出;
2.接收主机把从网络上接到的字节依次保存在接收缓冲区中,也是按内存地址从低到高的顺序保存;
3.因此,网络数据流的地址应这样规定:先发出的数据是低地址,后发出的数据是高地址. 
//理解:低地址先进队列,而队列头是高地址

TCP/IP协议规定,网络数据流应采用大端字节序,即低地址高字节.  //规定
不管这台主机是大端机还是小端机, 都会按照这个TCP/IP规定的网络字节序来发送/接收数据;
如果当前发送主机是小端, 就需要先将数据转成大端; 否则就忽略, 直接发送即可;

//用户数据字节序无所谓,由用户协议定制



为使网络程序具有可移植性,使同样的C代码在大端和小端机器上编译后能够正常运行,
   可以调用以下库函数做网络字节序和主机字节序的转换.(方便和提高可读性)
{
常用:整数,端口号

注:recvfrom,sendto函数等,以及TCP的读写方法,会自动进行大小端转换,只有服务器启动,bind等阶段,才需要用户手动进行大小端转换

#include <arpa/inet.h>
  //主机转网络
  uint32_t htonl(uint32_t hostlong);  //h:host(本主机) to n:network(网络) l:long(32位长整数主机)
  uint16_t htons(uint16_t hostshort); //h:host(本主机) to n:network(网络) s:short(16位短整数主机)
  //描述:: htonl表示:将32位的长整数从主机字节序转换成网络字节序,例如将端口号转换后准备发送

  //网路转主机
  uint32_t ntohl(uint32_t netlong);  
  uint16_t ntohs(uint16_t netshort);

  //只有小端才会转,大端不做变换
}

不同风格的ip转换接口
{
//man inet
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
       int inet_aton(const char *cp, struct in_addr *inp); 
       //和inet_addr差不多,二选一.inet_aton(serverip.c_str(),&server.sin_addr); 

       in_addr_t inet_addr(const char *cp);    
       //将点分十进制的IP地址转换成4字节地址,并由主机地址转成网络字节序的地址

       in_addr_t inet_network(const char *cp);

       char *inet_ntoa(struct in_addr in);   
       //将IP转成点分十进制(字符串)
    注意:这个函数不一定是线程安全的(看平台实现).因为他创建的字符串常量,放在常量区,多次调用这个函数,可能会出现覆盖上一次的结果
        所以最好用inet_ntop / inet_pton
多线程调用inet_ntoa测试代码,在需要测试的平台上测试
{
#include <stdio.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>
    void* Func1(void* p) {
     struct sockaddr_in* addr = (struct sockaddr_in*)p;
     while (1) {
     char* ptr = inet_ntoa(addr->sin_addr);
     printf("addr1: %s\n", ptr);
     }
     return NULL;
    }
    void* Func2(void* p) {
     struct sockaddr_in* addr = (struct sockaddr_in*)p;
     while (1) {
     char* ptr = inet_ntoa(addr->sin_addr);
     printf("addr2: %s\n", ptr);
     }
     return NULL;
    }
    int main() {
     pthread_t tid1 = 0;
     struct sockaddr_in addr1;
     struct sockaddr_in addr2;
     addr1.sin_addr.s_addr = 0;
     addr2.sin_addr.s_addr = 0xffffffff;
     pthread_create(&tid1, NULL, Func1, &addr1);
     pthread_t tid2 = 0;
     pthread_create(&tid2, NULL, Func2, &addr2);
     pthread_join(tid1, NULL);
     pthread_join(tid2, NULL);
     return 0;
    }

} //测试代码__End;
Advanced Programming in the UNIX Environment(APUE) Unix环境高级编程 -- 教材

       struct in_addr inet_makeaddr(int net, int host);

       in_addr_t inet_lnaof(struct in_addr in);

       in_addr_t inet_netof(struct in_addr in);


}


socket常见API
{
//创建socket文件描述符 (TCP/UDP, 客户端+服务器)
int socket(int domain, int type, int protocol);

//绑定端口号 (TCP/UDP, 服务器)
int bind (int socket, const struct sockaddr *address, socklen_t address_len );

//开始监听socket (TCP, 服务器)
int listen(int socket, int backlog);

//接收请求 (TCP,服务器)
int accept(int socket,struct sockaddr* address, socklen_t address_len);


//建立链接 (TCP, 客户端)
int connet(int sockfd, const struct sockaddr *addr, socklen_t addrlen);

}

$ sockaddr结构 // addr通用的结构设计思想
{
sockaddr:套接字地址 / 通用地址结构

socket API 是一层抽象的网络编程接口,适用于各种底层网络协议,如IPv4,IPv6,以及UNIX Domain Socket.
    但各种网络协议的地址格式并不相同

sockaddr,          sockaddr_in,   sockaddr_un
|-------------|  |-------------|      |-------------|
|16位地址类型 |  |16位地址类型 |      |16位地址类型 |  //结构体相同的头部类型,用于区别不同sock类型
|             |  |  AF_INET    |      |  AF_UNIX    |  //是一个宏,整数
|-------------|  |-------------|      |-------------|
|             |  | 16位端口号  |      |             |
|             |  |-------------|      |             |
|14位地址数据 |  | 32位IP地址  |      |108字节路径名|
|             |  |-------------|      |             |
|             |  |  8字节填充  |      |14位地址数据 |
---------------  |   ...       |      |             |
                  -------------       |    ...      |
                                       -------------

1.sockaddr
结构:
   struct sockaddr {
	  sa_family_t sin_family;//地址族
	  char sa_data[14]; //14字节，包含套接字中的目标地址和端口信息               
　 };
注解:用于统一的父结构体(父类)


2.struct sockaddr_in
头文件:<arpa/inet.h>

C结构:
struct sockaddr_in
  {
//16位的地址类型
    __SOCKADDR_COMMON (sin_); // sa_family_t sin_family :协议家族
用途: 和socket()的domain一样,用于指定通信域
    /*
     #define __SOCKADDR_COMMON(sa_prefix) \                     
        sa_family_t sa_prefix##family                       
    //该宏用于声明用于套接字地址的数据类型的初始公共成员，`struct sockaddr'、sockaddr_in、sockaddr_un'等。  

    typedef unsigned short int sa_family_t; //无符号短整型

    
    */

//服务器要绑定的端口号 
 in_port_t sin_port;   // s:socket in:inet:Internet port:端口号 
    /*
        in_port_t : uint16_t;
    */

//ip地址
  struct in_addr sin_addr;  
     /*  // struct in_addr 的结构
      typedef uint32_t in_addr_t;                                                                                
      struct in_addr      //直接放uint32不行吗?为什么要用结构体
        {                                                                                                         
          in_addr_t s_addr;    //网络字节序的地址类型
        };  
     */

 
 //填充字段 -- 结构体很大,用不完,全部清零,填充满占位符
    /* Pad to size of `struct sockaddr'.填充到结构体sockaddr的大小  */
    unsigned char sin_zero[sizeof (struct sockaddr) -
         __SOCKADDR_COMMON_SIZE -
         sizeof (in_port_t) -
         sizeof (struct in_addr)];
};


}


//socket构建那时,C还没支持void*(不用强转,可以接收任意类型).所以代码比较丑陋,必须先强转才能传参


struct sockaddr_in //i:internet



$ int socket(int domain, int type, int protocol)
{

头文件:
   #include <sys/socket.h>

socket() creates an endpoint for communication and returns a descriptor.
socket（）创建一个通信端点并返回一个描述符。

RETURN VALUE
       On  success,  a  file descriptor for the new socket is returned.  On error, -1 is
       returned, and errno is set appropriately.
        成功将返回文件描述符

domain:
The  domain  argument specifies a communication domain;
域参数指定通信域；
       Name                Purpose                          Man page
       AF_UNIX, AF_LOCAL   Local communication              unix(7)  //本地通信,域间通信
       AF_INET             IPv4 Internet protocols          ip(7)    //IPv4网络通信
       AF_INET6            IPv6 Internet protocols          ipv6(7)

       AF_IPX              IPX - Novell protocols
       AF_NETLINK          Kernel user interface device     netlink(7)
       AF_X25              ITU-T X.25 / ISO-8208 protocol   x25(7)
       AF_AX25             Amateur radio AX.25 protocol
       AF_ATMPVC           Access to raw ATM PVCs
       AF_APPLETALK        Appletalk                        ddp(7)
       AF_PACKET           Low level packet interface       packet(7)
//AF: address familiers  地址家族
//PF: protocol familiers 协议家族
//两种写法都可以 如 AF_INET 或 PF_INET相同

type:
SOCK_STREAM  : 字节流,TCP用
                Provides  seq  uenced,  reliable,  two-way,  connection-based  byte streams. 
                    An out-of-band data transmission mechanism may be sup‐ ported.  

SOCK_DGRAM   : datagrams的简写    
                Supports datagrams  
                    (connectionless,  unreliable  messages  of  a fixed maximum length).  

protocol:
        默认为0,根据传输数据类型自动识别传输协议

}



$ 绑定
{
声明:int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
头文件:
    #include<sys/types.h>
    #include<sys/socket.h>

sockfd: 套接字文件描述符

struct sockaddr *addr:

addrlen: 解决sock_addr,sockaddr_in,sockaddr_un等类型大小不一致的问题,得到地址后再根据长度来获得完整的类型

注:只有在绑定阶段,才需要用户手动字节序转换

 
 
 
}

$ 问题1: 云服务器不允许用户直接绑定IP地址
{
 报错:  bind socker error : Cannot assign requested address
     
 原因:  云服务器,不需要bind IP地址,需要让服务器自己指定IP地址,
       因为云服务器,或服务器,一般会有多张网卡 , 但bind只能绑定一个,即只传数据给一张网卡,就会导致接收的数据量变少.
       而我们期望只要是发送到这台机器上的数据,都要接收.所以,不允许使用IP来甄别数据,而是使用端口,只要是这个端口的,我都接收.
       因此: 服务器或云服务器不允许使用明确的IP.
   注:自己本地装的虚拟机,或者物理机器是允许的.
 
 如何让服务器自己指定IP地址?
 解决:  使用宏INADDR_ANY 来让我们的server在启动时,bind本主机上的任意IP/自 动分配IP
 //用例: local.sin_addr.s_addr = INADDR_ANY; //如果置零sockaddr_in了,不写也行
 //#define	INADDR_ANY		((in_addr_t) 0x00000000)


}


数据接收 --  receive
{
//man 2 recv

接口:recvfrom
声明:ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,struct sockaddr *src_addr, socklen_t *addrlen);
参数:
   sockfd:套接字
   buf:  用户定义的缓冲区
   len:  缓冲区大小
   flags: 读取方式,默认读取方式为阻塞读取,目前只需要设置为0;
   sockaddr*: 输出型参数,存放着发送方的IP和Port.
   socklen_t: sockaddr的实际长度
返回值:  ssize_t , 实际读到的字节数
注意: 缓冲区内的数据是什么类型是未知的,需要由程序员制定协议来规定. 目前先设为C风格字符串
//peer 对等,对方 ,相同(地位/年龄)的人

//自动进行大小端转换

}

数据接收 - sendto
{
声明:ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen);
参数:和recvfrom差不多


//自动进行大小端转换

}



netstat 
{
   netstat 命令用于显示各种网络相关信息，如网络连接，路由表，接口状态 (Interface Statistics)，
  masquerade 连接，多播成员 (Multicast Memberships,即一对多通信) 等等。

  选项:
-a (all)显示所有选项，默认不显示LISTEN相关
-t (tcp)仅显示tcp相关选项
-u (udp)仅显示udp相关选项
-n 拒绝显示别名，能显示数字的全部转化成数字。
-l 仅列出有在 Listen (监听) 的服务状态
-p 显示建立相关链接的程序名,(进程process)
-r 显示路由信息，路由表 (router)
-e 显示扩展信息，例如uid等 (extend)
-s 按各个协议进行统计   (stat)
-c 每隔一个固定时间，执行该netstat命令。 (cycle)

#以下不常用
-I    # 显示iFace接口表
-i    # 显示接口表
-g    # 显示多播组成员
-s    # 显示网络统计数据（如SNMP）
-M    # 显示伪装连接
-v    # 显示详细verbose
-W    # 不要截断IP地址
-N    # 解析硬件名称
-e    # 显示其他/更多信息
-o    # 显示计时器


例:
[chj@kk ~ 14:34:33]$ netstat -nupa
(Not all processes could be identified, non-owned process info
 will not be shown, you would have to be root to see it all.)
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
udp        0      0 0.0.0.0:716             0.0.0.0:*                           -
udp        0      0 0.0.0.0:8080            0.0.0.0:*                           7600/./server    //0.0.0.0表示任意IP/随机绑定IP.
udp        0      0 0.0.0.0:68              0.0.0.0:*                           -
udp        0      0 0.0.0.0:111             0.0.0.0:*                           -
udp        0      0 127.0.0.1:323           0.0.0.0:*                           -
udp6       0      0 127.0.0.1:60880         127.0.0.1:38457         ESTABLISHED -
udp6       0      0 :::716                  :::*                                -
udp6       0      0 :::111                  :::*                                -
udp6       0      0 ::1:323                 :::*                                -


查看端口号占用情况
netstat -ano

查看活动连接数
netstat -antpu |grep 8888

}

$$ 0.0.0.0和127.0.0.1
{
$ 0.0.0.0
IPV4中，0.0.0.0地址被用于表示一个无效的，未知的或者不可用的目标。

在服务器中，0.0.0.0指的是本机上的所有IPV4地址，如果一个主机有两个IP地址，192.168.1.1 和 10.1.2.1，并且该主机上的一个服务监听的地址是0.0.0.0,那么通过两个ip地址都能够访问该服务。
在路由中，0.0.0.0表示的是默认路由，即当路由表中没有找到完全匹配的路由的时候所对应的路由。
用途总结
当一台主机还没有被分配一个IP地址的时候，用于表示主机本身。（DHCP分配IP地址的时候）
用作默认路由，表示”任意IPV4主机”。
用来表示目标机器不可用。

用作服务端，表示本机上的任意IPV4地址。




$ 127.0.0.1
127.0.0.1属于{127,}集合中的一个，而所有网络号为127的地址都被称之为回环地址，所以回环地址！=127.0.0.1,它们是包含关系，即回环地址包含127.0.0.1。
//本地环回,就表示当前主机,通常用来进行本地通信或者测试. --- 走一遍网络协议栈后发回来给自己
回环地址：所有发往该类地址的数据包都应该被loop back(发回来)。



$ localhost
相比127.0.0.1，localhost具有更多的意义。localhost是个域名，而不是一个ip地址。
之所以我们经常把localhost与127.0.0.1认为是同一个是因为我们使用的大多数电脑上都讲localhost指向了127.0.0.1这个地址。

用途
回环测试,通过使用ping 127.0.0.1 测试某台机器上的网络设备，操作系统或者TCP/IP实现是否工作正常。
DDos攻击防御：网站收到DDos攻击之后，将域名A记录到127.0.0.1，即让攻击者自己攻击自己。
大部分Web容器测试的时候绑定的本机地址。

}


client and server
{
一.客户端不需要自己绑定端口号,由系统自动绑定
    因为客户端中有很多进程,假设客户端端口号是固定的,如果出现相同进程同时使用同一个端口号,就会导致冲突,必定有一个进程无法运行.
  所以客户端的端口号不能是一个固定的端口号.交由操作系统自动为客户端选择端口号.
  

二.服务端的端口号必须是众所周知且不能随意改变的,和110等公共电话一样
   //不同服务器的端口号可以一样


server和service的区别主要体现在以下三个方面：
1. 含义不同server 主要有两种含义，一是服务器，二是服务器上安装的应用程序。
  service 则主要有三种含义，一是服务，二是服务端程序中包含的一种服务（也就是一个函数），三是动词提供服务。
2. 侧重不同server侧重于表示提供服务的硬件设备，比如电脑服务器、云服务器等。
  service侧重于表示软件层面上的服务，比如应用程序、系统服务等。
3. 语境不同在计算机领域，server通常指的是服务器，是提供计算服务的设备。
  service通常指的是应用程序或系统服务，是一种软件层面的服务。
4. 总的来说，server和service虽然都与“服务”有关，但在实际使用中，需要根据具体的语境来选择使用哪个词。


}


测试
{
端口分 tcp、udp

测试TCP,使用telnet:
1. telnet 使用的是 tcp 协议
2. telnet 公网IP 端口号
    能连接成功说明可以访问

测试UDP,使用netcat
1.服务端使用 nc -uvlp 端口号
2.客户端使用 nc -u 公网IP 端口号
客户端发送消息后服务端能回显说明可以访问

检查linux防火墙
systemctl status firewalld
iptables -nL

查看IP
https://www.ip138.com/

查看端口号占用情况
netstat -ano

查看活动连接数
netstat -antpu |grep 8888



}




$ 网络多服务器多线程
{

网络编程中， 经常要使用到回调函数。 当底层的网络框架有数据过来时，往往通过回调函数来通知业务层。 这样可以使网络层只专注于 数据的收发， 而不必关心业务
在c语言中， 回调函数的实现往往通过函数指针来实现。 但是在c++中 ， 如果回调函数是一个类的成员函数。这时想把成员函数设置给一个回调函数指针往往是不行的
因为类的成员函数，多了一个隐含的参数this。 所以直接赋值给函数指针肯定会引起编译报错
c++11 为我们带来了bind， 可以很好的解决这个问题
//用于线程执行类成员方法
}


$ TCP相关函数
{

//在TCP中,socket创建的套接字叫监听套接字,用于获取通信连接

1.listen
    man : man 2 listen 
    声明:int listen(int sockfd, int backlog);
    头文件:
       #include <sys/types.h>
       #include <sys/socket.h>
    参数:
        a. sockfd:监听套接字
        b. backlog
    返回值:
        成功返回0,错误返回-1,并设置错误码


2.accpet
    man : man 2 accpet
    声明:int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
    头文件:
        #include<sys/types.h>
        #include<sys/socket.h>
    参数:
        a. sockfd:监听套接字,socket函数的返回值,
        b/c. 输出型参数,返回客户端的套接字地址 
    返回值:
        返回tcp服务的文件描述符

3.connect
    man 2 connect
    声明:int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
    参数:和accpet相同,用于连接服务端,向目标地址发起连接
    返回值:连接(或绑定)成功,返回0,否则返回-1,并设置错误码
    //建立连接成功后会自动bind


}

TCP客户端/服务器
{
服务器:监听,TCP需要监听是否有需要与服务器建立连接的客户端

服务器:
1.不需要监听(listen).客户端只需要向服务器发起连接请求
2.connect成功后,会自动bind



}

TCP中信息传递手段
{
1.read/write


}

TCP错误问题
{
./server: socket bind error :Address already in use

}



日志
{


       #include <stdarg.h>

       int vprintf(const char *format, va_list ap); //只需要初始化ap,格式转换由vprintf完成,然后打印到显示器
       //如果不想打印到显示器上,下面3个打印到字符串,文件等其他缓冲区中...
       int vfprintf(FILE *stream, const char *format, va_list ap); 
       int vsprintf(char *str, const char *format, va_list ap);
       int vsnprintf(char *str, size_t size, const char *format, va_list ap);





$ 时间接口
1.time
2.gettimeofday
3.localtime

      
  }    
------------------------------------------------------
$ C语言可变参数用例演示

  enum
{
  DEBUG = 0,
  INFO,
  WARNING,
  ERROR,
  FATAL,
  UKNOWN //nknown
};

static std::string toLevelString(int level)
{
  switch(level)
  {
    case DEBUG:
      return "DEBUG"; //开源项目中很多是直接return,不使用break
    case INFO:
      return "INFO";
    case WARNING:
      return "WARNING";
    case ERROR:
      return "ERROR";
    case FATAL:
      return "FATAL";
    default:
      return "NKNOWN";
  }
}

static std::string getTime()
{
//struct tm
//  int tm_sec;			/* Seconds.	[0-60] (1 leap second) */
//  int tm_min;			/* Minutes.	[0-59] */
//  int tm_hour;			/* Hours.	[0-23] */
//  int tm_mday;			/* Day.		[1-31] */
//  int tm_mon;			/* Month.	[0-11] */
//  int tm_year;			/* Year	- 1900.  */
//  int tm_wday;			/* Day of week.	[0-6] */
//  int tm_yday;			/* Days in year.[0-365]	*/
//  int tm_isdst;			/* DST.		[-1/0/1]*/
 
 
  time_t curr = time(nullptr);
  struct tm *tmp = localtime(&curr); //参数事time_t类型的时间戳
  char buffer[128];
  snprintf(buffer,sizeof(buffer),"%d-%d-%d %d:%d:%d",tmp->tm_year+1900,tmp->tm_mon+1,tmp->tm_mday,tmp->tm_hour,tmp->tm_min,tmp->tm_sec);
  return buffer;
}

//日志格式: 日志等级 时间 文件 行 pid 消息体
void logMessage(int level, char *format, ...)     
    // levet:日志等级         
    // char * format, ... : 格式化可变参数 (可变参数要求必须有一个具体的参数)    // format实例:"hello %d %s"
    // 可变参数列表分为:具体参数+可变参数部分,即 具体类型+...    
  {                           
    //预备知识                
    //va_list p;////定义一个指针// VC5.0: typedef char *va_list 或其他平台 void*
    //va_start(p,format); //初始化,让p指向可变参数的 可变参数部分的起始地址,在紧贴着farmat之后 
    //va_arg(p,int); // 根据类型提取参数,那我怎么知道类型是什么? --> C语言%d,%s这些格式控制就是类型                                                            
    //va_end(p);    //很简单,就是不使用了,置空,p=NULL    
       
    //封装:stdarg.h --vprintf系列    
  char logLeft[1024] ; //左半部分:日志等级 时间 pid //文件和行有点麻烦, 先不做处理
  std::string level_string = toLevelString(level);
  std::string curr_time = getTime();
  snprintf(logLeft,sizeof(logLeft),"[%s] [%s] [%d] ",level_string.c_str(),curr_time.c_str(),getpid());

  char logRight[1024]; //右半部分:消息体
  va_list p;
  va_start(p,format);
  vsnprintf(logRight,sizeof(logRight),format,p);
  va_end(p);

  //打印
  printf("%s %s \n",logLeft,logRight);
  
  //或者保存到文件中,以后只需要在logMessage中修改定义就可以实现日志信息的流向


}




$ linux ps axj/efj 补充
{
[chj@47 ~ 17:47:27]$ ps axj
 PPID   PID    PGID        SID      TTY      TPGID STAT   UID   TIME COMMAND
             进程组Id    会话ID     终端

# PID.PPID.PGID.SID
.Process ID(PID)
    Linux中标识进程的一个数字，它的值是不确定的，是由系统分配的（但是有一个例外，启动阶段,kernel运行的第一个进程是init，
    它的PID是1，是所有进程的最原始的父进程），每个进程都有唯一PID，当进程退出运行之后，PID就会回收，可能之后创建的进程会分配这个PID
.Parent Process ID(PPID)
    字面意思，父进程的PID
.Process Group ID(PGID)
    PGID就是进程所属的Group的Leader的PID，如果PGID=PID，那么该进程是Group Leader
.Session ID(SID)
    和PGID非常相似，SID就是进程所属的Session Leader的PID，如果SID==PID，那么该进程是session leader
.Session和Group都是管理多个进程的方式，同一个Group的进程属于同一个Session，一个Session里可以包含多个Group
意义
group和session虽然都是进程的集合，但是他们的意义不同。fork出的子进程，会继承group和session（PGID和SID与父进程相同）
session与终端相关（Control terminal），同一个终端启动的进程默认会在一个session里。例如图形界面的终端（比如GNOME按ctrl+atl+T呼出的命令行界面），都是虚拟终端（Virtual terminal），他们实质上只有一个终端在真正起作用，输入w命令，可以看到所有的control terminal。
group则是方便管理，比如发送信号，kill可以一次向一个group的进程发送同一个信号，ctrl+z进入后台、bg、fg都可以对一个group的进程起作用。比如ctrl+z可以将一个group的进程stop暂停运行，fg可以让一个group继续运行

# TTY:终端:终端文件
    ?号表示 与终端没有关系
    pts/25  终端文件,一般在/dev/pts/下 --- pts/4说明这个进程终端关联了4号终端
    //就是显示命令行的地方
    如 echjo "hello world" > /dev/pts/5 //这样就是直接把hello world输出到终端5
    //一般把和终端有关的进程,一般与会话有关系


[chj@47 ~ 18:10:56]$ sleep 4000|sleep 5000 |sleep 6000 &
//...
[chj@47 ~ 18:08:17]$ sleep 10000|sleep 20000|sleep 30000
[chj@47 ~ 18:15:55]$ ps -axj|head -1 && ps axj|grep sleep
 PPID   PID  PGID   SID TTY      TPGID STAT   UID   TIME COMMAND
 3664  3717  3717  3664 pts/4     3717 S+    1000   0:00 sleep 10000
 3664  3718  3717  3664 pts/4     3717 S+    1000   0:00 sleep 20000
 3664  3719  3717  3664 pts/4     3717 S+    1000   0:00 sleep 30000
  636  3839   628   628 ?           -1 S        0   0:00 sleep 60
 3723  3840  3840  3723 pts/4     3845 S     1000   0:00 sleep 4000
 3723  3841  3840  3723 pts/4     3845 S     1000   0:00 sleep 5000
 3723  3842  3840  3723 pts/4     3845 S     1000   0:00 sleep 6000

 // 同时打开的,建立了管道通信的3个进程,属于同一个进程组,并且在同一个会话中(管道)
 // 属于同一个进程组时,组PID是以第一个进程的PID命名的
 //不是同时打开的两个进程,都属于同一个会话
 //同一个终端打开的所有进程,都是同一个会话 pts/N

[chj@47 ~ 18:19:07]$ ps -axj|head -1 && ps axj|grep 3723
 PPID   PID  PGID   SID TTY      TPGID STAT   UID   TIME COMMAND
 3722  3723  3723  3723 pts/4     3871 Ss    1000   0:00 -bash
 //说明 会话进程就是bash


 小结:
    会话>=进程组>=进程
    一个会话可以包含多个进程组,一个进程组可以包含多个进程
linux: 当用户登录linux时,linux会给用户创建一个会话,会话中至少有一个自成进程组的bash进程(命令行解释器)
   ( .进程组:用来组合式完成某种任务的几个进程.在用户视角,可以把进程组当作一个任务,这些进程组共同完成一个任务.
        进程组还分为 前台进程组,和后台进程组  //前台的意思就是让谁(哪一个进程组)去用这个终端
        //一个会话中任何时刻都只能有一个前台进程组在运行 --- 其他程序就无法从终端启动了
        //把前台任务ctrl+C干掉后,bash会自动成为前台任务.
  )
$ .打开一个终端(用户在别的终端登录,或者其他用户登录) === 创建新的会话 ---> 新的SID
$ .退出会话(退出登录)时,会销毁会话 --- > 可能会影响会话内部的所有任务/进程组(可能存在,可能会全部干掉,但不能保证不受影响)
$ .因此在linux中(不同OS不同做法),一般的网络服务器,为了不受到用户的登录注销的影响, 会以守护进程的方式进行运行

}


$$$ linux -- shell中控制进程组的命令
{
# jobs :查看当前会话的后台任务(看不到别的终端的) ,并且显示后台任务的任务号( [1]方括号括起来的那个编号就是)
[chj@47 ~ 18:37:59]$ jobs
[1]+  Running                 sleep 4000 | sleep 5000 | sleep 6000 &

# jobs -l //能看到PID
[chj@47 ~ 18:39:06]$ jobs -l
[1]+  3840 Running                 sleep 4000
      3841                       | sleep 5000
      3842                       | sleep 6000 &

# fg 任务号 //将后台任务调到前台
[chj@47 ~ 18:39:07]$ fg 1
sleep 4000 | sleep 5000 | sleep 6000
(恢复成前台卡住状态)

# ctrl+z  //将前台任务暂停,并自动转入后台

# bg 任务号  //将暂停的后台任务恢复运行

}


守护进程:
{ 

.即独立在会话外,与用户登录的生成的会话成并列关系的进程组
.本质是孤儿进程的一种

关闭守护进程:kill -9 或killall

1.setsid 接口
man 2 setsid
头文件: #include <unistd.h>
声明: pid_t setsid(void);
$ 作用:谁调setsid(),就把谁设成一个新的独立会话
返回值:成功,返回调用进程的新的会话id,失败返回-1并设置错误码
$ 条件: 
1.调用的进程不能是组长
2.守护进程要忽略异常信号
3.文件描述符0,1,2(标准输入输出,和标准错误)要做特殊处理
4.进程的工作路径可能要更改,可能想要改成根目录,不想在某个用户的目录下

# /proc/[pid]  //pid对应的进程所在的工作目录/  
$  /proc：内存文件系统，里面放的是当前系统实时的 进程信息。
[chj@47 ~ 19:59:45]$ ll /proc/4843
total 0
dr-xr-xr-x 2 chj chj 0 Jan 23 20:00 attr
-rw-r--r-- 1 chj chj 0 Jan 23 20:00 autogroup
-r-------- 1 chj chj 0 Jan 23 20:00 auxv
-r--r--r-- 1 chj chj 0 Jan 23 19:59 cgroup
--w------- 1 chj chj 0 Jan 23 20:00 clear_refs
-r--r--r-- 1 chj chj 0 Jan 23 20:00 cmdline
-rw-r--r-- 1 chj chj 0 Jan 23 19:59 comm
-rw-r--r-- 1 chj chj 0 Jan 23 20:00 coredump_filter
-r--r--r-- 1 chj chj 0 Jan 23 20:00 cpuset
lrwxrwxrwx 1 chj chj 0 Jan 23 19:59 cwd -> /home/chj/git_repositorier/linux_code/22.socket_service/3.TCP_Version
                                    // 进程当前的工作目录/路径,默认是启动时所在的目录
-r-------- 1 chj chj 0 Jan 23 20:00 environ
lrwxrwxrwx 1 chj chj 0 Jan 23 19:59 exe -> /home/chj/git_repositorier/linux_code/22.socket_service/3.TCP_Version/server
                                    //可执行程序文件所在的路径
dr-x------ 2 chj chj 0 Jan 23 20:00 fd
dr-x------ 2 chj chj 0 Jan 23 20:00 fdinfo
-rw-r--r-- 1 chj chj 0 Jan 23 20:00 gid_map
-r-------- 1 chj chj 0 Jan 23 20:00 io
-r--r--r-- 1 chj chj 0 Jan 23 20:00 limits
/... 略


2.daemon  // 运行到后台 -- Linux提供的守护进程接口
头文件: #include <unistd.h>
声明:   int daemon(int nochdir, int noclose);
参数:
a. nochdir==no change dir :是否更改工作目录,默认是不修改.   1为真,即不修改. 0就是false,修改成根目录\
b. noclose :要不要关闭0,1,2.默认是1,不关闭.  如果为0,false,daemon将重定向标准输出,输入,错误到 /dev/null(黑洞,丢失了).否则不修改
//程序员喜欢自己写.daemon

# /dev目录:字符型设备目录,
/dev/null: 所有linux都存在,信息黑洞,任何向这个文件内写的,都会被丢弃,从这里读, 什么都读不到,会立刻返回/结束
功能: 用于实现类似close(fd)的效果,比close温柔.不会影响到cout输入输出流等
.

}

【Networkk】一篇文章完全搞清楚 scoket read/write 返回码、阻塞与非阻塞、异常处理 等让你头疼已久的问题
https://www.cnblogs.com/junneyang/p/6126635.html
---------------------------------------------------------------------- new socket___END




$ 序列化与反序列化(属于编码设计)
{
. 网络中结构化数据发送 
  解决方案:将结构化数据转换成一条大字符串发送,接收端再把这条大字符串转换成结构化数据,
    ---- 在这个过程中,发送端做的是序列化,接收端做的是反序列化
. 序列化与反序列化的作用:方便网络通信

? 接收端如何知道要把接收到的数据转成什么格式呢? ---> 协议

. 协议本质就是双方约定好的某种格式的数据,常见的就是用结构体或者类来进行表达

.约定方案
    . 定义结构体来表示我们需要交互的信息;
    . 发送数据时将这个结构体按照一个规则转换成字符串, 接收到数据的时候再按照相同的规则把字符串转化回结构体;
    . 这个过程叫做 "序列化" 和 "反序列化"


}


telnet工具
{
启动: 
# telnet IP Port 
# ctrl+] 进入telnet命令行


}




防火墙关闭:
1.sudo systemctl stop firewalld
2.sudo systemctl disable firewalld


md5sum:linux计算md5工具 ---- 在git bash中,叫做md5sum.exe
    CLI:md5sum 文件1 文件2 ...
certutil:windows计算md5工具(CLI:command line interface)
    CLI:certutil -hashfile 文件 md5 

$ TCP报头
16位窗口大小: 
  用于流量控制,填写主机当前缓冲区剩余大小


TCP6个标志位
FIN:finish,请求连接结束
SYN:请求连接
RST:reset,重置
PSH:push,请求尽快向上交付
ACK:用于对报文作应答
URG:紧急指针

$ TCP连接
1.OS内一定能同时存在多个TCP连接(多个进程...),所以需要讲这些连接管理起来;
管理方式:struct tcp_link{//...}; ==> 创建和维护连接有成本(内存+CPU).
(UDP不面向连接,没有维护连接的成本)

2.建立连接的过程(三次握手):
    a.3次握手的过程由双方系统中的TCP层自主完成
    b.先由客户端发起请求报头(SYN),然后服务器返回SYN+ACK,最后客户端再发送ACK
    accept:等待建立完成,获取连接
        //服务端的整个过程:accept阻塞等待客户端发送SYN,收到SYN后(SYN_RCVD状态),返回SYN+ACK,直到收到客户端的ACK(established:确定的),accept返回fd.
        //accept收到SYN一次握手,发出SYN+ACK两次握手,收到ACK,三次握手完成
    connect:触发连接,获取连接
        //客户端是connect发送SYN后(SYN_SENT状态)阻塞等待接收到SYN+ACK才返回,
        connect发出SYN一次握手,收到SYN+ACK两次握手,发送ACK后,三次握手已完成

3.连接重置:res
        在三次握手时,客户端只要将最后一个ACK发送出去就认为三次握手成功,接下来就会向服务器发送数据(赌服务器能接收到)
    但是如果发送的ACK服务器端没有接收到,服务器端就会认为三次握手没有成功,
    如果此时服务器接收到数据报文,则服务器就会像客户端发送RES(请求重置)进行重新连接(三次握手).
(最后一个应答永远都存在丢失的可能,所以这种方式能够有效处理,也能体现可靠性) 
--- 红军蓝军问题

4.为什么不是两次握手,四次握手等
      A.两次握手非常容易受到攻击,服务器会认为收到SYN就是建立连接完成.这时如果客户端发送大量SYN就会占满服务器资源(维护连接需要成本) --- SYN洪水 ;
      B.四次握手和偶数次握手 :
        握手次数如果是偶数,则最后一次ACK发送是在服务端,即服务端先完成握手,即维护连接和维护连接异常的成本先在服务器端,
        由于服务器要面向多个客户端,面向多个客户端必然会使服务器压力和成本增加,异常连接占用的资源不能投入生产,造成资源浪费
        偶数次握手客户端发起连接成本低廉,容易发起SYN洪水
      C.奇数次握手
        握手次数如果是奇数,则最后一次ACK发送一定是在客户端,即客户端最先完成握手,
        由于客户端只需要和服务器维护连接,成本远低于偶数次握手,
        一般情况下服务器配置要远高于一般主机,能够应付单机的SYN洪水
      (由于客户端数量很多,所以SYN洪水一定会存在,服务端只能缓解)

5.为什么是3次握手
  A.没有明显的设计漏洞 -- SYN洪水
  B.三次握手是验证全双工通信信道通畅的最小成本
    客户端发出SYN,收到SYN+ACK,就能验证收到和发出信息正常
    服务端收到SYN后,发出SYN+ACK和收到ACK,也能验证发出和收到信息正常


$ 四次挥手
1.3次握手也可以看作是四次挥手
即
c:SYN
s:ACK
s:SYN
c:ACK
只不过服务器的连续两次操作可以放到一个报文里一次发送出去

2.为什么是四次
    a.断开连接也是需要双方形成共识,因为双方地位是对等的.所以必须是偶数次
    b.而两次挥手最多只能完成一方的一次应答,所以不能是两次挥手
    c.不需要六次及以上,最快,最小成本即可

3.谁close就是谁发送FIN


// 用netstat可以观察TCP服务器和客户端连接到断开的各种状态

正常断开时,主动退出的一方要进入TIME_WAIT状态(临界,可以认为连接还在,也可以认为断开,但此时物理连接还存在).
此时如果服务端主动断开后(一般是服务器,因为IP和端口是用户指定的,固定的)重新启动,则就会错误,描述:地址已经使用
//服务器主动断开的场景:服务器压力过大导致重启

4.为什么要time_wait两个MSL
    a.尽可能让本次连接所发出的报文消散或接收,避免影响到下次连接,出现奇怪问题--- 历史遗留报文
    b.尽可能保证对方接收到最后一次ACK,在time_wait期间如果对方没有收到ACK会请求重传 
    time_wait能保证基本不会出现历史遗留报文

$ 流量控制
    接收端处理数据的速度是有限的,如果发送端发的太快,导致接收端的缓冲区被打满,这个时候发送端继续发送,
        就会造成丢包,继而引起丢包重传等等一系列连锁反应.
    因此TCP支持根据接收端的处理能力,俩决定发送端的发送速度.这个机制就叫做流量控制(Flow Control)
.接收端将自己可以接收的缓冲区大小放入 TCP 首部中的 "窗口大小" 字段, 通过ACK端通知发送端;
.窗口大小字段越大, 说明网络的吞吐量越高;
.接收端一旦发现自己的缓冲区快满了, 就会将窗口大小设置成一个更小的值通知给发送端;
.发送端接受到这个窗口之后, 就会减慢自己的发送速度;
.如果接收端缓冲区满了, 就会将窗口置为0; 这时发送方不再发送数据, 但是需要定期发送一个窗口探测数据段(只有报头,序号范围为自己), 使接收端把窗口大小告诉发送端
.接收端缓冲区腾出空间后,也可能会给发送端发送窗口更新通知

TCP在3次握手时,不会携带数据,即不会占用对方缓冲区. 在3次握手的报头中,携带自己的16位窗口大小


$ 滑动窗口:
    滑动窗口位于发送方的发送缓冲区内
1.发送缓冲区功能范围划分:
    滑动窗口: 暂时不用收到应答,可以直接发送的区域
    滑动窗口经过后的区域:已经发送已经确认,可以被覆盖-无效的数据.
    滑动窗口没经过的区域:尚未发送的数据区域
2.滑动窗口大小与对方的接收能力有关,是应答报文中窗口大小有关.
3.用户往发送缓冲区内放数据,放的数据在尚未发送的数据区域后面,发送缓冲区是一个队列模型
    由于是字节流,说明也是一个数组,天然有序号,下标
    所谓的滑动窗口,就是一段缓冲区区间
4.滑动窗口的各种情况
    滑动窗口的边界是[winstart,winend)
    A.滑动窗口只能向右滑动,不能向左滑动,因为左边数据已经确认,已经无效
    B.滑动窗口可以变大也能变小,也能为0.
    C.更新依据:
        a.根据对方的接收能力
        应答也要按序达到.
        应答的seq(顺序),用于winstart = seq.即滑动窗口左边界增加
        应答的win大小,用于winend = winstart+win.即滑动窗口右边界增加
        滑动窗口为0,即winstart == winend,会进入窗口探测状态
    D.报文丢失
        a.第一个报文丢失
            如果是ACK丢失,则没有影响,因为后面序号的报文的ACK的确认信号包括了前面序号的应答
            如果是数据丢失,则会收到多个相同序号的应答,则滑动窗口不动,等待超时重传.补发后,由于后面的数据对方已经收到,下次应答的窗口大小会很大
            (收到3个同样的确认应答时则进行重发,叫高速重发控制,也叫快重传)
        b.中间的报文丢失
            和第一个报文丢失一样.中间丢失即左边全部收到了,此时中间就会变成滑动窗口的第一个.
        c.最后一个丢失同理
    E.滑动窗口能一直滑动吗? 可能会越界吗
        能,
        不会.因为发送缓冲区就是一个环形队列
    F.为什么不把滑动窗口内的所有数据一次打包发送,而是拆成多个?
5.滑动窗口的效率:
一发一收的方式性能较低, 那么我们一次发送多条数据, 就可以大大的提高性能(其实是将多个段的等待时间重叠在一起了)
        
$ 快重传和超时重传
    快重传和超时重传都存在TCP中,并无冲突
    超时重传是兜底的,解决只收到0个到2个的丢包和超时无应答情况.决定下限

$ 网络拥塞
//拥塞判定,每次超时重传后,拥塞窗口会减半.少量的丢包, 我们仅仅是触发超时重传; 大量的丢包, 我们就认为网络拥塞;
1.当出现大面积丢包时,主机会认为是网络拥塞,此时不能进行超时重传.
    如果此时做超时重传,因为所有主机都用的是同一个网络,则所有主机都会做超时重传,会加剧网络负担,造成严重后果.
2.处理策略:
    发生网络拥塞时,不能超时重传,也不能等等再发.
    a.先减少发送量,探探路.之后就可以继续进行超时重传.只对少量的报文进行超时重传

3 拥塞控制:
    TCP引入慢启动机制,先发少量的数据探探路,摸清当前的网络拥堵状态,再决定按照多大的速度传输数据 -- 网络状态的探测
        //发送的数据量和丢包率能够反应网络的拥塞程度

4.网络的健康状态
    网络的健康状态是不知道的,必须要一直探测

5 拥塞窗口:
    .发送开始时,定义拥塞窗口大小为1;
    .每次收到一个ACK应答,拥塞窗口加1;
    .每次发送数据包时,将拥塞窗口和接收端主机反馈的窗口大小做比较,取较小的值作为实际发送的窗口
    

6 现在,滑动窗口不止和对端主机的接收能力有关,还和网络的拥塞窗口有关
    滑动窗口大小= min(对端主机的窗口,网络的拥塞窗口) //取最小值
    win_start = seq;
    win_end = min(seq_win,拥塞窗口)

7.慢启动阈值ssthresh
    拥塞窗口的"慢启动"只是指初始时慢,但是增长速度非常快.
    前期慢后期快的目的是为了尽快恢复网络通信
    为了不增长太快,不能使拥塞窗口简单的加倍,因此引入了慢启动的阈值ssthresh.
    .当拥塞窗口超过这个阈值的时候,不再按照指数方式增长,而是按照线性方式增长.
    .除了ssthresh的初始值外,其他新的ssthresh的值是当前堵塞窗口的一半 -- "乘法减小"

8 .
少量的丢包, 我们仅仅是触发超时重传; 大量的丢包, 我们就认为网络拥塞; 
当TCP通信开始后, 网络吞吐量会逐渐上升; 随着网络发生拥堵, 吞吐量会立刻下降; 
拥塞控制, 归根结底是TCP协议想尽可能快的把数据传输给对方, 但是又要避免给网络造成太大压力的折中方案

因为网络拥塞存在,所以TCP不能直接将滑动窗口直接打包发送给接收方,必须要拆分成一定大小的包


$ 延迟应答:
在不超时的时间内,等待一段时间,尽可能将数据交付上层,腾出空间,更新出更大的接受能力.

$ 捎带应答:
大部分报文的ACK都置为1,有效提高传输效率

$ TCP还有其他如定时(超时重连)的功能

$ 粘包问题
UDP没有,TCP有,在协议处由程序员处理好


$ TCP listen的第二个参数.
1.TCP协议需要在底层维护一个全连接队列,最大长度是listen第二个参数+1.
    队列元素是已经3次握手成功的,正在等待被accept取到应用层去的连接.(说明accept不参与3次握手)
//不能太长,但不能没有,排队太长浪费还不如多服务多几个
作用:提前缓存好连接,提高服务的效率
2.TCP还维护了半连接队列,元素是进行3次握手过程中的连接 (维护时间非常短)





$ IP
主机:配有IP地址的设备就是主机
路由器:既有IP地址,又能进行路由控制的设备叫路由器
节点:主机和路由器都叫做节点.


子网:内部各种主机
公网,转发集群:内部是各种路由器作为节点组成的网.

$ 子网划分
IP是子网划分的结果,目的是提高主机查找另一台主机的效率
//排除法进行查找,高效率
公网IP -- 子网IP -- 主机
//入网协议

子网划分规则定制:顶级工程师和组织.
各子网的规则定制:运营商

IP地址分为网络号和主机号
网络号:区分不同网段的唯一标识
主机号:同一网段内区分不同主机的唯一标识

路由器要连接不同的子网,则至少要有子网个数的网卡
原因:公网中网络号是唯一的,不同的子网有不同的网络号.相同的网络号子网内主机才能识别是自己人
//路由器一般都是子网的出口或入口,所以一般的主机号都是1 (路由器也是主机,第一个构建子网)
//路由器也叫网关
路由器的功能:构建子网,常见如手机开热点,此时手机就是路由器
猫/调制解调器

配置子网IP
子网是路由器构建好的,子网ip都要经过路由器申请(一般路由器设置账号密码,登录(幌子),其实是在申请动态ip地址)
    路由器会自动申请未被占用的IP地址
在以前手动配ip,很麻烦
现在:DHCP技术,
1.自动给子网内新增的主机节点分配ip地址,避免了手动管理ip的不便
2.动态管理和分配共享IP地址
//一般的路由器都有DHCP技术,所以把路由器看作一个DHCP服务器
//现在一般的路由器都能工作在应用层,如登录路由器管理页面,用的就是http(应用层)


CIDR(Classless Interdomain Routing):
引入一个额外的子网掩码(subnet mask)来区分网络号和主机号;
子网掩码也是一个32位的正整数. 通常用一串 "0" 来结尾; 将IP地址和子网掩码进行 "按位与" 操作, 得到的结果就是网络号;
(相同网段(网络号)的主机可以相互通信,如我的机器访问我家的路由器)


IP子网划分后消息就不是群发了,只有在刚开始和更新的时候才会群发,即在路由交换:建立路由表的过程才需要群发.

//二进制与十进制转换:
//规律:2^n次方转为二进制即1后有n个0.
//例: 2^6 == 0100 0000 //1后有6个0
//因此,十进制数可以先转化成2的大次方和2的小次方的形式,然后再通过规律转成二进制,
//如68 == 64 + 4 == 2^6 + 2^2 == 0100 0000 + 0100 == 0100 0100

划分子网的例子:
IP地址:      140.252.20.68
子网掩码:    255.255.255.240
网络号:      140.252.20.64    | 计算: 240 = 255-15 = 1111 0000 ,网络号:240&68=0100 0000(64). 
子网地址范围:140.252.20.79    | 计算: 0100 0000(网络号开始)+0000 1111(不超过掩码最小位) = 79
//可用主机号范围[65,78],总共14台主机 ---> 比较适用家庭网络
//实际可用主机号范围是[网络号+1,广播号-1],网络号是最小的IP,广播号是最大的IP
IP与子网掩码与运算可以得到网络号.主机号从全0到全1可以得到子网的地址范围.
CIDR表示方式: 140.252.20.68/28


特殊的IP地址
将IP地址中的主机地址全部设为0, 就成为了网络号, 代表这个局域网; 将IP地址中的主机地址全部设为1, 就成为了广播地址, 用于给同一个链路中相互连接的所有主机发送数
据包;
127.*的IP地址用于本机环回(loop back)测试,通常是127.0.0.1

$ linux环境下
[chj@gz ~ 22:26:52]$ ifconfig
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500   //mtu 数据链路层携带数据最大是1500字节
        inet 172.31.122.173  netmask 255.255.240.0  broadcast 172.31.127.255
        inet6 fe80::216:3eff:fe03:6b2e  prefixlen 64  scopeid 0x20<link>
        ether 00:16:3e:03:6b:2e  txqueuelen 1000  (Ethernet) //ether:mac地址
        RX packets 2680490  bytes 599386071 (571.6 MiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 1985569  bytes 1441601022 (1.3 GiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536  //lo:loop 本地环回
        inet 127.0.0.1  netmask 255.0.0.0   //inet:本地环回地址. netmask: 子网掩码
        inet6 ::1  prefixlen 128  scopeid 0x10<host>
        loop  txqueuelen 1000  (Local Loopback)
        RX packets 27741  bytes 42588760 (40.6 MiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 27741  bytes 42588760 (40.6 MiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0


$ 公网IP与私网IP
私有IP
    1.私网IP允许重复 --> 提高IP利用率
    2.私有IP不允许出现在公网,因为每个私网IP都可能重复,如果以私网IP方式发出去,之后就回不来了,不知道发给谁
路由器有两套IP
    1.LAN口IP,路由器与主机构建的子网IP,对内
    2.WAN口IP,路由器在运营商的IP,对外(子网外).一般以10.开头

子网向公网发送数据的方式: 源IP从LAN口IP转为WAN口IP,而目的IP一直不变:
   每次向上交付时,首先判断LAN口IP是不是公网IP,不是则会用WAN口IP替换调LAN口IP,直到替换后属于公网IP为止
即NAT（Network Address Translation）,NAT技术,后谈
    
//城域网:运营商在一块区域内自己构建的局域网


$ 路由:
缺省路由:把不知道传给谁的数据包丢给路由器去转发
查找路由表:报文每到一个节点(路由器),该路由器都会查找路由表看是否认识,不认识就走默认路由
路由地过程:路上先进行路由转发,到了目标路由后进行对目标主机进行交付
//内网路由通常比较简单,基本上一直缺省路由到公网即可

IP报文结构:
0 -------------------------------------------------------------------------------------- 31bit  ___
|    4位版本  | 4位首部长度 | 8位服务类型(TOS) |          16位总长度(字节数)             |       |
|             16位标识                         | 3位标志 |           13位偏移            |       |
|         8位生存时间 |   8位协议              |          16位首部检验和                 | 20字节报头长度
|                                        32位源IP地址                                    |       |
|                                       32位目的IP地址                                   |      _|_
|                                        选项(如果有)                                    |
|                                           数据                                         |
0 -------------------------------------------------------------------------------------- 4字节

第一行
.4位版本号(version): 指定IP协议的版本, 对于IPv4来说, 就是4. 
.4位头部长度(header length): IP头部的长度是多少个32bit, 也就是 length * 4 的字节数. 4bit表示最大
 的数字是15, 因此IP头部最大长度是60字节. 
.8位服务类型(Type Of Service): 3位优先权字段(已经弃用), 4位TOS字段, 和1位保留字段(必须置为0). 4位
.TOS分别表示: 最小延时, 最大吞吐量, 最高可靠性, 最小成本. 这四者相互冲突, 只能选择一个. 对于
 ssh/telnet这样的应用程序, 最小延时比较重要; 对于ftp这样的程序, 最大吞吐量比较重要.
.16位总长度(total length): IP数据报整体占多少个字节. 

第二行
.16位标识(id): 唯一的标识主机发送的报文. 如果IP报文在数据链路层被分片了, 那么每一个片里面的这个
 id都是相同的. 
.3位标志字段: 第一位保留(保留的意思是现在不用, 但是还没想好说不定以后要用到). 第二位置为1表示禁
 止分片, 这时候如果报文长度超过MTU, IP模块就会丢弃报文. 第三位表示"更多分片", 如果分片了的话, 
 最后一个分片置为1, 其他是0. 类似于一个结束标记. 
.13位分片偏移(framegament offset): 是分片相对于原始IP报文开始处的偏移. 其实就是在表示当前分片
 在原报文中处在哪个位置. 实际偏移的字节数是这个值 * 8 得到的. 因此, 除了最后一个报文之外, 其他报
 文的长度必须是8的整数倍(否则报文就不连续了). 

第三行
.8位生存时间(Time To Live, TTL): 数据报到达目的地的最大报文跳数. 一般是64. 每次经过一个路由, TTL 
 -= 1, 一直减到0还没到达, 那么就丢弃了. 这个字段主要是用来防止出现路由循环
.8位协议: 表示上层协议的类型
.16位头部校验和: 使用CRC进行校验, 来鉴别头部是否损坏. 

第四第五行
.32位源地址和32位目标地址: 表示发送端和接收端. 

后面
.选项字段(不定长, 最多40字节): 略
.数据

问题和归纳:
{
1.是否分片以及是分片的哪部分.
    独立报文: 更多分片是0,偏移是0.
    开始报文: 更多分片是1,偏移是0.
    中间报文: 更多分片是1,偏移>1.
    结束报文: 更多分片是0,偏移>1.
//3位标志+13位偏移能判定分片情况

2.分片不是IP的常态,不建议分片
  a.如果分片丢失,需要重发所有 
    因为可靠性是由TCP负责,如果数据包丢失,如果需要知道那部分丢失,则需要提交给TCP,相应的TCP也要对IP的分片负责,这会增加TCP的复杂度,和TCP/IP的耦合度
    所以:分片丢失,需要重发所有.
    为了尽量不分片,TCP就需要将滑动窗口拆成多个报文来发
    //UDP也一样,只不过UDP的不重传,丢失就是真丢失了
  b.过多的分片,容易增加丢包率

3.怎么判断报文连续,中间没有丢失
    a.下一个分片的起始偏移量 = 分片的起始偏移量+分片自身的大小
    b.将接收到的所有分片排序.
4.数据可靠性?
    IP不保证可靠性.IP "16位首部校验和" 用于保证报头没问题.有效载荷则交给TCP "16位校验和" 去处理;
    即,由TCP负责可靠性,IP负责报文没BUG --> TCP和IP互相协同,
    
5.IP基本不会出现历史遗留数据包的问题 -- 不用太大考虑
    IP层没有缓冲区,接收好后就会立即向上层交付.
    IP首部的各种检验,标志,偏移等基本能校验出来历史遗留数据包问题

6.分片是在IP完全将上层报文封装后,再进行分片的.即一个大的数据报(IP+有效载荷),需要再分成多个数据报
    组装则是把不是第一个分片的其他分片的报头去除.再拼接到第一个分片的后面.


}


# route
[chj@gz ~ 12:06:06]$ route
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
default         gateway         0.0.0.0         UG    0      0        0 eth0
link-local      0.0.0.0         255.255.0.0     U     1002   0        0 eth0
172.31.112.0    0.0.0.0         255.255.240.0   U     0      0        0 eth0
//目标IP         网关            掩码          
解释：
Destination：目的主机/网络的IP
Gateway：发送到的网关
Flags：路由标志，代表当前网络结点状态：
U：UP，该路由当前为启动状态
H：Host，该路由为某个主机路由
G：Gateway，该路由为某个默认路由
D：Dynamically，该路由为动态写入
R：Reinstate Route，使用动态路由重新初始化的路由
M：Modified，该路由是路由守护程序或导向器动态修改
!：该路由为关闭状态
Iface：网卡名
https://www.cnblogs.com/ShineLeBlog/p/17605793.html


$ 报文的最大大小
{
               ___________________
       _______|报头=20| MSS==1460 | TCP/UDP   //MSS:最大段尺寸 --- 数据段
 _____|报头=20|              1480 | IP                         --- 数据报
|     |                 mtu==1500 | 数据链路                   --- 数据帧 
}


$ 数据链路层
复习:
应用层主要是协议,序列化与反序列化的过程.传输层主要是可靠性的问题,网络层主要是网络路由的功能
//跨网络:就是经历很多子网或局域网的过程,因为一个路由器属于一个子网,也属于另一个子网
//IP解决的是网络如果路由和途径.决定下一步往哪走(路径选择).
mac帧解决的就是如果在局域网内,两台主机之间的通信,解决怎么走的问题
IP和mac合起来提供了将A主机跨网络送到B主机的能力

局域网通信原理:广播式的

mac地址:ifconfig:ether后的,6字节48位,每字节以冒号分开的地址


mac数据帧结构
{
结构
   |目的地址|源地址|类型|            数据          |CRC|
字节:   6      6     2              46-1500          4
源地址和目的地址是指网卡的硬件地址(也叫MAC地址), 长度是48位,是在网卡出厂时固化的;
帧协议类型字段有三种值,分别对应IP(0800)、ARP(0806)、RARP(8035);
帧末尾是CRC校验码。

mac地址在linux中是个结构体: struct mac_hdr {}
}

mac在网络中传输的过程
{
主机A将mac帧发到网络中,期间所有的主机都能看到主机A发出的mac帧,所有主机都会将主机A的mac帧捞起来拆包,看目的地址是否符合,符合才向上交付,不符合则丢弃,相当于每接受过macA
//网卡有个混杂模式:不对报文的目标MAC地址进行认证,直接交付给自己的上层 -- 大部分抓包工具的抓包原理

$ 在以太网中,任何时刻,只能有一台主机给另一台主机发送数据帧,否则可能会发生数据碰撞问题. -- 光波信号相互干扰可能导致二进制序列发生变化
    因此局域网也被叫做碰撞域.
解决方式:碰撞避免
    碰撞避免:主机发送mac帧后立刻捞起来读,CRC检测是否一致,不一致说明发生碰撞,需要重传,等一会再发送(sleep(随机数)),让别人先发
        只要有一方主机发出,其他所有主机都要执行碰撞避免
----> 这就是以太网的原理:以概率的形式发送,总有机会发送出去的
        也是一些网络攻击手段的原理,允许绕过正常流程/驱动去使用硬件设备
----> 从系统角度,以太网可以被看作是一个临界资源.(同一时刻只能有一个主机使用),只不过以太网是以碰撞方式判断能不能使用


$ 既然以太网会碰撞,则主机越多,碰撞概率越大.那怎么解决?
交换机(Switch)/网桥:工作在数据链路层的设备
    工作原理:划分碰撞域
        将局域网划分成几个区域,让其中一块区域因碰撞产生的垃圾数据不要影响到另一块区域



}

$ 主机发送时,怎么知道对方主机的mac地址呢?
    实际上,数据帧在发送的过程中,源mac地址和目标mac是一直在发生变化的,(底层差异化的体现)
    //只要目的IP地址不变,不影响传输(上层统一的体现)
    ---> ARP协议

$ ARP协议
功能:就是将IP地址转化成mac地址
工作域:链路层,在mac帧之上
结构:
{

mac部分:   以太网目的地址|以太网源地址|帧类型|

ARP部分:   硬件类型|协议类型|硬件地址长度|协议地址长度|op|发送端以太网地址|发送端IP地址|目的以太网地址|目的IP地址
大小:         2         2        1            1        2          6             4            6              4

mac部分:   CRC|


目的地址为全F时(12个F),为广播地址
帧类型为0x0806时,为ARP请求/应答
硬件类型:表示链路层网络类型,令牌环,以太网.. 一般都是以太网,值为1即可
协议类型指要转化的地址类型,一般都是以IP地址转化成mac地址;0x0800为IP地址(ipv4),ipv6同理
硬件地址长度:mac地址长度,6字节,填6
协议地址长度:IPv4为4字节,IPv6为128字节,填128
op字段为1时表示ARP请求,op字段为2时表示ARP应答
发送端以太网地址:发送端mac地址
发送端IP地址:
目的以太网地址:不知道就填全F当占位符,表示我不知道目的mac地址
}

ARP原理:
   1.在不知道目的mac的情况下,数据链路层会先组织ARP报文(全F广播报文),然后向下交付组装成mac帧,广播到局域网中.
    此时所有的主机都需要接收该报文(因为该报文目的地址是全F),然后分离报文并交给ARP层,
    ARP层首先会查看广播报文的op是否是请求,是请求后才会去看目的IP.
    如果op==1且IP不是自己,则在ARP层直接丢弃.因为不是请求自己
    如果op==1且IP是自己的,则在ARP层构建应答;构建应答的过程能够从ARP请求中获取必要信息,能够正常的构建了
   2.当接收到ARP报文后,主机也是先看op是什么,
    如果op==2,即ARP应答,则主机就能拿到自己请求IP的mac地址
即任何主机,收到arp,优先看op

$ ARP缓存
ARP只要成功一次,主机就会在一段时间内将双方的映射关系维护起来,15分钟或30分钟等等.这段时间内就不需要再发送ARP了
查看arp缓存命令: arp -a
PS C:\Users\chj\Desktop> arp -a
接口: 192.168.138.219 --- 0x4
  Internet 地址         物理地址              类型
  192.168.138.244       ee-30-b3-2b-59-62     动态
  192.168.138.255       ff-ff-ff-ff-ff-ff     静态


  [chj@gz ~ 19:36:31]$ ping -c 3 www.baidu.com //-c n 选项(count):ping命令重复执行n次
PING www.a.shifen.com (183.2.172.42) 56(84) bytes of data.
64 bytes from 183.2.172.42 (183.2.172.42): icmp_seq=1 ttl=50 time=3.73 ms
64 bytes from 183.2.172.42 (183.2.172.42): icmp_seq=2 ttl=50 time=3.74 ms
64 bytes from 183.2.172.42 (183.2.172.42): icmp_seq=3 ttl=50 time=3.73 ms
//TTL是 Time To Live的缩写，该字段指定IP包被路由器丢弃之前允许通过的最大网段数量。(跳数)
//获取局域网内所有主机的小工具原理:根据地址规则从0到111..遍历ping所有局域网内主机就可以获得所有有效主机的地址 
$ RARP 逆地址转换协议,通过mac来获取ip,在有mac没ip的情况下使用.

$ 数据帧长好还是短好?
    短好!
    假设很长,极限微分,一个帧要占很多个时间段,可能发生碰撞的概率比较高,碰撞后重发的成本也高
    如果是短的,占用时间段小,碰撞的概率更小,且碰撞后重发的成本也更低.因此越短越好,即包括上层的报文都是短一些比较好
   
$  局域网中间人 - ARP欺骗
// 如果是https,中间人几乎没用. 但是其他协议就不一定了
// 虽然https下无效,但中间人还可以定向攻击某台主机使其瘫痪.只需要提供假的mac,使数据发送不出去,就断网了



$$ DNS domain name system 域名系统
    用于将域名和IP地址相互转换
原理:使用域名时浏览器,软件应用等会先将域名发送到最近的域名服务器去获取响应的IP,然后再具体IP去访问服务器
DNS缓存:类似ARP缓存;
工作区域及协议:工作在应用层,UDP请求方式,
linux下DNS配置文件路径 # /etc/hosts
域名结构:
    com: 一级域名. 表示这是一个企业域名(一般是商业公司,要赚钱的). 同级的还有 "net"(网络提供商), "org"(非盈利组织) ,"edu"(教育机构)等.
    baidu: 二级域名, 公司名.
    www: 只是一种习惯用法. 之前人们在使用域名时, 往往命名成类似于ftp.xxx.xxx/www.xxx.xxx这样的格式, 来表示主机支持的协议.
//kernal.org(linux内核官网)


$ ICMP
ICMP协议是一个网络层协议,一般给管理员使用的,允许从应用层绕过传输层直接在网络层使用的协议
    一个新搭建好的网络, 往往需要先进行一个简单的测试, 来验证网络是否畅通; 但是IP协议并不提供可靠传输. 如果丢
    包了, IP协议并不能通知传输层是否丢包以及丢包的原因
功能:
.确认IP包是否成功到达目标地址.
.通知在发送过程中IP包被丢弃的原因. 
.ICMP也是基于IP协议工作的. 但是它并不是传输层的功能, 因此人们仍然把它归结为网络层协议;
.ICMP只能搭配IPv4使用. 如果是IPv6的情况下, 需要是用ICMPv6;

ICMP能实现的原理是路径的路由器会根据ICMP包的发送情况来帮忙构建ICMP应答返回给发送端
//什么时候使用ICMP或IP? 联系现实:使用某种产品的人和维修的人使用的方式或工具是不一样的.ICMP一般给维护者用
//ICMP借助IP来实现,是IP的有效载荷
ICMP大概分为两类报文:
    一类是通知出错原因
    一类是用于诊断查询
//报文格式:略
应用:
    ping命令:C/C++写的应用层工具
    原理:1.ICMP报文所经过的路由器都要给发送端应答;2.将IP报头中TTL字段从1开始依次增加.直到测试出最大跳数或超时


$$ NAT

为什么NAPT需要维护目的IP和port? 
    保护内网,防止外网随意访问内网.有目的IP就能分辨出是否是内网需要的应答
NAT技术的缺陷
    由于NAT依赖这个转换表, 所以有诸多限制:
    .无法从NAT外部向内部服务器建立连接;
    .装换表的生成和销毁都需要额外开销;
    .通信过程中一旦NAT设备异常, 即使存在热备, 所有的TCP连接也都会断开






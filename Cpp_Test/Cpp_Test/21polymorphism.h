#pragma once
/*****************************************************************//**
 * \file   21polymorphism.h
 * \brief  
 * 
 * \author 26390
 * \date   July 2023
 *********************************************************************/

/** 多态/动态调用
 * 
 * 
 * 1.虚函数/虚拟函数
 * 语法:在函数前面加上virtual
 * 
 * 1.1虚函数与虚继承没有关系,只是共用了关键字
 * 
 * 2.重写/覆盖:虚函数且函数名字类型等完全一样
 * $注:虚函数是覆盖,不是虚函数才构成隐藏
 * $重写:指对函数体重写,函数体外的是直接使用父类的,接口继承;重写只有虚函数才有,非虚函数的叫做隐藏
 * $只有虚函数才可以重写,非虚函数不能修改继承下来的函数体
 * 
 * 2.1 虚函数重写的条件
 * $三同:函数名,参数(平常说的参数都是说参数的类型,与缺省参数无关),返回值都要相同
 * 
 * 2.2 重写体现 <<接口继承>>
 * 
 * 3.多态的条件
 * a.虚函数的重写  -- 多态的基础
 * b.父类的指针或引用去调用  -- 很重要,必须是父类类型的指针或引用(接收父类对象或子类对象)的对象去调用虚函数
 * $一个不满足都实现不了多态 
 * 
 * 3.1 多态对象和普通对象的区别
 * $不满足多态时,只看类型
 * $满足多态时,看指向对象的类型
 * 
 * 4.必须使用多态的场景
 * a.继承中对析构函数的特殊处理场景
 * $引入:继承中析构的特殊处理引入 Destructor
 *  &如果是父类指针接收子类类型,则析构函数调用父类的,没调子类,
 *  $析构特殊处理后,构成隐藏的析构函数,类型是谁就调用谁的析构,目前不能解决
 *  $多态,虚函数,父类指针或引用调用虚函数,->彻底解决继承的析构问题
 * 
 * 5.虚函数的例外
 * a.子类可以不写virtual(重点记忆) -- 虚函数可以继承(隐式) -- 体现接口继承
 * b.协变covariant -- 返回值可以不同,但必须是父子关系的指针或引用,可以是nullptr,不能是对象
 * 
 * 5.1 协变 - 目前用途比较少 后续遇到再学习
 * 
 * 6.多态的特殊继承
 * a.发生多态后,会继承父类的缺省参数,即子类缺省参数无效 -- 非多态下,子类继承下来的成员与父类无关
 * $ a的解释:多态的继承是一种接口实现,即函数体外所有东西都是父类的,只有函数体是对象的,多态继承的函数叫重写;重写:即重写函数体
 * 
 * 7 说明符final (说明符不是关键字)
 * 7.1 final的功能
 * a.final可以修饰类,表示|最终类|,即不允许被继承的类
 * b.final可以修饰虚函数,使虚函数不能被重写(可以继承) //但是很矛盾,虚函数的意义就是可以重写,重写的意义就是实现多态
 * 
 * 8 说明符override:重写说明符
 * 8.1 override的功能
 * a.辅助用户检查是否完成重写; 语法:加载函数参数列表的括号后(),函数体花括号{}前: (//...)override{//...};
 * 
 */

#include<string>
#include<iostream>
using std::cout;
using std::endl;
using std::cin;
using std::string;

class Person 
{
public:
	//虚函数:在函数前面加virtual
	virtual void BuyTicket() { cout << "买票-全价" << endl; }

	virtual ~Person() { cout << "~Person()" << endl; }
};

class Student : public Person
{
public:
	//重写/覆盖:虚函数且函数名字类型等完全一样
	virtual void BuyTicket() { cout << "买票-半价" << endl; }

	virtual ~Student() { cout << "~Student()" << endl; }
};

//测试用例

//多态的用法
void fun(Person& p)
{
	p.BuyTicket();
}
void test_polymorphism1()
{
	Person p;
	Student s;
	fun(p);
	fun(s);
}

void test_polymorphism2()
{
	Person p;
	Student s;
	cout << " ================ " << endl;

	//有virtual和无virtual区别
	Person* p1 = new Person();
	Person* p2 = new Student();
	delete p1;
	delete p2;
}

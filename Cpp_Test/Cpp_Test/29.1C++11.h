#pragma once

#include<iostream>
#include<vector> 
#include<list>
#include"10myString.h"
#include"11myVector.h"
#include"12myList.h"
#include"2Date.h"
#include <map>

/** C++11
 * 
 * 默认成员函数
原来C++类中，有6个默认成员函数：
1. 构造函数
2. 析构函数
3. 拷贝构造函数
4. 拷贝赋值重载
5. 取地址重载
6. const 取地址重载
最后重要的是前4个，后两个用处不大。默认成员函数就是我们不写编译器会生成一个默认的。
 * 
 * C++11新增了两个构造函数,分别是
 * 1.移动构造
 * 2.移动赋值
 * 
 * 但他们自动生成的条件非常苛刻:
 * 1. 如果你没有自己实现移动构造函数，且没有实现析构函数 、拷贝构造、拷贝赋值。那么编译器会自动生成一个默认移动构造。 
 * -- 实现一个都不行? 对,只要实现到其中1个或以上都不会自动生成
 *   原因:
 *		如果我们重载了析构,拷贝,赋值,就说明这个类是需要深拷贝的,那这个类最好是由我来决定资源如何转移,而不是由编译器控制,以免出现意想不到的结果       
 *      
 * 2. 默认生成的移动构造函数，对于内置类型成员会逐字节拷贝(值拷贝)，
 *      对于自定义类型成员，如果该自定义类型内实现了移动构造,就调用他的移动构造,没有实现就调用他的拷贝构造。
 *      --- 默认生成的移动构造,需要自定义类型实现了移动构造才能发生移动,其他都是值拷贝或深拷贝...
 * 
 *
 * 
 * 
 * 
 *  
 * 强制生成默认的移动构造
 * A(A&& a) = default;
 * A& operator=(A&& a) = default;
 * 
 * 
 */

//类成员变量初始化 -- 缺省值
/**
 * C++11允许在类定义时给成员变量初始缺省值，默认生成构造函数会使用这些缺省值初始化 -- 缺省参数
 *  补足对内置类型默认不处理的缺陷
 */


//关键字default -- 强制生成默认的构造函数
/**
 * 
 * C++11可以让你更好的控制要使用的默认函数。假设你要使用某个默认的函数，但是因为一些原因这个函数没有默认生成。
 * 比如：我们提供了拷贝构造，就不会生成移动构造了，那么我们可以使用default关键字显示指定移动构造生成。
 * 强制生成默认的移动构造
 * A(A&& a) = default;
 * A& operator=(A&& a) = default;
 * 
 */

/**禁止生成默认函数的关键字delete:
 * 
 * 1.如果能想要限制某些默认函数的生成，在C++98中，使该函数设置成private，并且只声明 ，这样只要其他人想要调用就会报错。 --- 不够明确/清晰
 * 2.在C++11中更简单，只需在该函数声明加上 = delete即可，该语法指示编译器不生成对应函数的默认版本，
 *    称 = delete修饰的函数为删除函数。 -- 更清晰明确
 * 哪些对象不希望被拷贝,被移动? -- 1.I/O流 2.单例模式...
 * 
 */

//继承和多态中的final与override关键字
/**
 * final: -- 修饰基类,父类
 * 1.final可以修饰一个类,使其不能被继承.
 * 2.final还可以修饰成员函数,使其不能被重写.
 * 
 * override: --- 修饰派生类
 * 1.override用于修饰派生类的虚函数.检查是否完成重写.
 * 
 * 
 * 什么情况下子类必须重写虚函数 --- 规定:纯虚函数的子孙类必须至少有一个重写纯虚函数.
 * 
 * 
 */

//委托构造 -- 可读性差点,意义不大,只提高了复用性.但可以不使用,可有可无
/**
 * 委托构造函数也是一种构造函数，这种构造函数可以委托其他构造函数来帮它完成一些对象成员的初始化操作。
 * 一个构造函数可以调用其他构造函数
 */
/*class Person
{
public:
	Person(const char* name, int age)
		:_name(name)
		, _age(age)
	{}
	Person(const char* name)  //委托构造
		:Person(name, 18)   // ---- 借用已有的构造函数来帮助构造,初始化
	{}
private:
	string _name;
	int _age;
};*/







//可变参数模板 --- 记忆:声明时:三个点,在中间. 单独使用时,三个点,在后边. --- 特例,sizeof是宏,所以三个点,在中间
/**
 * 起源:C语言的printf()
 * int printf ( const char * format, ... ); //这三个点...就是可变参数
 * C语言底层是编译器开了一个参数数组,三个参数就存三个空间,四个参数就存4个...
 * 
 * C++11的新特性可变参数模板能够让您创建可以接受可变参数的函数模板和类模板，相比
 * C++98 / 03，类模版和函数模版中只能含固定数量的模版参数，可变模版参数无疑是一个巨大的改
 * 进。然而由于可变模版参数比较抽象，使用起来需要一定的技巧，所以这块还是比较晦涩的。现
 * 阶段呢，掌握一些基础的可变参数模板特性就够用了，所以这里点到为止，以后如果有需要再深入学习。
 * 
 *   
 * Args是一个模板参数包，args是一个函数形参参数包  
 * 声明一个参数包Args ... args，这个参数包中可以包含0到任意个模板参数,代表的就是0到任意个参数。
 * 
 * -----  (注:args是个名称,可以任意取,习惯写成args)  
 * -----  (参数包写法为Args ... 命名) (类似类型写法T t)
 * 
 * 可变参数模板使用场景:线程  -- 线程库:<thread> --C++11
 * (线程:我们需要分配不同任务给不同线程去执行.不同任务有不用需求和情况---> 因此需要支持多种类型)	
 * 1.C语言通过使用 void*传参,然后强转成需要的类型, 来解决不同类型的问题. 无参数传null,1个参数直接传void*,多个参数就放在一个结构体内再传void*
 * 2.C++11使用了一个类去封装线程.(C++不限于函数,还可以是可执行对象,如仿函数等...) , 
 *	   这个类使用了可变参数包,可以传任意个类型.用的时候再解析出来.
 *  
 * 可变参数模板主要是为库准备的 -- 我们目前先了解了解
 * 
 * 容器中都有一个emplace系列
 * 特点:
 * 1.可以传多个参数,传一个参数时和其他同样参数的函数功能一样,如push_back和emplace_back 效率基本一样  但底层实现不一样
 * 2.emplace有直接构造情况... 只要传构造函数的参数,可变参数包就会自动推导到相应构造函数-->直接构造
 * 
 * emplace确实有优化,可以多使用
 * 
 * 一些工具使用:
 * 1.支持sizeof ... (函数形参参数包)   
 * 2.不支持typeid().name().
 * 
 * 需要将可变参数解析出来才能使用可变参数 ---> 递归拆解... (待学.迷糊中)
 * 
 */

template<typename ... Args> //三个点中间
void showList(Args ... args)
{
	std::cout << sizeof ... (args) << std::endl; //打印有多少个类型
}

int man()
{
	showList();
	showList('x', 'y');
	showList('x', '1');
	showList(1);

	return 0;
}



 // 解析出可变参数包
 // 递归,将可变参数包拆解.分而治之
void ShowList() //递归的终止条件,拆分到最后,会有一个无参的函数.定义一个无参的函数让递归停止.
{
	std::cout << std::endl;
}
template <class T, class ...Args>
void ShowList(const T& val, Args... args) //每次都将可变参数包的最左1个拆分出来,直到分解完毕.
{
	//cout << __FUNCTION__ << "(" << sizeof...(args) << ")" << endl; //__FUNCTION__会替换成当前函数名的字符串

	cout << typeid(val).name()<<" " <<val << " "; // 打印出 类型 和 值 
	ShowList(args...);
}






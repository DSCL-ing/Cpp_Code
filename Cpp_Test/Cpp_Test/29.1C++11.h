#pragma once

#include<iostream>
#include<vector> 
#include<list>
#include"10myString.h"
#include"11myVector.h"
#include"12myList.h"
#include"2Date.h"
#include <map>

/** C++11
 * 
 * 默认成员函数
原来C++类中，有6个默认成员函数：
1. 构造函数
2. 析构函数
3. 拷贝构造函数
4. 拷贝赋值重载
5. 取地址重载
6. const 取地址重载
最后重要的是前4个，后两个用处不大。默认成员函数就是我们不写编译器会生成一个默认的。
 * 
 * C++11新增了两个构造函数,分别是
 * 1.移动构造
 * 2.移动赋值
 * 
 * 但他们自动生成的条件非常苛刻:
 * 1. 如果你没有自己实现移动构造函数，且没有实现析构函数 、拷贝构造、拷贝赋值。那么编译器会自动生成一个默认移动构造。 
 * -- 实现一个都不行? 对,只要实现到其中1个或以上都不会自动生成
 *   原因:
 *		如果我们重载了析构,拷贝,赋值,就说明这个类是需要深拷贝的,那这个类最好是由我来决定资源如何转移,而不是由编译器控制,以免出现意想不到的结果       
 *      
 * 2. 默认生成的移动构造函数，对于内置类型成员会逐字节拷贝(值拷贝)，
 *      对于自定义类型成员，如果该自定义类型内实现了移动构造,就调用他的移动构造,没有实现就调用他的拷贝构造。
 *      --- 默认生成的移动构造,需要自定义类型实现了移动构造才能发生移动,其他都是值拷贝或深拷贝...
 * 
 *
 * 
 * 
 * 
 *  
 * 强制生成默认的移动构造
 * A(A&& a) = default;
 * A& operator=(A&& a) = default;
 * 
 * 
 */

//类成员变量初始化 -- 缺省值
/**
 * C++11允许在类定义时给成员变量初始缺省值，默认生成构造函数会使用这些缺省值初始化 -- 缺省参数
 *  补足对内置类型默认不处理的缺陷
 */


//关键字default -- 强制生成默认的构造函数
/**
 * 
 * C++11可以让你更好的控制要使用的默认函数。假设你要使用某个默认的函数，但是因为一些原因这个函数没有默认生成。
 * 比如：我们提供了拷贝构造，就不会生成移动构造了，那么我们可以使用default关键字显示指定移动构造生成。
 * 强制生成默认的移动构造
 * A(A&& a) = default;
 * A& operator=(A&& a) = default;
 * 
 */

/**禁止生成默认函数的关键字delete:
 * 
 * 1.如果能想要限制某些默认函数的生成，在C++98中，使该函数设置成private，并且只声明 ，这样只要其他人想要调用就会报错。 --- 不够明确/清晰
 * 2.在C++11中更简单，只需在该函数声明加上 = delete即可，该语法指示编译器不生成对应函数的默认版本，
 *    称 = delete修饰的函数为删除函数。 -- 更清晰明确
 * 哪些对象不希望被拷贝,被移动? -- 1.I/O流 2.单例模式...
 * 
 */

//继承和多态中的final与override关键字
/**
 * final: -- 修饰基类,父类
 * 1.final可以修饰一个类,使其不能被继承.
 * 2.final还可以修饰成员函数,使其不能被重写.
 * 
 * override: --- 修饰派生类
 * 1.override用于修饰派生类的虚函数.检查是否完成重写.
 * 
 * 
 * 什么情况下子类必须重写虚函数 --- 规定:纯虚函数的子孙类必须至少有一个重写纯虚函数.
 * 
 * 
 */

//委托构造 -- 可读性差点,意义不大,只提高了复用性.但可以不使用,可有可无
/**
 * 委托构造函数也是一种构造函数，这种构造函数可以委托其他构造函数来帮它完成一些对象成员的初始化操作。
 * 一个构造函数可以调用其他构造函数
 */
/*class Person
{
public:
	Person(const char* name, int age)
		:_name(name)
		, _age(age)
	{}
	Person(const char* name)  //委托构造
		:Person(name, 18)   // ---- 借用已有的构造函数来帮助构造,初始化
	{}
private:
	string _name;
	int _age;
};*/







//可变参数模板 --- 记忆:声明时:三个点,在中间. 单独使用时,三个点,在后边. --- 特例,sizeof是宏,所以三个点,在中间
/**
 * 起源:C语言的printf()
 * int printf ( const char * format, ... ); //这三个点...就是可变参数
 * C语言底层是编译器开了一个参数数组,三个参数就存三个空间,四个参数就存4个...
 * 
 * C++11的新特性可变参数模板能够让您创建可以接受可变参数的函数模板和类模板，相比
 * C++98 / 03，类模版和函数模版中只能含固定数量的模版参数，可变模版参数无疑是一个巨大的改
 * 进。然而由于可变模版参数比较抽象，使用起来需要一定的技巧，所以这块还是比较晦涩的。现
 * 阶段呢，掌握一些基础的可变参数模板特性就够用了，所以这里点到为止，以后如果有需要再深入学习。
 * 
 *   
 * Args是一个模板参数包，args是一个函数形参参数包  
 * 声明一个参数包Args ... args，这个参数包中可以包含0到任意个模板参数,代表的就是0到任意个参数。
 * 
 * -----  (注:args是个名称,可以任意取,习惯写成args)  
 * -----  (参数包写法为Args ... 命名) (类似类型写法T t)
 * 
 * 可变参数模板使用场景:线程  -- 线程库:<thread> --C++11
 * (线程:我们需要分配不同任务给不同线程去执行.不同任务有不用需求和情况---> 因此需要支持多种类型)	
 * 1.C语言通过使用 void*传参,然后强转成需要的类型, 来解决不同类型的问题. 无参数传null,1个参数直接传void*,多个参数就放在一个结构体内再传void*
 * 2.C++11使用了一个类去封装线程.(C++不限于函数,还可以是可执行对象,如仿函数等...) , 
 *	   这个类使用了可变参数包,可以传任意个类型.用的时候再解析出来.
 *  
 * 可变参数模板主要是为库准备的 -- 我们目前先了解了解
 * 
 * 容器中都有一个emplace系列
 * 特点:
 * 1.可以传多个参数,传一个参数时和其他同样参数的函数功能一样,如push_back和emplace_back 效率基本一样  但底层实现不一样
 * 2.emplace有直接构造情况... 只要传构造函数的参数,可变参数包就会自动推导到相应构造函数-->直接构造
 * 
 * emplace确实有优化,可以多使用
 * 
 * 一些工具使用:
 * 1.支持sizeof ... (函数形参参数包)   
 * 2.不支持typeid().name().
 * 
 * 需要将可变参数解析出来才能使用可变参数 ,有几种拆解方法
 * 1.   ---> 递归拆解... ,套壳递归拆解等 
 * 2.
 * 
 * 
 *   
 */

/* 打印刻板参数包中 参数(类型) 个数 */
template<typename ... Args> //三个点中间
void showList(Args ... args)
{
	std::cout << sizeof ... (args) << std::endl; //打印有多少个类型
}

int man()
{
	showList();
	showList('x', 'y');
	showList('x', '1');
	showList(1);

	return 0;
}

// ---------------------------------------------------------------

 /* 解析出可变参数包  */
 // 递归,将可变参数包拆解.分而治之
void showList() //递归的终止条件,拆分到最后,会有一个无参的函数.定义一个无参的函数让递归停止.
{
	std::cout << std::endl;
}
template <class T, class ...Args>
void showList(const T& val, Args... args) //每次都将可变参数包的最左1个拆分出来,直到分解完毕.
{
	//cout << __FUNCTION__ << "(" << sizeof...(args) << ")" << endl; //__FUNCTION__会替换成当前函数名的字符串

	cout << typeid(val).name()<<" " <<val << " "; // 打印出 类型 和 值 
	ShowList(args...);
}

 /* 解析出可变参数包 ,法二 */
 template<typename T>
 int PrintArg(T&& t)  //由于编译器会生成很多份函数.如果使用直接传参(拷贝),则开销会非常大.所以一般会使用引用,引用折叠等...
 {
	 cout<<t<<" ";
	 return 0; //用于数组初始化为0
 }
 template<typename ... Args>
 void ShowList(Args ... args)
 {
     int arr[] = { PrintArg(args) ... };//此处只写args,意义类似拆解,拆一个参数出来.剩下的就在 三个点 ... 中. --- 编译器自动解析
										//函数可以是任意的.看需求使用
	// 编译器实际生成类似于 int arr[] = { func(args1),func(args2),func(args3), ...);
 }

/* //逗号表达式写法,两种写法一样
 template<typename T>
 void PrintArg(T t) //直接传参.开销很大... 不推荐
 {
	 cout << t << " ";
 }
 template<typename ... Args>
 void ShowList(Args ... args)
 {
    int arr[] = { (PrintArg(args),0) ... }; //如果函数不带返回值,可以用逗号表达式,取最后一个为返回值,也是用于初始化数组为0
 }
*/

// emplace
/** 
 * C++11 给STL容器都增加了emplace操作
 * 如果是push_back/push_front,则对应增加emplace_bask /emplace_front
 * 如果是insert , 则对应增加emplace
 * 
 * emplace系列支持了可变参数包和引用折叠.如insert和push支持的emplace基本也支持
 *   --> 可以同时使用inset/push和emplace. //插入相同对象时,功能基本没有区别
 * 
 * 区别点:
 * 1.一定情况下,可以实现直接构造,直接使用参数在自己的对象内构造 -- 跳过如(先构造匿名对象,再移动构造)  --- 高效体现,深拷贝差不多,快一丢丢
 * 2.浅拷贝的类效率高会明显 
 */

 /* 测试emplace区别 */
 int man()
 {
	 std::list<test::string> lt;
	 lt.push_back(std::move("3333"));
	 lt.emplace_back(std::move("3333"));
	 return 0;
 }
/*
 结果:
 string(const char* s) --左值, 默认构造
 string(string&& s) --移动拷贝

 string(const char* s) --左值, 默认构造 --- emplace直接构造
 //深拷贝只快一点点,因为构造+移动构造 和直接构造差不多
 //原因分析: 
 1.push_back是隐式类型转换,模板推导出来类型是string,所以由char*构造成string再push.
 2.emplace_back是由可变参数包直接推导成char*,然后直接构造 -- 直接拿参数包去构造参数 -- emplace是传什么就是什么,直接干,直接定位new显示调用节点的构造函数...
*/



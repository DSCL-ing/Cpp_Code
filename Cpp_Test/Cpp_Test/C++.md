[TOC]



## 1. 什么是C++ 

​    C语言是结构化和模块化的语言，适合处理较小规模的程序。对于复杂的问题，规模较大的 
程序，需要高度的抽象和建模时，C语言则不合适。为了解决软件危机， 20世纪80年代， 计算机
界提出了OOP(object oriented programming：面向对象)思想，支持面向对象的程序设计语言 
应运而生。
   1982年，Bjarne Stroustrup博士在C语言的基础上引入并扩充了面向对象的概念，发明了一 
种新的程序语言。为了表达该语言与C语言的渊源关系，命名为C++。因此：C++是基于C语言而 
产生的，它既可以进行C语言的过程化程序设计，又可以进行以抽象数据类型为特点的基于对象的 
程序设计，还可以进行面向对象的程序设计。

## 2. C++的发展史 

​    1979年，贝尔实验室的本贾尼等人试图分析unix内核的时候，试图将内核模块化，于是在C 
语言的基础上进行扩展，增加了类的机制，完成了一个可以运行的预处理程序，称之为C  with 
classes。

语言的发展就像是练功打怪升级一样，也是逐步递进，由浅入深的过程。我们先来看下C++的历 
史版本。

|      阶段      | 内容                                                         |
| :------------: | :----------------------------------------------------------- |
| C with classes | 类及派生类、公有和私有成员、类的构造和析构、友元、内联函数、赋值运算符重载等 |
|     C++1.0     | 添加虚函数概念，函数和运算符重载，引用、常量等               |
|     C++2.0     | 更加完善支持面向对象，新增保护成员、多重继承、对象的初始化、抽象类、静态成员以及const成员函数 |
|     C++3.0     | 进一步完善，引入模板，解决多重继承产生的二义性问题和相应构造和析构的处理 |
|     C++98      | C++标准第一个版本，绝大多数编译器都支持，得到了国际标准化组织(ISO)和美国标准化协会认可，以模板方式重写C++标准库，引入了STL(标准模板库) |
|     C++03      | C++标准第二个版本，语言特性无大改变，主要：修订错误、减少多异性 |
|     C++05      | C++标准委员会发布了一份计数报告(Technical Report，TR1)，正式更名C++0x，即：计划在本世纪第一个10年的某个时间发布 |
|     C++11      | 增加了许多特性，使得C++更像一种新语言，比如：正则表达式、基于范围for循环、auto关键字、新容器、列表初始化、标准线程库等 |
|     C++14      | 对C++11的扩展，主要是修复C++11中漏洞以及改进，比如：泛型的lambda表达式，auto的返回值类型推导，二进制字面常量等 |
|     C++17      | 在C++11上做了一些小幅改进，增加了19个新特性，比如：static_assert()的文本信息可选，Fold表达式用于可变的模板，if和switch语句中的初始化器等 |
|     C++20      | 自C++11以来最大的发行版，引入了许多新的特性，比如：模块(Modules)、协程(Coroutines)、范围(Ranges)、概念(Constraints)等重大特性，还有对已有特性的更新：比如Lambda支持模板、范围for支持初始化等 |
|     C++23      |                                                              |
|     C++26      |                                                              |
|                |                                                              |

## 3. C++的重要性 

### 3.1 语言的使用广泛度

在30多年的发展中，C/C++几乎一直稳居前5。

TIOBE 编程语言社区排行榜是编程语言流行趋势的一个指标，每月更新，这份排行榜排名基于互联网上有经验的程序员、 课程和第三方厂商的数量。排名使用著名的搜索引擎（诸如 Google、MSN、Yahoo!、Wikipedia、YouTube 以及 Baidu 等）进行计算。 
注意：排名不能说明那个语言好，那个不好，每门编程语言都有适应自己的应用场景。

### 3.2 在工业领域

1. **操作系统以及大型系统软件开发** 
所有操作系统几乎都是C/C++写的，许多大型软件背后几乎都是C++写的，比如：
Photoshop、Oﬃce、JVM(Java虚拟机)等，究其原因还是性能高，可以直接操控硬件。 
2. **服务器端开发**
后台开发：主要侧重于业务逻辑的处理，即对于前端请求后端给出对应的响应，现在主流采 
用java，但内卷化比较严重，大厂可能会有C++后台开发，主要做一些基础组件，中间件、 
缓存、分布式存储等。服务器端开发比后台开发跟广泛，包含后台开发，一般对实时性要求 
比较高的，比如游戏服务器、流媒体服务器、网络通讯等都采用C++开发的。
3. **游戏开发** 
PC平台几乎所有的游戏都是C++写的，比如：魔兽世界、传奇、CS、跑跑卡丁车等，市面上
相当多的游戏引擎都是基于C++开发的，比如：Cocos2d、虚幻4、DirectX等。三维游戏领 
域计算量非常庞大，底层的数学全都是矩阵变换，想要画面精美、内容丰富、游戏实时性 
搞，这些高难度需求无疑只能选C++语言。比较知名厂商：腾讯、网易、完美世界、巨人网 
络等。


4. **嵌入式和物联网领域** 
嵌入式：就是把具有计算能力的主控板嵌入到机器装置或者电子装置的内部，能够控制这些
装置。比如：智能手环、摄像头、扫地机器人、智能音响等。 
谈到嵌入式开发，大家最能想到的就是单片机开发(即在8位、16位或者32位单片机产品或者 
裸机上进行的开发)，嵌入式开发除了单片机开发以外，还包含在soc片上、系统层面、驱动 
层面以及应用、中间件层面的开发。 
常见的岗位有：嵌入式开发工程师、驱动开发工程师、系统开发工程师、Linux开发工程 
师、固件开发工程师等。 
知名的一些厂商，比如：以华为、vivo、oppo、小米为代表的手机厂；以紫光展锐、乐鑫为 
代表的芯片厂；以大疆、海康威视、大华、CVTE等具有自己终端业务厂商；以及海尔、海 
信、格力等传统家电行业。 
随着5G的普及，物联网(即万物互联，)也成为了一种新兴势力，比如：阿里lot、腾讯lot、京 
东、百度、美团等都有硬件相关的事业部。
5. **数字图像处理** 
数字图像处理中涉及到大量数学矩阵方面的运算，对CPU算力要求比较高，主要的图像处理
算法库和开源库等都是C/C++写的，比如：OpenCV、OpenGL等，大名鼎鼎的Photoshop 
就是C++写的。
6. **人工智能** 
一提到人工智能，大家首先想到的就是python，认为学习人工智能就要学习python，这个
是误区，python中库比较丰富，使用python可以快速搭建神经网络、填入参数导入数据就 
可以开始训练模型了。但人工智能背后深度学习算法等核心还是用C++写的。
7. **分布式应用** 
近年来移动互联网的兴起，各应用数据量业务量不断攀升；后端架构要不断提高性能和并发
能力才能应对大信息时代的来临。在分布式领域，好些分布式框架、文件系统、中间组件等 
都是C++开发的。对分布式计算影响极大的Hadoop生态的几个重量级组件：HDFS、 
zookeeper、HBase等，也都是基于Google用C++实现的GFS、Chubby、BigTable。包括分 
布式计算框架MapReduce也是Google先用C++实现了一套，之后才有开源的java版本。
除了上述领域外，在：科学计算、浏览器、流媒体开发、网络软件等都是C++比较适合的场景， 
作为一名老牌语言的常青树，C++一直霸占编程语言前5名，肯定有其存在的价值。

除了上述领域外，在：科学计算、浏览器、流媒体开发、网络软件等都是C++比较适合的场景， 
作为一名老牌语言的常青树，C++一直霸占编程语言前5名，肯定有其存在的价值。



## C++关键字(C++98) 

C++总计63个关键字，C语言32个关键字

|   |   |   |   |   |   |
|:---|:---|:---|:---|:---|:---|
|asm|do|if|return|try|continue|
|auto|double|inline|short|typedef|for|
|bool|dynamic_cast|int|signed|typeid|public|
|break|else|long|sizeof|typename|throw|
|case|enum|mutable|static| union| wchar_t|
|catch|explicit|namespace|static_cast|unsigned|default|
|char|export|new|struct|using|friend|
|class|extern|operator|switch|virtual|register|
|const|false|private|template|void|true|
|const_cast|ﬂoat|protected|this|volatile|while|
|delete|goto|reinterpret_cast|

 

### C++支持函数重载的原理--名字修饰(name Mangling) 

为什么C++支持函数重载，而C语言不支持函数重载呢？ 

在C/C++中，一个程序要运行起来，需要经历以下几个阶段：预处理、编译、汇编、链接。

![image-20240528221018205](C++.assets/image-20240528221018205.png)

![image-20240528220845691](C++.assets/image-20240528220845691.png)

1. 实际项目通常是由多个头文件和多个源文件构成，而通过C语言阶段学习的编译链接，我们可以知道，【当前a.cpp中调用了b.cpp中定义的Add函数时】，编译后链接前，a.o的目标 文件中没有Add的函数地址，因为Add是在b.cpp中定义的，所以Add的地址在b.o中。那么怎么办呢？
2. 所以链接阶段就是专门处理这种问题，链接器看到a.o调用Add，但是没有Add的地址，就会到b.o的符号表中找Add的地址，然后链接到一起。(老师要带同学们回顾一下)
3. 那么链接时，面对Add函数，链接接器会使用哪个名字去找呢？这里每个编译器都有自己的函数名修饰规则。
4. 由于Windows下vs的修饰规则过于复杂，而Linux下g++的修饰规则简单易懂，下面我们使用了g++演示了这个修饰后的名字。
5. 通过下面我们可以看出gcc的函数修饰后名字不变。而g++的函数修饰后变成【_Z+函数长度
+函数名+类型首字母】。

- 采用C语言编译器编译后结果

![image-20240528221122791](C++.assets/image-20240528221122791.png)

结论：在linux下，采用gcc编译完成后，函数名字的修饰没有发生改变。 

- 采用C++编译器编译后结果

![image-20240528221134271](C++.assets/image-20240528221134271.png)

结论：在linux下，采用g++编译完成后，函数名字的修饰发生改变，编译器将函数参数类型信息添加到修改后的名字中。

- Windows下名字修饰规则

![image-20240528221314093](C++.assets/image-20240528221314093.png)

对比Linux会发现，windows下vs编译器对函数名字修饰规则相对复杂难懂，但道理都是类似的，我们就不做细致的研究了。 
【C/C++函数调用约定和名字修饰规则-对vs下函数名修饰规则讲解】

[C/C++ 函数调用约定-CSDN博客](https://blog.csdn.net/lioncolumn/article/details/10376891)

> 函数调用约定
>
>  常见的函数调用约定[5]：cdecl,stdcall,fastcall,thiscall,naked call
>
>  MFC调用约定(VS6:Project Settings->C/C++ <Category:Code Generation> Calling convention:)
>
>  
>
> 1, __cdecl（C调用约定.The C default calling convention）C/C++ 缺省调用方式
>
>  1)压栈顺序:函数参数从右到左
>
>  2)参数栈维护:由调用函数把参数弹出栈, 传送参数的内存栈由调用函数来维护
>
>  （正因为如此，实现可变参数vararg的函数(如printf)只能使用该调用约定）
>
>  3)函数修饰名约定:VC将函数编译后会在函数名前面加上下划线前缀
>
>  4)每一个调用它的函数都包含清空堆栈的代码，所以产生的可执行文件大小会比调用_stdcall函数的大
>
>  
>
> 2, __stdcall (Pascal方式清理C方式压栈，通常用于Win32 Api中)
>
>  1)压栈顺序:函数参数从右到左的压栈顺序
>
>  2)参数栈维护:被调用函数把参数弹出栈(在退出时清空堆栈)
>
> 　3)函数修饰名约定:VC将函数编译后会在函数名前面加上下划线前缀，在函数名后加上"@"和参数的字节数
>
>   ex. VC: int f(void *p) (编译后)-> _f@4(在外部汇编语言里可以用这个名字引用这个函数)
>
>  
>
> 3, __fastcall (快速调用约定,通过寄存器来传送参数)
>
>  1)压栈顺序:用ECX和EDX传送前两个双字（DWORD）或更小的参数，剩下的参数仍旧自右向左压栈传送
>
>  2)参数栈维护:被调用函数在返回前清理传送参数的内存栈
>
>  3)函数修饰名约定:VC将函数编译后会在函数名前面加上"@"前缀，在函数名后加上"@"和参数的字节数
>
>  
>
> 4, thiscall (本身调用,仅用于“C++”成员函数)
>
>  1)压栈顺序:this指针存放于CX/ECX寄存器中，参数从右到左的压栈顺序
>
>  2)thiscall不是关键词，因此不能被程序员指定
>
>  
>
> 5, naked call (裸调)
>
>  1)当采用1-4的调用约定时，如果必要的话，进入函数时编译器会产生代码来
>
>   保存ESI，EDI，EBX，EBP寄存器, 退出函数时则产生代码恢复这些寄存器的内容
>
>   (这些代码称作 prolog and epilog code,一般，ebp,esp的保存是必须的)
>
>  2)naked call不产生这样的代码。naked call不是类型修饰符，故必须和_declspec共同使用
>
>  
>
> ・关键字 __stdcall、__cdecl和__fastcall(1-3)可以直接加在要输出的函数前。
>
>  它们对应的命令行参数分别为/Gz、/Gd和/Gr。缺省状态为/Gd，即__cdecl
>
> ・要完全模仿PASCAL调用约定首先必须使用__stdcall调用约定，函数名修饰约定可通过其它方法模仿
>
> ・WINAPI宏，Windows.h支持该宏，它可以将出函数翻译成适当的调用约定，
>
>  在WIN32中，它被定义为__stdcall。使用WINAPI宏可以创建自己的APIs
>
>  
>
> 引用:
>
>  很多API函数就是象这样声明的:
>  int WINAPI MessageBoxA(HWND,LPCSTR,LPSTR,UINT);
>  而WINAPI实际上就是__stdcall.
>  大多数API都采用__stdcall调用规范,这是因为几乎所有的语言都支持__stdcall调用.
>
>  相比之下,__cdecl只有在C语言中才能用. 但__cdecl调用有一个特点,就是能够实现可变参数的函数调用, 
>
>  比如printf,这用__stdcall调用是不可能的.
>  __fastcall这种调用规范比较少见,但是在Borland C++ Builder中比较多的采用了这种调用方式.
>  如果有共享代码的需要,比如写DLL,推荐的方法是用__stdcall调用,因为这样适用范围最广.
>
>  如果是C++语言写的代码供Delphi这样的语言调用就必须声明为__stdcall,
>
>  因为Pascal不支持cdecl调用(或许Delphi的最新版本能够支持也说不定,这个不太清楚).
>
>  在其他一些地方,比如写COM组件,几乎都用的是stdcall调用.
>
>  在VC或Delphi或C++Builder里面都可以从项目设置中更改默认的函数调用规范,
>
>  当然也可在函数声明时加入__stdcall,__cdecl,__fastcall关键字来明确的指示本函数用哪种调用约定.
>  __declspec一般都是用来声明DLL中的导出函数.这个关键字也有一些其他的用法,不过非常罕见.
>
>  __declspec主要是用于说明DLL的引出函数的,在某些情况下用__declspec(dllexport)在DLL中声明引出函数,
>
>  比用传统的DEF文件方便.在普通程序中也可用__declspec(dllimport)说明函数是位于另一个DLL中的导出函数.
>
>  以下是在dev-c++里建立自已的dll时的dll.h里面的代码,这里面有一个:_declspec(dllexport)
>
>   \#ifndef _DLL_H_
>   \#define _DLL_H_//防重复定义
>
>   \#if BUILDING_DLL
>   \# define DLLIMPORT __declspec (dllexport)
>   \#else
>   \# define DLLIMPORT __declspec (dllimport)
>   \#endif
>   DLLIMPORT void HelloWorld (void);
>   \#endif
>  上面代码里面的_delcspce(dllexport)被定义为宏,这样可以提高程序的可读性.
>
>  这个的作用是将函数定义为导出函数,也就是说这个函数要被包含这个函数的程序之外的程序调用.
>
>  本语句中就是:void Helloword(void):
>
>  摘自msdn:在 32 位编译器版本中，可以使用 __declspec(dllexport) 关键字从 DLL 导出数据、
>
>  函数、类或类成员函数。__declspec(dllexport) 将导出指令添加到对象文件
>
>  若要导出函数，__declspec(dllexport) 关键字必须出现在调用约定关键字的左边（如果指定了关键字）
>
>  例如：
>
>  __declspec(dllexport) void __cdecl Function1(void);
>
>  若要导出类中的所有公共数据成员和成员函数，关键字必须出现在类名的左边，如下所示：
>
>  class __declspec(dllexport) CExampleExport : public CObject
>   { ... class definition ... };
>
>  生成 DLL 时，通常创建一个包含正在导出的函数原型和/或类的头文件，并将 __declspec(dllexport)
>
>  添加到头文件中的声明。若要提高代码的可读性，请为 __declspec(dllexport) 定义一个宏并对正在导出的
>
>  每个符号使用该宏：#define DllExport __declspec( dllexport )
>
>  __declspec(dllexport) 将函数名存储在 DLL 的导出表中。如果希望优化表的大小
>
> 附录>
>
>  1, 修饰名(Decoration name)
>
> 　　“C”或者“C++”函数在内部（编译和链接）通过修饰名识别。修饰名是编译器在编译函数定义或者原
>
> 　　型时生成的字符串。有些情况下使用函数的修饰名是必要的，如在[模块定义文件](http://baike.baidu.com/view/2779203.htm)里头指定输出“C++”
>
> 　　重载函数、构造函数、析构函数，又如在汇编代码里调用“C””或“C++”函数等。
>
> 　　修饰名由函数名、类名、调用约定、返回类型、参数等共同决定。
>
> 　　2、名字修饰约定随调用约定和编译种类(C或C++)的不同而变化。
>
> 　　函数名修饰约定随编译种类和调用约定的不同而不同，下面分别说明。
>
> 　　a、C编译时函数名修饰约定规则：
>
> 　　__stdcall调用约定在输出函数名前加上一个下划线前缀，后面加上一个“@”符号和其参数的字节数，
>
> 　　格式为_functionname@number。
>
> 　　__cdecl调用约定仅在输出函数名前加上一个下划线前缀，格式为_functionname。
>
> 　　__fastcall调用约定在输出函数名前加上一个“@”符号，后面也是一个“@”符号和其参数的字节数，
>
> 　　格式为@functionname@number。
>
> 　　它们均不改变输出函数名中的字符大小写，这和PASCAL调用约定不同，
>
>   PASCAL约定输出的函数名无任何修饰且全部大写。
>
> 　　b、C++编译时函数名修饰约定规则：
>
> 　　__stdcall调用约定：
>
> 　　1、以“?”标识函数名的开始，后跟函数名；
>
> 　　2、函数名后面以“@@YG”标识参数表的开始，后跟参数表；
>
> 　　3、参数表以代号表示：
>
> 　　X--void ，
>
> 　　D--char，
>
> 　　E--unsigned char，
>
> 　　F--short，
>
> 　　H--int，
>
> 　　I--unsigned int，
>
> 　　J--long，
>
> 　　K--unsigned long，
>
> 　　M--float，
>
> 　　N--double，
>
> 　　_N--bool，
>
> 　　....
>
> 　　PA--表示指针，后面的代号表明指针类型，如果相同类型的指针连续出现，以“0”代替，一个“0”代
>
> 　　表一次重复；
>
> 　　4、参数表的第一项为该函数的返回值类型，其后依次为参数的数据类型,指针标识在其所指数据类型前
>
> 　　；
>
> 　　5、参数表后以“@Z”标识整个名字的结束，如果该函数无参数，则以“Z”标识结束。
>
> 　　其格式为“?functionname@@YG*****@Z”或“?functionname@@YG*XZ”，例如
>
> 　　int Test1（char *var1,unsigned long）-----“?Test1@@YGHPADK@Z”
>
> 　　void Test2（） -----“?Test2@@YGXXZ”
>
> 　　__cdecl调用约定：
>
> 　　规则同上面的_stdcall调用约定，只是参数表的开始标识由上面的“@@YG”变为“@@YA”。
>
> 　　__fastcall调用约定：
>
> 　　规则同上面的_stdcall调用约定，只是参数表的开始标识由上面的“@@YG”变为“@@YI”。
>
> 　　VC++对函数的省缺声明是"__cedcl",将只能被C/C++调用

6. 通过这里就理解了C语言没办法支持重载，因为同名函数没办法区分。而C++是通过函数修
饰规则来区分，只要参数不同，修饰出来的名字就不一样，就支持了重载。
7. 如果两个函数函数名和参数是一样的，返回值不同是不构成重载的，因为调用时编译器没办
法区分。


## 构造函数
1. 构造函数
2. 拷贝构造函数
3. 赋值运算符重载
4. 析构函数
5. 取地址运算符重载
6. const取地址运算符重载

- 所有构造函数都不能被其他成员函数复用(委托构造除外).
  看着很像复用的情况:string::operator=()在成员函数内自己定义自己,**构建临时对象**,然后swap(); 因此这不是复用
- 成员函数也不能自己调用析构函数,因为肚子里的蛋不能杀的了鸡.
- 赋值运算符重载不仅用于拷贝构造.还可以实现某成员的=重载
  ```
    struct A {
    A() = default;
    int operator=(int i) {  //只给a重载
        _a = i;
        return _a;
    }
    A& operator=(const A& a) { //拷贝构造作用
        _a = a._a;
        _b = a._b;
        return *this;
    }
    int _a = 0;
    int _b = 0;
    };
  ```



## placement new

> 作者: 苏丙榅 链接: https://www.subingwen.cn/cpp/union/

一般情况下，使用new申请空间时，是从系统的堆（heap）中分配空间，申请所得的空间的位置是根据当时的内存的实际使用情况决定的。但是，在某些特殊情况下，可能需要在已分配的特定内存创建对象，这种操作就叫做placement new即定位放置 new。

定位放置new操作的语法形式不同于普通的new操作：

- 使用new申请内存空间：

  `Base* ptr = new Base;`

- 使用定位放置new申请内存空间：

  `ClassName* ptr = new (定位的内存地址)ClassName;`

例程:

```]
#include <iostream>
using namespace std;

class Base
{
public:
    Base() {}
    ~Base() {}
    void print()
    {
        cout << "number value: " << number << endl;
    }
private:
    int number;
};

int main()
{
    int n = 100;
    Base* b = new (&n)Base;
    b->print();
    return 0;
}
```

输出结果

`number value: 100`

在程序的第20行，使用定位放置的方式为指针b申请了一块内存，也就是说此时指针 b指向的内存地址和变量 n对应的内存地址是同一块（栈内存），而在Base类中成员变量 number的起始地址和Base对象的起始地址是相同的，所以打印出 number 的值为100也就是整形变量 n 的值。

最后，给大家总结一下关于placement new的一些细节：

1. 使用定位放置new操作，既可以在栈(stack)上生成对象，也可以在堆（heap）上生成对象，这取决于定位时指定的内存地址是在堆还是在栈上。
2. 从表面上看，定位放置new操作是申请空间，其本质是利用已经申请好的空间，真正的申请空间的工作是在此之前完成的。
3. 使用定位放置new 创建对象时会自动调用对应类的构造函数，但是由于对象的空间不会自动释放，如果需要释放堆内存必须显示调用类的析构函数。
4. 使用定位放置new操作，我们可以反复动态申请到同一块堆内存，这样可以避免内存的重复创建销毁，从而提高程序的执行效率（比如网络通信中数据的接收和发送）。

----



## 类成员类型修饰符

​    [C++程序员应了解的那些事（56）const 和 volatile 成员函数、mutable 数据成员_mutable成员一般在什么情况下定义-CSDN博客](https://blog.csdn.net/qfturauyls/article/details/109344360#:~:text=【valatile成员函数】 也可以将成员函数声明为 volatile 。 如果一个类对象的值可能被修改的方式是编译器无法控制或检测的，则把它声明为 volatile 。,与 const 类对象类似，对于一个 volatile 类对象，只有 volatile 成员函数、构造函数、析构函数可以被调用。)

**为尊重类对象的常量性，编译器必须区分不安全与安全的成员函数(即区分试图修改类对象与不试图修改类对象的函数)。**



**【const成员函数】**

​    类的设计者通过把成员函数声明为 const ，以表明它们不修改类对象。只有被声明为 const 的成员函数才能被一个 const 类对象调用。关键字 const 被放在成员函数的参数表和函数体之间。**对于在类体之外定义的 const 成员函数，我们必须在它的定义和声明中同时指定关键字const 。**把一个修改类数据成员的函数声明为 const 是非法的。
​    一般来说，任何一个类如果期望被广泛使用，就应该把那些不修改类数据成员的成员函数声明为 const 成员函数。但是，把一个成员函数声明为 const 并不能阻止程序员可能做到的所有修改动作。把一个成员函数声明为 const 可以保证这个成员函数不修改类的数据成员，但是如果该类含有指针，那么在 const 成员函数中就能修改指针所指的对象。编译器不会把这种修改检测为错误，这常常令 C++ 初学者吃惊，例如：

```
#include <cstring>
class Text {
public:   
    void bad(const string &parm )const;
private:
    char *_text;
};
void Text::bad(const string &parm ) const
{   
    for( int ix = 0; ix < parm.size(); ++ix )
   {      
      _text[ix] = parm[ix];  // 不好的风格，但不是错误     
   }
   //_text = parm.c_str();  // 错误：不能修改数据成员
}
```

![image-20240705221819112](C++.assets/image-20240705221819112.png)

**const 成员函数可以被相同参数表的非 const 成员函数重载。在这种情况下，类对象的常量性决定了调用哪个函数。构造函数和析构函数是两个例外，即使构造函数和析构函数不是 const 成员函数，const 对象也可以调用它们。**当构造函数执行结束、类对象已经被初始化时，类对象的常量性才被建立。析构函数一被调用，常量性就消失。所以一个 const 类对象“从构造完成时刻到析构开始时刻”这段时间内被认定是 const 。

**【valatile成员函数】**
    也可以将成员函数声明为 volatile 。**如果一个类对象的值可能被修改的方式是编译器无法控制或检测的，则把它声明为 volatile 。与 const 类对象类似，对于一个 volatile 类对象，只有 volatile 成员函数、构造函数、析构函数可以被调用。**

**【mutable数据成员】**

​     **为了允许修改一个类的数据成员，即使它是一个 const 对象的数据成员，我们也可以把该数据成员声明为 mutable (易变的)。**mutable 数据成员永远不会是 const 成员，即使它是一个 const 对象的数据成员。mutable 成员总可以被更新，即使是在一个 const 成员函数中。**为把一个成员声明为 mutable 数据成员，我们必须把关键字 mutable 放在类成员中的数据成员声明之前，例如：**

```
class Screen {
public:
// 成员函数
private:    
string _screen;   
mutable string::size_type _cursor; // mutable 成员
};
```

**【const数据成员】**

 **const修饰的成员变量相当于该变量是一个常量，所以只能在初始化列表上初始化。**

```
class Date{
public:
	Date(int year = 1900, int month = 1)
		:_year(year)
		, _month(month)
		, _day(1)
	{}
private:
	int _year;
	int _month;
	const int _day;
};
```



## operator type() 类型转换运算符

[C++:28---类类型转换之类型转换运算符operator（explicit）_c++ operator 类型转换-CSDN博客](https://blog.csdn.net/qq_41453285/article/details/95189974)

类类型转换运算符是类的一种特殊成员函数，它负责将一个类转换为其他类型



#### 与类的隐式类型转换（转换构造函数）的不同：

- 类的隐式类型转换：是将其他类型转换为类类型
- 类型转换运算符：将类类型转换为其他类型



#### 类型转换函数的形式：

- type表示某种类型
- 类型转换运算符可以面向任意类型（除了void）进行定义，只要该类型能作为函数的返回类型
- 返回类型不能指定,自动根据return的值进行推导

```
operator type() const;
```

#### 注意事项：

- 不允许转换成数组或者函数类型，但允许转换为指针（包括数组指针以及函数指针）或者引用类型
- 类型转换运算符没有显式的返回类型，也没有形参
- 必须定义成类的成员函数
- 类型转换函数通常应该为const类型
- 并且转换的类型要与return结果类型相同
- 类类型转换函数不能调用

#### 错误格式的使用案例

- 类型转换运算符是隐式执行的，所以无法给这些函数传递实参，当然也就不能在类型转换运算符的定义中使用任何形参
- 同时，尽管类型转换函数不负责指定返回类型，但实际上每个类型转换函数都会返回一个对应类型的值

下面是一些错误的使用案例:

```
class SmallInt {
public:
    int operator int() const;    //错误，不能指定返回类型
    operator int(int = 0)const;  //错误，不能有参数
    operator int*()const { return 42; }//错误，42与int*类型不一致
};
```


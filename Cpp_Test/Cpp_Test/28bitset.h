#pragma once

/** 基础知识
 * 
 * 位运算:
 * $ 任何数和0进行或运算结果都是它本身 -- 0和任何数或运算结果还是那个数
 * 用途:在二进制运算时,需要修改其中的一个位或几个位,但要保证不需要修改的位不被修改.,则可以用使用 "0或" 来控制:
 * -- 只要给不需要修改的位或上0,即可保证不被修改
 * 场景:需要将某个位从0置为1,其他位保持不变:> 将需要的二进制数或上000...001000...000(1为需要置1的位),即可将该位置1
 * 
 * $ 任何数和全1(111....111)进行与运算结果都是它本身 -- 全1和任何数进行与运算结果还是那个数
 * 场景:reset:将某一位置0 -- 只需要与上111...0...111(0为需要置零的位)
 * 
 * $ 获得全1的方法:按位取反
 * 
 * $ 左移:低位往高位移   右移:高位往低位移
 * 
 * $ C中位运算级别很低,注意要加上括号
 * 
 * $ 位运算取块用除.取位用模 --- 模从0开始,可以这种原因计算机很多以0开始
 * 
 */

/**
 * 1. 面试题
 * 给40亿个不重复的无符号整数，没排过序。给一个无符号整数，如何快速判断一个数是否在这40亿个数中。【腾讯】
 * 
 * 解决:构建位图,调用bs.test(x)即可
 */

#include<vector>
#include<iostream>
using std::cout;
using std::endl;

namespace test
{
/**位图概念
 * 所谓位图，就是用每一位来存放某种状态，适用于海量数据，数据无重复的场景。通常是用来判断某个数据存不存在的。
 * 
 * 	位图的应用
 * 		1. 快速查找某个数据是否在一个集合中
 * 		2. 排序 + 去重
 * 		3. 求两个集合的交集、并集等
 * 		4. 操作系统中磁盘块标记
 * 如果能够映射到位图,则会使等价的数据量大大减小,使其能够进入内存
 * 位图效率极高,时间复杂度O(1),节省内存
 * 
 * 缺点:只能映射整型
 * 
 */




	template<size_t N> // 非类型模板参数 -- N一般给最大值
	class bitset //位图可以叫做bitmap好点,不过stl叫做bitset
	{
		/** 位图
		 * 
		 * 位图在C++标准库std中
		 * https://legacy.cplusplus.com/reference/bitset/bitset/
		 * 
		 * 位图功能:
		 * $ 能够操作比特位,在某些场景下能使消耗空间大大 减小,足以容纳进内存,快速执行
		 *
		 *
		 * 需要实现的功能:
		 * 1.接收数用于开辟多大空间 -- 非类型模板参数 -- 根据不同情况传不同的值,位图还有很多功能,如果计算无符号整型需要传整型最大值
		 * 2.能够对位图某一比特位 置零 -- reset
		 * 3.能够对位图某一比特位 置1  -- set
		 * 4.能够得知某一比特位是0还是1 -- return bool ret
		 *
		 * 成员
		 * 1.成员:char数组 - vectot
		 *
		 * 位图调试,在监视窗口中获取原始视图的指针,然后从数组首地址开始看内存,内存是从右往左,从上往下看 ,两个字母为1个字节,字节内按二进制写法
		 *
		 */

	private:
		std::vector<char> _bits; //不允许访问,因为实现位图必须通过特殊操作

	public:
		bitset()
		{
			//1.求所需要的字节数,需要至少有N个bit位,而8bit一个字节,所以至少需要N/8个字节,由于会截断,故需要+1
			//2.必须全部置成0,或者1(如果逻辑全部取反的话)
			_bits.resize(N / 8 + 1, 0);
		}

		void set(size_t x) //置1
		{
			int i = x / 8; //确定下标
			int j = x % 8; //确定该字节内的第几位 -- 用来左移,定位到第j比特位
			//置1 对左移j位 进行或运算
			_bits[i] |= 1 << j;

		}

		void reset(size_t x) //置0
		{

			int i = x / 8; //确定下标
			int j = x % 8; //确定该字节内的第几位 -- 用来左移,定位到第j比特位
			//置0: 对取反后的左移j位的1 进行与运算
			_bits[i] &= ~(1 << j);
		}

		
		bool test(size_t x) //返回x所在的位是0或1 //标准库就叫做test
		{
			int i = x / 8; //确定下标
			int j = x % 8; //确定该字节内的第几位 -- 用来左移,定位到第j比特位
			return _bits[i] & (1 << j);
		}

		//bitset& filp(size_t x = N) //翻转全部bit位或某一位
		//{

		//}


	};


	void test_bitset1()
	{
		test::bitset<100> bs;//测试用
		//test::bitset<-1> bs;//无符号整型最大值 -- 和size_t npos = -1 一样 -- 可以看资源管理器,开的内存空间
		bs.set(10);
		bs.set(11);
		bs.set(15);
		cout << bs.test(10) << endl;
		cout << bs.test(11) << endl;

		bs.reset(10);
		bs.reset(11);
		cout << bs.test(10) << endl;
		cout << bs.test(11) << endl;
	}

}

//问题引申:1. 给定100亿个整数，设计算法找到只出现一次的整数？
//题目分析:1.100亿中,最大值为42亿,很多重复,只需要开辟size_t-1个空间,即500多M即可,所以位图可以使用
//解决:双位图 -- 封装两个位图的位图
namespace test2
{
	/** 位图扩展
	 * 
	 * 位图玩法多种多样,多练习才能驾驭
	 * 
	 * 
	 */

	template<size_t N>
	class twobitset //开了两个位图的封装 
	{
	public:
		void set(size_t x)
		{
			/** 原理
			 * 通过双位图,给三种状态 00,01,10;
			 * 00代表 0次
			 * 01代表 1次
			 * 10代表 2次及以上
			 * 
			 * 个位用bs1控制,十位用bs2控制
			 * 示例图如:
			 * _bs1:▭▭▭▭▭▭▭▭▭▭011
			 * _bs2:▭▭▭▭▭▭▭▭▭▭101
			 * 
			 */
			if (_bs1.test(x) == false && _bs2.test(x) == false)
			{
				_bs1.set(x);
			}
			else if (_bs1.test(x) == true && _bs2.test(x) == false)
			{
				_bs1.reset(x);
				_bs2.set(x);
			}
		}

		bool test(size_t x)
		{
			return _bs1.test(x) == true && _bs2.test(x) == false;//由题,只出现1次返回真
		}

	private:
		test::bitset<N> _bs1; //已经初始化成0了
		test::bitset<N> _bs2;
	};

	void test_twobitset1()
	{
		int a[] = { 3, 45, 53, 32, 32, 43, 3, 2, 5, 2, 32, 55, 5, 53,43,9,8,7,8 };
		test2::twobitset<100> bs;
		for (auto i : a)
		{
			bs.set(i);
		}
		for (auto i : a)
		{
			if (bs.test(i))
			{
				cout << i << " ";
			}
		}

	}

}


//2. 给两个文件，分别有100亿个整数，我们只有1G内存，如何找到两个文件交集？
/**
 * 题目分析:1G内存只能足够一个位图使用(512M)
 * 
 * 基础方法:一个文件进位图,另一个文件进行比对,如果存在就是交集
 * 存在问题:基础方法得到的交集有重复的,违背集合互异性,需要再次去重
 * 
 * (如果不限空间,可以开两个位图分别存两个文件的数据,然后再与运算选出两个都是1的就是交集
 * 
 * 解决方法1:在基础方法的基础上,每次匹配到交集就reset.下次重复值就不会匹配成功了
 * 
 * 
 */


//3. 位图应用变形：1个文件有100亿个int，1G内存，设计算法找到出现次数不超过2次的所有整数
/**
 * 方法:双位图
 * 出现0次:00
 * 出现1次:01
 * 出现2次:10
 * 出现3次及以上:11
 * 
 * 
 */

//布隆过滤器




#pragma once

/** 基础知识
 * 
 * 位运算:
 * $ 任何数和0进行或运算结果都是它本身 -- 0和任何数或运算结果还是那个数
 * 用途:在二进制运算时,需要修改其中的一个位或几个位,但要保证不需要修改的位不被修改.,则可以用使用 "0或" 来控制:
 * -- 只要给不需要修改的位或上0,即可保证不被修改
 * 场景:需要将某个位从0置为1,其他位保持不变:> 将需要的二进制数或上000...001000...000(1为需要置1的位),即可将该位置1
 * 
 * $ 任何数和全1(111....111)进行与运算结果都是它本身 -- 全1和任何数进行与运算结果还是那个数
 * 场景:reset:将某一位置0 -- 只需要与上111...0...111(0为需要置零的位)
 * 
 * $ 获得全1的方法:按位取反
 * 
 * $ 左移:低位往高位移   右移:高位往低位移
 * 
 * $ C中位运算级别很低,注意要加上括号
 * .
 */

#include<vector>
namespace bitset
{
	template<size_t N> // 非类型模板参数
	class bitset //位图可以叫做bitmap好点,不过stl叫做bitset
	{

		
		/** 位图
		 * 位图功能:
		 * $ 能够操作比特位,在某些场景下能使消耗空间大大 减小,足以容纳进内存,快速执行
		 * 
		 * 
		 * 需要实现的功能:
		 * 1.接收数用于开辟多大空间 -- 非类型模板参数 -- 不过应该设置成固定值,因为传进来的数据是随机的,可能很大可能很小,一般都开设size_t -1(最大值)个空间
		 * 2.能够对位图某一比特位 置零 -- reset
		 * 3.能够对位图某一比特位 置1  -- set
		 * 4.能够得知某一比特位是0还是1 -- return bool ret
		 * 
		 * 成员
		 * 1.成员:char数组 - vectot
		 * 
		 * 
		 */
		std::vector<char> _bits;

		bitset()
		{
			_bits.resize(N / 8 + 1);//
		}
		



	};


}




